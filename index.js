/*! For license information please see index.js.LICENSE.txt */
(()=>{var n={245:()=>{function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n(t)}function t(t,e){for(var i=0;i<e.length;i++){var l=e[i];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(t,(void 0,r=function(t,e){if("object"!==n(t)||null===t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var l=i.call(t,"string");if("object"!==n(l))return l;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(l.key),"symbol"===n(r)?r:String(r)),l)}var r}function e(n){var t="function"==typeof Map?new Map:void 0;return e=function(n){if(null===n||(e=n,-1===Function.toString.call(e).indexOf("[native code]")))return n;var e;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,l)}function l(){return i(n,arguments,a(this).constructor)}return l.prototype=Object.create(n.prototype,{constructor:{value:l,enumerable:!1,writable:!0,configurable:!0}}),r(l,n)},e(n)}function i(n,t,e){return i=l()?Reflect.construct.bind():function(n,t,e){var i=[null];i.push.apply(i,t);var l=new(Function.bind.apply(n,i));return e&&r(l,e.prototype),l},i.apply(null,arguments)}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function r(n,t){return r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},r(n,t)}function a(n){return a=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},a(n)}var s=document.querySelector("#page"),o=function(e){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&r(n,t)}(u,e);var i,o,d,c,p=(d=u,c=l(),function(){var t,e=a(d);if(c){var i=a(this).constructor;t=Reflect.construct(e,arguments,i)}else t=e.apply(this,arguments);return function(t,e){if(e&&("object"===n(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(t)}(this,t)});function u(){var n;!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,u),(n=p.call(this)).addEventListener("click",(function(){s.classList.toggle("snow"),t=s.classList.contains("snow")?"snow":"net",localStorage.setItem("snow",t)}));var t=localStorage.getItem("snow")||"snow";return"snow"==t&&s.classList.add("snow"),n}return i=u,(o=[{key:"connectedCallback",value:function(){this.innerHTML='\n    <div id="snow_btn" class="snow_btn"></div>\n    '}}])&&t(i.prototype,o),Object.defineProperty(i,"prototype",{writable:!1}),u}(e(HTMLElement));customElements.define("snow-btn",o)}},t={};function e(i){var l=t[i];if(void 0!==l)return l.exports;var r=t[i]={exports:{}};return n[i](r,r.exports,e),r.exports}(()=>{"use strict";function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n(t)}function t(t,e){for(var i=0;i<e.length;i++){var l=e[i];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(t,(void 0,r=function(t,e){if("object"!==n(t)||null===t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var l=i.call(t,"string");if("object"!==n(l))return l;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(l.key),"symbol"===n(r)?r:String(r)),l)}var r}function i(n){var t="function"==typeof Map?new Map:void 0;return i=function(n){if(null===n||(e=n,-1===Function.toString.call(e).indexOf("[native code]")))return n;var e;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,i)}function i(){return l(n,arguments,s(this).constructor)}return i.prototype=Object.create(n.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),a(i,n)},i(n)}function l(n,t,e){return l=r()?Reflect.construct.bind():function(n,t,e){var i=[null];i.push.apply(i,t);var l=new(Function.bind.apply(n,i));return e&&a(l,e.prototype),l},l.apply(null,arguments)}function r(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function a(n,t){return a=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},a(n,t)}function s(n){return s=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},s(n)}var o=function(e){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&a(n,t)}(p,e);var i,l,o,d,c=(o=p,d=r(),function(){var t,e=s(o);if(d){var i=s(this).constructor;t=Reflect.construct(e,arguments,i)}else t=e.apply(this,arguments);return function(t,e){if(e&&("object"===n(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(t)}(this,t)});function p(){return function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,p),c.call(this)}return i=p,(l=[{key:"connectedCallback",value:function(){this.innerHTML='<div class="container"> <header class="header"> <h1>DSR (Doing Software Right)</h1> <div class="snow-right"> <snow-btn></snow-btn> </div> <article class="article"> <h2>C++: Начала программирования</h2> </article> </header> </div> '}}])&&t(i.prototype,l),Object.defineProperty(i,"prototype",{writable:!1}),p}(i(HTMLElement));function d(n){return d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},d(n)}function c(n,t){for(var e=0;e<t.length;e++){var i=t[e];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,(void 0,l=function(n,t){if("object"!==d(n)||null===n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var i=e.call(n,"string");if("object"!==d(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(i.key),"symbol"===d(l)?l:String(l)),i)}var l}function p(n){var t="function"==typeof Map?new Map:void 0;return p=function(n){if(null===n||(e=n,-1===Function.toString.call(e).indexOf("[native code]")))return n;var e;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,i)}function i(){return u(n,arguments,f(this).constructor)}return i.prototype=Object.create(n.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),h(i,n)},p(n)}function u(n,t,e){return u=m()?Reflect.construct.bind():function(n,t,e){var i=[null];i.push.apply(i,t);var l=new(Function.bind.apply(n,i));return e&&h(l,e.prototype),l},u.apply(null,arguments)}function m(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function h(n,t){return h=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},h(n,t)}function f(n){return f=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},f(n)}customElements.define("header-component",o),e(245);var v=function(n){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&h(n,t)}(a,n);var t,e,i,l,r=(i=a,l=m(),function(){var n,t=f(i);if(l){var e=f(this).constructor;n=Reflect.construct(t,arguments,e)}else n=t.apply(this,arguments);return function(n,t){if(t&&("object"===d(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}(this,n)});function a(){return function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,a),r.call(this)}return t=a,(e=[{key:"connectedCallback",value:function(){this.innerHTML='<div class="container"> <section id="maincomponent"></section> </div> '}}])&&c(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),a}(p(HTMLElement));customElements.define("main-component",v);const g='<article class="article"> <p>Лекции проходят в главном корпусе ВГУ</p> <p>2024. Аудитория 435, по понедельникам с 18.40 до 20.00</p> <p>2025. Аудитория 329, по вторникам с 18.40 до 20.00</p> <p>Преподаватель - Коток Игорь Дмитриевич</p> <p>Факультет ПММ</p> </article> <article class="article"> <h2>Конспект лекций</h2> <p><a href="lec-1.html" class="js-dsr-lecture">Лекция 1 (16.09.2024)</a></p> <p><a href="lec-2.html" class="js-dsr-lecture">Лекция 2 (23.09.2024)</a></p> <p><a href="lec-3.html" class="js-dsr-lecture">Лекция 3 (7.10.2024)</a></p> <p><a href="lec-4.html" class="js-dsr-lecture">Лекция 4 (14.10.2024)</a></p> <p><a href="lec-5.html" class="js-dsr-lecture">Лекция 5 (21.10.2024)</a></p> <p><a href="lec-6.html" class="js-dsr-lecture">Лекция 6 (5.11.2024)</a></p> <p><a href="lec-7.html" class="js-dsr-lecture">Лекция 7 (11.11.2024)</a></p> <p><a href="lec-8.html" class="js-dsr-lecture">Лекция 8 (18.11.2024)</a></p> <p><a href="lec-9.html" class="js-dsr-lecture">Лекция 9 (9.12.2024)</a></p> <p><a href="lec-10.html" class="js-dsr-lecture">Лекция 10 (16.12.2024)</a></p> <p><a href="lec-11.html" class="js-dsr-lecture">Лекция 11 (23.12.2024)</a></p> <p><a href="lec-12.html" class="js-dsr-lecture">Лекция 12 (11.02.2025)</a></p> <p><a href="lec-13.html" class="js-dsr-lecture">Лекция 13 (18.02.2025)</a></p> <p><a href="lec-14.html" class="js-dsr-lecture">Лекция 14 (04.03.2025)</a></p> <p><a href="lec-15.html" class="js-dsr-lecture">Лекция 15 (11.03.2025)</a></p> </article> ';var b=['<article class="article"> <h1>Лекция 1 (16.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#types">Типы данных</a></p> <p><a href="#base">Основы C++</a></p> <p><a href="#rus">Подключение русской локализации</a></p> <p><a href="#task1">Задача 1. Найти периметр треугольника заданного координатами своих вершин</a></p> <p><a href="#task2">Задача 2. Найти сумму членов арифметической прогрессии</a></p> <p><a href="#task3">Задача 3. Найти сумму членов геометрической прогрессии</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Знакомство</li> <li>Ход курса</li> <li>Типы данных</li> <li>Основы C++</li> </ol> <ol> <li>Теория</li> <li>Практика</li> <li>Домашка</li> </ol> </article> <article class="article"> <div class="anchor" id="types"></div> <h3>Типы данных</h3> <h4>Базовые типы</h4> <ol> <li>bool</li> <li>int</li> <li>float</li> <li>char</li> </ol> <h4>Числовые типы</h4> <ol> <li>short 2 байта</li> <li>int 2-4 байта</li> <li>long 4-8 байт</li> <li>long long 8 байт</li> <li>float 4 байта</li> <li>double 8 байт</li> <li>long double 8+ байт</li> </ol> <h4>Символьные типы</h4> <ol> <li>char 1 байт (ASCII)</li> <li>wchar_t 2-4 байта</li> <li>char8_t 1 байт</li> <li>char16_t 2 байта</li> <li>char32_t 4 байта</li> </ol> <p>Раньше строковые типы данных представлялись массивами типа char</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout &lt;&lt; "Hello, world!\\n";\n  return 0;\n}\n</pre> <p>Output</p> <code>Hello, world!</code> </article> <article class="article"> <div class="anchor" id="base"></div> <h3>Основы C++</h3> <p>Необходимо установить Visual Studio Community</p> <p>Фигурные скобки {} нужно использовать везде где есть логические блоки</p> <h4>Объявление переменной</h4> <p>При объявлении переменной сначала пишут тип данных потом название переменной. При объявлении переменной компилятор выделяет область памяти, размером указанного типа данных, для значения переменной</p> <code>int valInt;</code> <h4>Инициализация переменной</h4> <p>Можно сразу при объявлении инициализировать переменную значением по умолчанию. Для типа int это 0</p> <code>int valInt{}; // 0</code> <p>Можно инициализировать переменную значением</p> <pre>\nint valInt2 = 5;\nint valInt3(6);\nint valInt4{12};\n</pre> <p>Инициализация через {} безопасная, при неправильном значении проект даже не запустится</p> <h4>Операторы ввода и вывода</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int count;\n  std::cout &lt;&lt; "Введите количество кроликов" &lt;&lt; std::endl;\n  std::cin &gt;&gt; count;\n  std::cout &lt;&lt; "Количество кроликов " &lt;&lt; count;\n\n  return 0;\n}\n</pre> <h4>Количество байт, выделенные под переменные</h4> <code>sizeof(bool)</code> <code>sizeof(int)</code> <code>sizeof(double)</code> <h4>Использование namespase std нежелательно</h4> <code>namespace std; // нежелательно, потому что могут совпадать имена</code> <h4>Возведение в квадрат</h4> <code>a * a; // хорошо</code> <code>pow(a, 2); хуже, потому что выделяется лишняя память</code> <h4>Приостановить действие программы</h4> <code>system("pause");</code> <h4>Очистить поток ввода</h4> <code>std::cin.clear();</code> <code>std::cin.ignore(32767,n);</code> <code>std::cin.get</code> </article> <article class="article"> <div class="anchor" id="rus"></div> <h3>Подключение русской локализации</h3> <p>Если файл не в кодировке UTF-8, то можно подключить русскую локализацию</p> <code>setlocale(LC_ALL, "Russian");</code> <p>Если файл в кодировке UTF-8, то также используют функцию <strong>setlocale()</strong>. В UTF-8 для каждого символа отводится не 1 байт, а 2 или 4 байта. Поэтому нужно использовать другой формат вывода. Вместо объекта <strong>cout</strong> применяется объект <strong>wcout</strong>, который работает с символами Unicode. А перед строкой надо указать символ <strong>L</strong></p> <pre>\n#include &lt;iostream&gt;\nint main() {\n  setlocale(LC_ALL, "");\n  std::wcout &lt;&lt; L"Привет, мир!";\n  return 0;\n}\n</pre> <p>Output</p> <code>Привет, мир!</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найти периметр треугольника заданного координатами своих вершин</h3> <p>Треугольник задан на плоскости координатами своих вершин. Найти его периметр</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x1, x2, x3, y1, y2, y3, a, b, c, p;\n\n  std::cout &lt;&lt; "Введите первую вершину x1 y1" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x1 &gt;&gt; y1;\n  std::cout &lt;&lt; "Введите вторую вершину x2 y2" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x2 &gt;&gt; y2;\n  std::cout &lt;&lt; "Введите третью вершину x3 y3" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x3 &gt;&gt; y3;\n\n  a = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n  b = sqrt((x2-x3)*(x2-x3) + (y2-y3)*(y2-y3));\n  c = sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3));\n  p = a+b+c;\n\n  std::cout &lt;&lt; "Периметр " &lt;&lt; p &lt;&lt; std::endl;\n  return 0;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Найти сумму членов арифметической прогрессии</h3> <p>Дана арифметическая прогрессия</p> <code>10 20 30 40 50</code> <p>Первый член 10, шаг 10, количество членов 5</p> <p>Найти сумму членов арифметической прогрессии Sa</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double a1, d, na, Sa;\n  a1 = 10;\n  d = 10;\n  na = 5;\n\n  Sa = (2*a1+d*(na-1))/2*na;\n\n  std::cout &lt;&lt; Sa;\n}\n</pre> <p>Output</p> <code>150</code> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Найти сумму членов геометрической прогрессии</h3> <p>Дана геометрическая прогрессия</p> <code>10 20 40 80 160</code> <p>Первый член 10, множитель 2, количество членов 5</p> <p>Найти сумму членов геометрической прогрессии Sb</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n  double b1, q, nb, Sb;\n  b1 = 10;\n  q = 2;\n  nb = 5;\n\n  Sb = b1*(1-pow(q,nb))/(1-q);\n\n  std::cout &lt;&lt; Sb;\n}\n</pre> <p>Output</p> <code>310</code> </article> ','<article class="article"> <h1>Лекция 2 (23.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#conv">Преобразования типов</a></p> <p><a href="#task1">Задача 1. Дальнобойщик</a></p> <p><a href="#oper">Операции</a></p> <p><a href="#if">Условие if-else</a></p> <p><a href="#task2">Задача 2. Количество набранных очков</a></p> <p><a href="#task3">Задача 3. Площадь заштрихованной области</a></p> <p><a href="#switch">Условие switch-case</a></p> <p><a href="#task4">Задача 4. Принадлежит ли точка заштрихованной области</a></p> </article> <article class="article"> <div class="anchor" id="conv"></div> <h3>Преобразования типов</h3> <h4>Неявные преобразования типов</h4> <p>bool принимает другой тип</p> <code>bool flag_1 = 3; // true</code> <code>bool flag_2 = 2.5; // true</code> <code>bool flag_3 = 0; // false</code> <p>другой тип приниимает bool</p> <code>int var_int = true; // 1</code> <code>double var_double = false; // 0.00000</code> <p>целочисленное принимает вещественное</p> <code>int var_int_1 = 3.4; // 3</code> <code>int var_int_2 = 6.7; // 6</code> <p>вещественное принимает целочисленное</p> <code>float var_float = 324234222; // 324234208</code> <code>double var_double = 120000000000000011; // 1.2000000000000002e+17</code> <p>Если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается</p> <p>беззнаковые переменные принимают выходящие из диапазона</p> <code>unsigned char a = -5; // 251</code> <code>unsigned short b = -12; // 65524</code> <code>int c = -1; // 4294967295</code> <h4>Безопасные преобразования</h4> <p>bool - char - short - int - double - long double</p> <p>bool - char - short - int - long - long long</p> <p>unsigned char - unsigned short - unsigned int - unsigned long</p> <p>float - double - long double</p> <p>В арифметических операциях из двух типов выбирается максимальный и к нему приводится наименьший из них</p> <h4>Явные преобразования типов</h4> <p>Есть два способа язвного преобразования типа</p> <ol> <li><strong>(type) (value)</strong></li> <li><strong>static_cast&lt;type&gt;(value)</strong></li> </ol> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Дальнобойщик</h3> <p>Дальнобойщик проехал расстояние 130.21км со средней скоростью 8 км/ч. Сколько часов необходимо оплатить ему за проделанную поездку?</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double distance{ 130.21 };\n  unsigned int speed{ 8 };\n\n  unsigned int hours{ (unsigned int) (distance / speed) };\n\n  std::cout &lt;&lt; "Hours = "\n            &lt;&lt; hours &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Hours = 16</code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double distance{ 130.21 };\n  unsigned int speed{ 8 };\n\n  unsigned int hours{ static_cast&lt;unsigned int&gt;(distance / speed) };\n\n  std::cout &lt;&lt; "Hours = "\n            &lt;&lt; hours &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Hours = 16</code> </article> <article class="article"> <div class="anchor" id="oper"></div> <h3>Операции</h3> <h4>Базовые арифметические операции</h4> <p>Сложение a + b</p> <p>Вычитание a - b</p> <p>Умножение a * b</p> <p>Деление a / b</p> <p>Остаток от деления a % b</p> <h4>Операторы присваивания</h4> <p>a += b</p> <p>a -= b</p> <p>a *= b</p> <p>a /= b</p> <p>a %= b</p> <h4>Инкремент и декремент</h4> <p>префиксный инкремент ++a</p> <p>постфиксный инкремент a++</p> <p>префиксный декремент --a</p> <p>постфиксный декремент a--</p> <h4>Внимание подстава!</h4> <pre>\nint a{ 3 };\nint new_a{ --a };\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl; // a = 2\nstd::cout &lt;&lt; "new_a = " &lt;&lt; new_a &lt;&lt; std::endl; // new_a = 2\n</pre> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Приоритет операций</h4> <ol> <li>++, -- (инкремент, декремент)</li> <li>* (умножение), / (деление), % (остаток от деления)</li> <li>+ (сложение), - (вычитание)</li> </ol> <h4>Неоднозначный пример</h4> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Операции сравнения</h4> <p>a == b равно</p> <p>a &lt; b меньше</p> <p>a &lt;= b меньше или равно</p> <p>a &gt; b больше</p> <p>a &gt;= b больше или равно</p> <p>a != b не равно</p> <h4>Операции сравнения</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1{ a == b }; // false</code> <code>bool F2{ a &lt; b }; // true</code> <code>bool F3{ a &lt;= b }; // true</code> <code>bool F4{ a &gt; b }; // false</code> <code>bool F5{ a &gt;= b }; // false</code> <code>bool F6{ a != b }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> <h4>Логические операции</h4> <p>!a отрицание</p> <p>a && b И</p> <p>a || b ИЛИ</p> <p>a ^ b Исключающее ИЛИ</p> <h4>Логические операции</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1( a == b && b > 3 }; // false</code> <code>bool F2( a != b || a == 3 }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> </article> <article class="article"> <div class="anchor" id="if"></div> <h3>Условие if-else</h3> <h4>if</h4> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\n</pre> <h4>if - else</h4> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a &lt;= b\\n";\n}\n</pre> <h4>if - else if - else</h4> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse if (a &lt; b)\n{\n  std::cout &lt;&lt; "a &lt; b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a == b\\n";\n}\n</pre> <h4>Тернарный оператор</h4> <code>a > b ? a++ : b++;</code> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Количество набранных очков</h3> <p>Определить по введенным пользователем координатам попадания выстрела в мишень количество набранных очков</p> <p>3 очка если попали в круг радиусом 5 с центром в (0, 0)</p> <p>2 очка если попали в круг радиусом 10</p> <p>1 очко если попали в круг радиусом 15</p> <h4>Решение</h4> <p>Точка с координатами x, y попадет в круг радиуса r, если расстояние от центра круга до точки меньше r. То есть должно выполняться условие</p> <code>x<sup>2</sup> + y<sup>2</sup> &lt;= r<sup>2</sup></code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  // объявление и инициализация переменных\n  double x{}, y{};\n  int score{};\n\n  // заполнение переменных\n  std::cout &lt;&lt; "Input coords x y\\n";\n  std::cin >> x >> y;\n\n  // Проверка на попадание\n  if (x * x + y * y &lt;= 5 * 5)\n  {\n    score = 3;\n  }\n  else if (x * x + y * y &lt;= 10 * 10)\n  {\n    score = 2;\n  }\n  else if (x * x + y * y &lt;= 15 * 15)\n  {\n    score = 1;\n  }\n\n  // Вывод результатов работы\n  if (score > 0)\n  {\n    std::cout &lt;&lt; "Congratulations! Score = " &lt;&lt; score &lt;&lt; "\\n";\n  }\n  else{\n    std::cout &lt;&lt; "Try again\\n";\n  }\n}\n</pre> <h4>Можно использовать условие</h4> <code>if (score)</code> <p>Потому что score может принимать значения только 0, 1, 2, 3.</p> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Площадь заштрихованной области</h3> <p>Заштрихованная область находится внутри большого круга радиусом 3 с центром в (0, 0) и вне малкенького круга радиусом 1.5 с центром в (0, 1.5)</p> <p>Вычислить значение площади заштрихованной области, если точка с заданными координатами (x, y) попадает в эту область. В противном случае вывести соответствующее сообщение</p> <h4>Решение</h4> <p>Чтобы точка с координатами x, y попала в заштрихованную область должны выполниться два условия. Первое точка должна попасть в круг радиуса R. Второе точка должна не попасть в круг радиуса r с центром rx, ry. То есть</p> <code>x<sup>2</sup> + y<sup>2</sup> &lt;= R<sup>2</sup></code> <code>(x - rx)<sup>2</sup> + (y - ry)<sup>2</sup> &gt;= r<sup>2</sup></code> <p>Площадь заштрихованной области равна площади круга радиуса R минус площадь круга радиуса r</p> <code>pi * R<sup>2</sup> - pi * r<sup>2</sup></code> <pre>\n#define _USE_MATH_DEFINES\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  // объявление и инициализация переменных\n  double x{}, y{}, s{};\n\n  // заполнение переменных\n  std::cout &lt;&lt; "Input x y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  // Проверка на попадание\n  if (x * x + y * y &lt;= 9 && x * x + (y + 1.5) * (y + 1.5) >= 2.25)\n  {\n    std::cout &lt;&lt; "Square =  " &lt;&lt; M_PI * 9 - M_PI * 2.25;\n  }\n  else\n  {\n    std::cout &lt;&lt; "Try again" &lt;&lt; std::endl;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="switch"></div> <h3>Условие switch-case</h3> <pre>\nswitch (/*выражение*/)\n{\n  case // значение1: инструкции1; break;\n  case // значение2: инструкции2; break;\n  default: // инструкции;\n}\n</pre> <h4>Пример реализации</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int counter{ 2 };\n\n  switch (counter)\n  {\n    case 1:\n      std::cout &lt;&lt; "counter = 1" &lt;&lt; std::endl;\n      break;\n    case 2:\n      std::cout &lt;&lt; "counter = 2" &lt;&lt; std::endl;\n      break;\n    case 3:\n      std::cout &lt;&lt; "counter = 3" &lt;&lt; std::endl;\n      break;\n    default:\n      std::cout &lt;&lt; "counter is undefined" &lt;&lt; std::endl;\n      break;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Принадлежит ли точка заштрихованной области</h3> <p>Заштрихованная область ограничена сверху графиком функции y = 2 - x<sup>2</sup>. При x &lt; 0 ограничена снизу функцией y = x. При x &gt;= 0 ограничена снизу функцией y = 0.</p> <p>Требуется написать программу, которая принимает с клавиатуры координаты точки на плоскости (x, y - вещественные числа) и определяет принадлежность точки заштрихованной области, включая ее границы</p> <p>Пояснение</p> <p>Область C лежит в первой четверти (x >= 0, y >= 0). Ограничена сверху графиком y = x. Ограничена снизу графиком y = 0</p> <p>Область G лежит в третьей четверти (x &lt 0, y &lt 0). Ограничена сверху графиком y = x. Ограничена снизу графиком y = 2 - x<sup>2</sup></p> <p>Нужно отдельно проверить через switch попадание в области C и G. Пользователю выводится меню, где указано "Чтобы проверить точку G введите 1" и т.д. switch обрабатывает запрос пользователя и выдает результат проверки на попадание в запрашиваемую область</p> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  // объявление и инициализация переменных\n  double x{}, y{}, s{};\n  int command{};\n\n  // заполнение переменных\n  std::cout &lt;&lt; "Input x y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  // ввод команды\n  std::cout &lt;&lt; "Check all area - press 1" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Check C-area - press 2" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Check G-area - press 3" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Press 1 or 2 or 3" &lt;&lt; std::endl;\n  std::cin >> command;\n\n  switch (command)\n  {\n    case 1:\n      if (x&lt;=0 && y>=x && y &lt;= 2-x*x || x>0 && y&lt;=2-x*x && y>=0)\n      {\n        std::cout &lt;&lt; "In the area\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Out of the area\\n";\n      }\n      break;\n    case 2:\n      if (y&lt;=x && y&lt;=2-x*x && x>0 && y>=0)\n      {\n        std::cout &lt;&lt; "In the C-area\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Out of the C-area\\n";\n      }\n      break;\n    case 3:\n      if (y&lt;=x && y>=2-x*x && y&lt;=0)\n      {\n        std::cout &lt;&lt; "In the G-area\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Out of the G-area\\n";\n      }\n      break;\n    default:\n      std::cout &lt;&lt; "Invalid command\\n";\n  }\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 3 (7.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#while">Цикл while</a></p> <p><a href="#task1">Задача 1. Найти сумму чисел от 1 до 100</a></p> <p><a href="#while2">Вложенный цикл while</a></p> <p><a href="#task2">Задача 2. Вывести таблицу умножения от 1 до 9 while</a></p> <p><a href="#loop">Бесконечные циклы</a></p> <p><a href="#for">Цикл for</a></p> <p><a href="#task3">Задача 3. Вывести квадраты четных чисел от 0 до 20</a></p> <p><a href="#task4">Задача 4. Вывести таблицу умножения от 1 до 9 for</a></p> <p><a href="#task5">Задача 5. Просуммировать все числа от 1 до n</a></p> <p><a href="#dowhile">Цикл do-while</a></p> <p><a href="#task6">Задача 6. Вычитать случайное число</a></p> <p><a href="#bad">Обработка "плохих" данных</a></p> <p><a href="#task7">Задача 7. Вычислить сумму числовой последовательности</a></p> <p><a href="#task8">Задача 8. Вычислить сумму числовой последовательности</a></p> <p><a href="#task9">Задача 9. Вычислить сумму числовой последовательности</a></p> </article> <article class="article"> <div class="anchor" id="while"></div> <h3>Цикл while</h3> <h4>Определение цикла while</h4> <pre>\nwhile (/*выражение*/)\n{\n  //тело_цикла\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найти сумму чисел от 1 до 100</h3> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int i = 0;\n  int sum = 0;\n\n  while (i &lt; 100)\n  {\n    i++;\n    sum += i;\n  }\n\n  std::cout &lt;&lt; "Sum from 1 to 100 = "\n            &lt;&lt; sum &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Sum from 1 to 100 = 5050</code> </article> <article class="article"> <div class="anchor" id="while2"></div> <h3>Вложенный цикл while</h3> <h4>Определение вложенных циклов</h4> <pre>\nwhile (/*выражение1*/)\n{\n  //тело_цикла1\n  while (/*выражение2*/)\n  {\n    //тело_цикла2\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Вывести таблицу умножения от 1 до 9</h3> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы while</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int a{}, b{};\n\n  while (a &lt; 10)\n  {\n    while (b &lt; 10)\n    {\n      std::cout &lt;&lt; a &lt;&lt; "\\tx\\t" &lt;&lt; b\n                &lt;&lt; "\\t=\\t" &lt;&lt; a * b &lt;&lt; std::endl;\n      b++;\n    }\n    std::cout &lt;&lt; std::endl;\n    a++;\n    b = 0;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="loop"></div> <h3>Бесконечные циклы</h3> <pre>\nwhile (true)\n{\n  // этот цикл будет выполняться бесконечно\n}\n</pre> <pre>\nint count = 12;\n\nwhile (count &lt; 20) // всегда будет true\n{\n  std::cout &lt;&lt; count &lt;&lt; " "; // эта строка будет выполняться бесконечно\n}\nreturn 0; // эта строка никогда не выполнится\n</pre> <p>Единственный способ выйти из бесконечного цикла - использовать операторы return, break, goto, выбросить исключение или воспользоваться функцией exit()</p> <h4>continue</h4> <p>Нужно вывести все четные числа от 0 до 30</p> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 == 0)\n  {\n    std::cout &lt;&lt; i &lt;&lt; " ";\n  }\n}\n</pre> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 != 0)\n  {\n    continue;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <h4>break</h4> <pre>\nwhile (i != 0)\n{\n  i--;\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nwhile (1)\n{\n  i--;\n  if (i == 0)\n  {\n    break;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nint count = 1;\nwhile (count &lt;= 50)\n{\n  if (count &lt; 10)\n  {\n    std::cout &lt;&lt; "0" &lt;&lt; count &lt;&lt; " ";\n  }\n  else\n  {\n    std::cout &lt;&lt; count &lt;&lt; " "\n  }\n  if (count % 10 == 0)\n  {\n    std::cout &lt;&lt; "\\n";\n  }\n  ++count;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="for"></div> <h3>Цикл for</h3> <h4>Определение цикла for</h4> <pre>\nfor (/*объявление_переменных*/;/*условие*/;/*инкремент_декремент*/)\n{\n  //тело цикла\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Вывести квадраты четных чисел от 0 до 20</h3> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int num{20};\n\n  for (int i = 0; i &lt; num; i++)\n  {\n    if (i % 2 == 0)\n    {\n      std::cout &lt;&lt; i * i &lt;&lt; " ";\n    }\n  }\n}\n</pre> <p>Output</p> <code>0 4 16 36 64 100 144 196 256 324</code> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Вывести таблицу умножения от 1 до 9</h3> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы for</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  for (int i{1}; i &lt; 10; i++)\n  {\n    for (int j{1}; j &lt; 10; j++)\n    {\n      std::cout &lt;&lt; i &lt;&lt; "\\t x \\t" &lt;&lt; j\n                &lt;&lt; "\\t = \\t" &lt;&lt; i * j &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task5"></div> <h3>Задача 5. Просуммировать все числа от 1 до n</h3> <p>Напишите программу, где пользователь вводит любое целое положительное число. А программа суммирует все числа от 1 до введенного пользователем числа.</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  unsigned int n{};\n  int sum{};\n\n  std::cout &lt;&lt; "Input n ";\n  std::cin >> n;\n\n  for (int i{1}; i &lt;= n; i++)\n  {\n    sum += i;\n  }\n\n  std::cout &lt;&lt; "Sum from 1 to " &lt;&lt; n &lt;&lt; " = "\n            &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="dowhile"></div> <h3>Цикл do-while</h3> <h4>Определение цикла</h4> <pre>\ndo {\n  //тело_цикла\n} while (//условие);\n</pre> </article> <article class="article"> <div class="anchor" id="task6"></div> <h3>Задача 6. Вычитать случайное число</h3> <h4>Библиотека ctime, функции srand(), rand()</h4> <p>Библиотека ctime содержит функции srand(), rand(). Функция srand() устанавливает зерно. Функция rand() вычисляет псевдослучайное число относительно зерна. По умолчанию зерно равно 0.</p> <p>Дано целое число balance = 8. Вычитать из него случайное целое число от 0 до 3, пока balance не станет равным нулю.</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nint main()\n{\n  srand(time(0));\n  int balance = 8;\n\n  do\n  {\n    std::cout &lt;&lt; "balance = " &lt;&lt; balance &lt;&lt; std::endl;\n    int removal = rand() % 3;\n    std::cout &lt;&lt; "removal = " &lt;&lt; removal &lt;&lt; std::endl;\n    balance -= removal;\n  } while (balance > 0);\n\n  std::cout &lt;&lt; "balance = " &lt;&lt; balance &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="bad"></div> <h3>Обработка "плохих" данных</h3> <h4>Оператор извлечения</h4> <p>Если во входном буфере есть данные, то эти данные используются для извлечения.</p> <p>Если во входном буфере нет данных, то пользователю предлагается ввести данные (обычно именно это и происходит в большинстве случаев). Когда пользователь нажимает Enter, символ новой строки \\n помещается во входной буфер</p> <h4>Оператор извлечения &gt;&gt;</h4> <p>Оператор &gt;&gt; извлекает столько данных из входного буфера в переменную, сколько позволяет размер самой переменной (игнорируя любые пробелы, табы и \\n)</p> <p>Любые данные, которые не были извлечены остаются во входном буфере для последующего извлечения</p> <pre>\nint a;\nstd::cin &gt;&gt; a;\n</pre> <p>Пользователь вводит 21Z. 21 записывается в переменную a, при этом в буфере остается Z\\n</p> <h4>Ошибка 1: Извлечение выполняется успешно, но данные бесполезны</h4> <pre>\nwhile (true) // пока пользователь не введет корректные данные\n{\n  std::cout &lt;&lt; "Enter \'+\', \'-\', \'*\', \'/\' :";\n  char sm;\n  std::cin &gt;&gt; sm;\n\n  // вывполняем проверку значений\n  if (sm == \'+\'\' || sm ==\'-\' || sm == \'*\' || sm == \'/\') {\n    return sm; // возвращаем данные в функцию main()\n  } else { // иначе, сообщаем что что-то пошло не так\n    std::cout &lt;&lt; "Invalid input. Try again.\\n";\n  }\n}\n</pre> <h4>Ошибка 2: Извлечение выполняется успешно, но пользователь вводит лишний текст</h4> <pre>\nstd::cout &lt;&lt; "Enter a double value: ";\ndouble a;\nstd::cin &gt;&gt; a;\nstd::cin.ignore(32767, \'\\n\'); // удаляем до 32767 символов\n// из входного буфера вплоть до появления символа \'\\n\'\n\nstd::cin.ignore(std::cin.rdbuf()->in_avail());\n// зачищаем только то, что использовано\n</pre> <h4>Ошибка 3: Извлечение не выполняется</h4> <pre>\nwhile (true) // пока пользователь не введет корректное значение1\n{\n  std::cout &lt;&lt; "Enter a double value: ";\n  double a;\n  std::cin &gt;&gt; a;\n\n  if (std::cin.fail()) // если предыдущее значение оказалось неудачным\n  {\n    std::cin.clear(); // возвращаем cin в обычный режим работы\n    std::cin.ignore(32767, \'\\n\'); // удаляем значения предыдущего ввода из входного буфера\n  }\n  else // если все хорошо, выходим используя break\n  {\n    std::cin.ignore(32767, \'\\n\');\n    break;\n  }\n}\n</pre> <h4>Ошибка 4: Извлечение выполняется успешно, но пользователь ввел слишком большое числовое значение</h4> <pre>\nstd::int16_t x{ 0 };\n// переменная x занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number x between -32768 and 32767: ";\nstd::cin &gt;&gt; x;\n\nstd::int16_t y{ 0 };\n// переменная y занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number y between -32768 and 32767: ";\nstd::cin &gt;&gt; y;\n\nstd::cout &lt;&lt; "The sum is: " &lt;&lt; x + y &lt;&lt; \'\\n\';\n</pre> </article> <article class="article"> <div class="anchor" id="task7"></div> <h3>Задача 7. Вычислить сумму числовой последовательности</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>1 + 1/3 + 1/(3<sup>2</sup>) + ... + 1/(3<sup>8</sup>)</code> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double sum {1};\n  double denominator {1};\n\n  for (int i = 0; i &lt; 8; i++)\n  {\n    denominator *= 3;\n    sum += 1 / denominator;\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> <p>Output</p> <code>1.49992</code> </article> <article class="article"> <div class="anchor" id="task8"></div> <h3>Задача 8. Вычислить сумму числовой последовательности</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>x + x<sup>3</sup>/3 + x<sup>5</sup>/5 + ... + x<sup>11</sup>/11</code> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double sum {};\n  int n {5};\n  double x {2.0};\n  double temp = x;\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += temp;\n    temp = temp * (2 * i - 1) * x * x / (2 * i + 1);\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> <p>Output</p> <code>-115.41</code> </article> <article class="article"> <div class="anchor" id="task9"></div> <h3>Задача 9. Вычислить сумму числовой последовательности</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>e<sup>x</sup> = 1 + x + x<sup>2</sup>/2! + x<sup>3</sup>/3! + x<sup>4</sup>/4! + ...</code> <code>cos x = 1 - x<sup>2</sup>/2! + x<sup>4</sup>/4! + x<sup>6</sup>/6! + ...</code> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! + x<sup>7</sup>/7! + ...</code> </article> ','<article class="article"> <h1>Лекция 4 (14.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#ref">Ссылки</a></p> <p><a href="#point">Указатели</a></p> <p><a href="#t1">Практика. Sum(int, int)</a></p> <p><a href="#t2">Практика. Max(int, int)</a></p> <p><a href="#t3">Практика. Swap(int&, int&)</a></p> <p><a href="#t4">Практика. Print()</a></p> <p><a href="#t5">Практика. Swap(int*, int*)</a></p> <p><a href="#t6">Практика. Sum(int, int, int = 3)</a></p> <p><a href="#t7">Практика. init(int*)</a></p> <p><a href="#t8">Практика. init(int*&)</a></p> </article> <article class="article"> <div class="anchor" id="ref"></div> <h3>Ссылки</h3> <h4>Определение ссылки</h4> <code>тип_данных & название_ссылки = переменная_типа_ссылки;</code> <pre>\nint main()\n{\n  int a = 3;\n  int &refa = a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 3\n\n  refa++;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 4\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 4\n}\n</pre> </article> <article class="article"> <div class="anchor" id="point"></div> <h3>Указатели</h3> <h4>Определение указателя</h4> <code>тип_данных * название_указателя;</code> <pre>\nint main()\n{\n  int a = 3;\n  int *pointA = &amp;a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl;\n\n  std::cout&lt;&lt;&a&lt;&lt;std::endl; // 000000C2E6DAFBF4\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl; //\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;*pointA&lt;&lt;std::endl; // 3\n}\n</pre> <h4>Указатель</h4> <p>Количество выделяемой памяти не изменяется в зависимости от типа переменных на которую ссылается указатель.</p> <pre>\nint *pint{};\ndouble *pdouble{};\n\nstd::cout&lt;&lt;sizeof(pint)&lt;&lt;std::endl; // 8\nstd::cout&lt;&lt;sizeof(pdouble)&lt;&lt;std::endl; // 8\n</pre> <h4>Указатель</h4> <pre>\nint a {10};\nint b {2};\n\nint *pa {&a};\nint *pb {&b};\n\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\nstd::cout&lt;&lt;"pb: address="&lt;&lt;pb&lt;&lt;"\\t value="&lt;&lt;*pb&lt;&lt;std::endl;\n\npa = pb;\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\n*pa = 125;\nstd::cout&lt;&lt;"b value="&lt;&lt;b&lt;&lt;std::endl;\n</pre> <code>pa: address=00000072CAFEFA54 value=10</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>b value=125</code> <h4>Указатель</h4> <pre>\nint a {10};\nint b {6};\n\nint *p{};\nint *&pRef {p};\n\npRef = &a;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n\n*pRef = 70;\nstd::cout&lt;&lt;"a value="&lt;&lt;a&lt;&lt;std::endl;\n\npRef = &b;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n</pre> <code>p value=10</code> <code>a value=70</code> <code>p value=6</code> <h4>Операторы new и delete</h4> <pre>\nint *ptr = new int;\nint *ptr_1 = new int();\nint *ptr_2 {new int(12)};\n\nstd::cout &lt;&lt; *ptr &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_2 &lt;&lt; std::endl;\n\ndelete ptr;\ndelete ptr_1;\ndelete ptr_2;\n\nptr = nullptr;\nptr_1 = nullptr;\nptr_2 = nullptr;\n</pre> <code>-842150451</code> <code>0</code> <code>12</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Sum(int, int)</h3> <p>Найдем сумму двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = a + b;\n}\n</pre> <p>Разделим программу на несколько файлов</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b) = " &lt;&lt; sum &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Практика. Max(int, int)</h3> <p>Добавим в проект функцию Max, возвращающую максимум из двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Max(a,b) = " &lt;&lt; max &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t3"></div> <h3>Практика. Swap(int&, int&)</h3> <p>Добавим в проект функцию Swap, которая ничего не возвращает, принимает адреса двух переменных и меняет местами их значения</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(&a, &b);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t4"></div> <h3>Практика. Print()</h3> <p>Добавим вывод на экран слова Bob. Добавим функцию Print, которая выводит на экран число, сколько раз функция Print вызывалась</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> <p>Статическая переменная i, объявленная внутри функции Print() инициализируется только один раз - при первом вызове функции. Она получает значение i = 0. При повторных вызовах, инициализация не производится.</p> </article> <article class="article"> <div class="anchor" id="t5"></div> <h3>Практика. Swap(int*, int*)</h3> <p>Перепишем функцию Swap(), при которой она будет принимать не адреса, а указатели на две переменные.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  int *pa = &a;\n  int *pb = &b;\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(pa, pb);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t6"></div> <h3>Практика. Sum(int, int, int = 3)</h3> <p>Перепишем функцию Sum(), при которой она будет принимать не два, а три параметра. Причем третий параметр будет необязательным и в случае его отсутствия будет подставляться значение по умолчанию.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "default c = " &lt;&lt; 3 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,c) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  sum = Sum(a, b, 25);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,25) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int, int = 3);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y, int z)\n{\n  return x + y + z;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t7"></div> <h3>Практика. init(int*)</h3> <p>Напишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t8"></div> <h3>Практика. init(int*&)</h3> <p>Перепишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(&a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article>','<article class="article"> <h1>Лекция 5 (21.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#func">Перегрузка функции</a></p> <p><a href="#const1">Константы</a></p> <p><a href="#const2">Указатели на константы</a></p> <p><a href="#const3">Константный указатель</a></p> <p><a href="#const4">Константный указатель на константу</a></p> <p><a href="#const5">Константные параметры</a></p> <p><a href="#const6">Константные ссылочные параметры</a></p> <p><a href="#const7">Вопросы по перегрузке</a></p> <p><a href="#t1">Практика. Сумма ряда</a></p> <p><a href="#t2">Код программы</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Ссылки и указатели</li> <li>Функции</li> <li>Массивы</li> </ol> </article> <article class="article"> <div class="anchor" id="func"></div> <h3>Перегрузка функции</h3> <p>Напишем функцию sum(), которая складывает два целых числа и функцию sum(), которая скаладывает два вещественных числа</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n</pre> <code>9</code> <code>4.1</code> <p>Добавим еще одну функцию sum(), которая складывает три целых числа, причем третий параметр не обязательный, при его отсутствии будет подставляться значение по умолчанию.</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\nint sum(int, int, int = 2);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n\nint sum(int a, int b, int c)\n{\n  return a + b + c;\n}\n</pre> <p>Компилятор не знает какую функцию запустить</p> </article> <article class="article"> <div class="anchor" id="const1"></div> <h3>Константы</h3> <p>const тип_данных & имя_переменной = значение_переменной</p> <p>Объявим константу с инициализацией, а потом попробуем присвоить ей новое значение</p> <pre>\nconst int a = 3;\na = 10; // нельзя\n</pre> <p>Компилятор не будет компилировать, потому что константе нельзя присвоить новое значение</p> <p>Объявим константу без инициализации, а потом попробуем ее инициализировать</p> <pre>\nconst int age; // нельзя\nage = 6;\n</pre> <p>Компилятор не будет компилировать, потому что константу нужно инициализировать только при объявлении.</p> </article> <article class="article"> <div class="anchor" id="const2"></div> <h3>Указатели на константы</h3> <p>const тип_данных * имя_указателя = адресс_переменной</p> <pre>\nconst int a {10};\nconst int *pa {&a};\n\nstd::cout &lt;&lt; "address = " &lt;&lt; pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 4; // нельзя\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nconst int b {45};\npa = &b; // можно\n\nstd::cout &lt;&lt; "*pa = " &lt;&lt; *pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\na = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n</pre> </article> <article class="article"> <div class="anchor" id="const3"></div> <h3>Константный указатель</h3> <p>тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nint *const pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\nint b {45};\npa = &b; // нельзя\n</pre> </article> <article class="article"> <div class="anchor" id="const4"></div> <h3>Константный указатель на константу</h3> <p>const тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nconst int *const pa {&a};\nint b {45};\n</pre> </article> <article class="article"> <div class="anchor" id="const5"></div> <h3>Константные параметры</h3> <pre>\nvoid square(int);\n//void square(const int);\n\nint main()\n{\n  int number {12};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int a)\n{\n  std::cout &lt;&lt; "a * a = " &lt;&lt; a * a &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 144</code> </article> <article class="article"> <div class="anchor" id="const6"></div> <h3>Константные ссылочные параметры</h3> <pre>\nvoid square(const int&);\n\nint main()\n{\n  const int number {6};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int &n)\n{\n  std::cout &lt;&lt; "n * n = " &lt;&lt; n * n &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 36</code> </article> <article class="article"> <div class="anchor" id="const7"></div> <h3>Вопросы по перегрузке</h3> <pre>\nvoid show(int);\nvoid show(int&);\n\nvoid print(int);\nvoid print(const int);\n\nint square(int*);\nint square(const int*);\n\nint square(int* num)\n{\n  return *num * *num;\n}\n\nint square(const int* num)\n{\n  return *num * *num;\n}\n</pre> <p>Компилятор не различает в данном случае & и const от простой реализации</p> <pre>\nconst int n1{2};\nint n2{3};\n\nint square_n1 {square(&n1)};\nint square_n2 {square(&n2)};\n\nstd::cout &lt;&lt; "square(n1) = " &lt;&lt; square_n1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; "square(n2) = " &lt;&lt; square_n2 &lt;&lt; std::endl;\n</pre> <code>4</code> <code>9</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Сумма ряда</h3> <p>Вычислить суммму ряда</p> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ...</code> <p>Для начала попробуем упростить выражение</p> <code>S<sub>n</sub> = sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ... + (-1)<sup>n</sup> * (x<sup>2n+1</sup>)/(2n+1)!</code> <code>q = a<sub>n</sub>/a<sub>n-1</sub></code> <code>q = (-1)<sup>n</sup> * x<sup>2n+1</sup>/(2n+1)! * (2n-1)!/(x<sup>2n-1</sup> * (-1)<sup>n-1</sup>)</code> <code>q = (-1)<sup>n-n+1</sup> * x<sup>2n+1-2n+1</sup> * (2n-1)!/(2n+1)!</code> <p>Так как</p> <code>n! = 1*2*3*...*n</code> <code>(n-1)! = 1*2*3*...*(n-1)</code> <p>То</p> <code>n! = (n-1)!*n</code> <p>Тогда</p> <code>(2n+1)! = (2n-1)! * 2n * (2n+1)</code> <p>Подставим это вместо (2n+1)!</p> <code>q = (-1) * x<sup>2</sup> * (2n-1)! / ((2n-1)! * 2n * (2n+1))</code> <code>q = (-1) * x<sup>2</sup> / (2n * (2n+1))</code> <h4>1 часть</h4> <p>Так как при i=0 множитель даст деление на 0, начинаем с 1, а самое первое значение заносим заранее в ai</p> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; i &lt; n; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <h4>2 часть</h4> <p>Посчитаем с погрешностью. Пусть погрешность будет очень маленькая величина</p> <code>eps = 1.0e-10;</code> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; abs(ai)>eps; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <p>С каждым шагом ai стремится к нашей точности eps, уменьшается. Чем выше точность eps (чем оно меньше), тем ближе к значению S<sub>точ</sub>. Таким образом мы считаем S<sub>n</sub>до тех пор, пока абсолютное значение ai не станет меньше eps</p> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Код программы</h3> <pre>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    std::cout &lt;&lt; "Введите 1- Сумма ряда" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 2- Сумма ряда c погрешностью" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 3- Завершение программы" &lt;&lt; std::endl;\n\n    bool isError{ true };\n    do {\n\n      std::cin >> choice;\n      if (!std::cin.fail()&& choice&lt;=3 && choice>=1)\n      {\n        isError = false;\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n      else\n      {\n        std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n        std::cin.clear();\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n\n    } while (isError);\n\n    if (choice != 3)\n    {\n      double x{};\n      isError = true;\n      do {\n\n        std::cout &lt;&lt; "Введите x " &lt;&lt; std::endl;\n        std::cin >> x;\n        if (!std::cin.fail())\n        {\n          isError = false;\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n        else\n        {\n          std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n          std::cin.clear();\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n\n      } while (isError);\n\n      if (choice == 1)\n      {\n\n        double Sn{};\n        int N{};\n        std::cout &lt;&lt; "Введите кол-во элементов ряда" &lt;&lt; std::endl;\n        std::cin >> N;\n        double ai{ x };\n        for (int i = 1; i &lt; N; i++)//ошибочка\n        {\n          Sn += ai;\n          ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n        }\n        std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; N\n        &lt;&lt; " элементах ряда =" &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n\n\n      }\n      else if (choice == 2)\n      {\n\n\n        int i{};\n        double eps = 1.0E-12;\n\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          double ai{ x };\n\n          for (i = 1; abs(ai) > eps; i++)\n          {\n            Sn += ai;\n            ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n          }\n          std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; i\n          &lt;&lt; " элементах ряда ="&lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n          std::cout &lt;&lt; "Точное значение" &lt;&lt; sin(x) &lt;&lt; std::endl;\n          eps /= 100;\n\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, другое - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n\n\n  } while (choice != 3);\n\n}\n</iomanip></iostream></pre> </article> ','<article class="article"> <h1>Лекция 6 (5.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#lamb">Лямбда-функции</a></p> <p><a href="#lamb1">Определение лямбда-функций</a></p> <p><a href="#lamb2">"Захват" лямбда-выражения</a></p> <p><a href="#lamb3">Примеры использования</a></p> <p><a href="#t1">Код программы</a></p> </article> <article class="article"> <div class="anchor" id="lamb"></div> <h3>Лямбда-функции</h3> </article> <article class="article"> <div class="anchor" id="lamb1"></div> <h3>Определение лямбда-функций</h3> <pre>\n     1   2     3       4       5\n     |   |     |       |       |\n    --- --- ------- ------- --------\n    [=] ()  mutable throw() -> int\n  |  {\n  |    int n = x + y;\n  |\n  |    x = y;\n6-|    y = n;\n  |\n  |    return n;\n  |  }\n</pre> <ol> <li>Capture clause - список внешних захватываемых параметров</li> <li>Список передаваемых параметров</li> <li>Спецификация изменений</li> <li>Спецификация исключений</li> <li>Тип возвращаемого значения</li> <li>Тело функции</li> </ol> </article> <article class="article"> <div class="anchor" id="lamb2"></div> <h3>"Захват" лямбда-выражения</h3> <ol> <li> <h4>По значению</h4> <pre>\nint n{10};\nstd::function&lt;void(int)&gt; add =\n       [=](int x) { std::cout &lt;&lt; x + n &lt;&lt; std::endl; };\n\nadd(5); // выведет 15\n</pre> <p>[=] Внешнюю переменную n изменять нельзя - программа не скомпилируется</p> </li> <li> <h4>По ссылке</h4> <pre>\nint n{10};\nstd::function&lt;void(int)&gt; add =\n       [&](int x) { std::cout &lt;&lt; x + ++n &lt;&lt; std::endl; };\n\nadd(5); // выведет 16\ncout &lt;&lt; n; // выведет 11\n</pre> <p>[&] Внешнюю переменную n изменять можно. Она также изменится за пределами функции</p> </li> <li> <h4>mutable</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n{10};\n  auto increment = [=]() mutable {\n    n++; // увеличиваем значение внешней переменной\n    std::cout &lt;&lt; "n inside lambda: " &lt;&lt; n &lt;&lt; std::endl;\n  };\n  increment();\n  std::cout &lt;&lt; "n outside lambda: " &lt;&lt; n &lt;&lt; std::endl;\n}\n</pre> <p>mutable Внешняя переменная n передается по значению, но внутри лямбда-выражения ее можно изменять. За пределами она не изменится</p> </li> <li> <h4>Все по значению, кроме одной по ссылке</h4> <pre>\nint n{10}, n_2{ 8 };\nauto add = [=, &n](int x)\n{ std::cout &lt;&lt; x + ++n + n_2 &lt;&lt; std::endl; };\n\nadd(5); // выведет 24\ncout &lt;&lt; nl // выведет 11\n</pre> <p>[=, &n] все переменные передаются по значению и их изменять нельзя, но переменная n передается по ссылке и ее изменять можно. За пределами функции она тоже изменится.</p> </li> <li> <h4>Ошибка</h4> <pre>\nint n{10}, n_2{ 8 };\nauto add = [&, &n](int x)\n{ std::cout &lt;&lt; x + ++n + n_2 &lt;&lt; std::endl; };\n\nadd(5); // ошибка\ncout &lt;&lt; n_2; // ошибка\n</pre> <p>[&, &n] все переменные передаются по ссылке и переменная n тоже передается по ссылке. Это условие избыточное. Компилироваться такая строчка не будет</p> </li> <li> <h4>Все по значению, кроме одной по ссылке</h4> <pre>\n#include &lt;iostream&gt;\n#include &lt;function&gt;\n\nusing namespace std;\n\nint main()\n{\n  int n{ 10 }, n_2{ 8 };\n  std::function&lt;void(int)&gt; lambda_func = [=, &n_2](int x)\n  { std::cout &lt;&lt; x + ++n_2 - n &lt;&lt; std::endl; };\n\n  lambda_func(5); // выведет 13\n}\n</pre> <p>[=, &n_2] все переменные передаются по значению и их изменять нельзя, но переменная n_2 передается по ссылке и ее изменять можно. За пределами функции она тоже изменится.</p> </li> </ol> </article> <article class="article"> <div class="anchor" id="lamb3"></div> <h3>Примеры использования</h3> <ol> <li> <h4>Логические выражения. Передача по значению</h4> <pre>\nint n{ 4 };\nstd::function&lt;bool(int)&gt; lambda_func_bool =\n       [](int x) { return x &gt; 1 && x &lt; 3; };\ncout &lt;&lt; lambda_func_bool(n); // 0\n\ndouble r{ 5 };\ndouble x{ 4 }, y{ 2 };\nauto lambda_func_r =\n       [r](double x, double y) { return x * x + y * y &lt;= r * r; };\ncout &lt;&lt; lambda_func_r(x, y); // 1\n\nr = 1;\ncout &lt;&lt; lambda_func_r(x, y); // 1\n</pre> <p>[r] переменная r передается по значению и равна значению, которое было при первом вызове лямбда-функции. Если после вызова лямбда-функции переменную r изменить, то при следующем вызове лямбда-функции все равно останется ее старое значение</p> </li> <li> <h4>Логические выражения. Передача по ссылке</h4> <pre>\nint n{ 4 };\nstd::function&lt;bool(int)&gt; lambda_func_bool =\n       [](int x) { return x &gt; 1 && x &lt; 3; };\ncout &lt;&lt; lambda_func_bool(n); // 0\n\ndouble r{ 5 };\ndouble x{ 4 }, y{ 2 };\nauto lambda_func_r =\n       [&r](double x, double y) { return x * x + y * y &lt;= r * r; };\ncout &lt;&lt; lambda_func_r(x, y); // 1\n\nr = 1;\ncout &lt;&lt; lambda_func_r(x, y); // 0\n</pre> <p>[&r] переменная r передается по ссылке. Если после вызова лямбда-функции переменную r изменить, то при следующем вызове лямбда-функции она тоже изменится</p> </li> <li> <h4>Замена переменных</h4> <pre>\ndouble a{ 4 }, b{ 2 };\nstd::function&lt;void(double&, double&)&gt; lambda_func_swap\n= [](double& x, double& y)\n{\n  double temp = x;\n  x = y;\n  y = temp;\n};\n\nlambda_func_swap(a, b);\ncout &lt;&lt; a &lt;&lt; " " &lt;&lt; b; // 2 4\n</pre> </li> </ol> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Код программы</h3> <p>Вынесем в отдельный файл функцию</p> <p>Файл Series.cpp</p> <pre>\n#include "Series.h"\n\nint menu() {\n  std::cout &lt;&lt; "Введите 1 - Сумма ряда" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Введите 2 - Сумма ряда c погрешностью" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Введите 3 - Завершение программы" &lt;&lt; std::endl;\n\n  int choice{};\n  get_value<int>(choice, [](int temp) { return temp >= 1 && temp &lt;= 3; },\n  "Введите значение в диапазоне от 1 до 3\\n");\n\n\treturn choice;\n}\n//void get_value(int& choice, std::function&lt;bool(int)&gt;\n//condition, const std::string& message)\n//{\n//  std::cout &lt;&lt; message &lt;&lt; std::endl;\n//\n//  do {\n//    std::cin >> choice;\n//    if (!std::cin.fail() && condition(choice))\n//    {\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//      return;\n//    }\n//    else\n//    {\n//      std::cout &lt;&lt; message &lt;&lt; std::endl;\n//      std::cin.clear();\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//    }\n//  } while (true);\n//}\n//void get_value(double& x, std::function&lt;bool(double)&gt;\n//condition, const std::string& message)\n//{\n//  std::cout &lt;&lt; message &lt;&lt; std::endl;\n//\n//  do {\n//    std::cin >> x;\n//    if (!std::cin.fail() && condition(x))\n//    {\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//      return;\n//    }\n//    else\n//    {\n//      std::cout &lt;&lt; message &lt;&lt; std::endl;\n//      std::cin.clear();\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//    }\n//  } while (true);\n//}\n\ndouble sum_series(double x, int n)\n{\n  double Sn{};\n  double ai{ x };\n  for (int i = 1; i &lt; n; i++)\n  {\n    Sn += ai;\n    ai *= (-1) * (x * x) / (2 * i * (2 * i + 1));\n  }\n  return Sn;\n}\n\ndouble sum_series(double x, int& count, double eps)\n{\n  double Sn{};\n  double ai{ x };\n\n  for (count = 1; abs(ai) >= eps; count++)\n  {\n    Sn += ai;\n    ai *= (-1) * (x * x) / (2 * count * (2 * count + 1));\n  }\n  return Sn;\n}\n\nvoid print_answer(double Sn, const std::string& message, int n)\n{\n  std::cout&lt;&lt;std::setw(35) &lt;&lt; std::left &lt;&lt; message &lt;&lt; std::fixed\n  &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n  if (n > 0)\n  {\n    std::cout &lt;&lt; std::setw(35) &lt;&lt; std::left\n    &lt;&lt; "Количество элементов ряда" &lt;&lt; std::fixed &lt;&lt; n &lt;&lt; std::endl;\n  }\n}\n</int></pre> <p>Файл Series.h</p> <pre>\n#pragma once\n#include <iostream>\n#include <iomanip>\n#include <functional>\n\nint menu();\n//void get_value(int& choice, std::function<bool (int)> condition, const std::string& message);\n//void get_value(double& x, std::function<bool (double)> condition, const std::string& message);\n\ndouble sum_series(double x, int n);\ndouble sum_series(double x, int& count, double eps);\nvoid print_answer(double Sn, const std::string& message, int n = 0);\n\ntemplate&lt;typename T&gt;\nvoid get_value(T& x, std::function&lt;bool(T)&gt; condition, const std::string& message)\n{\n  std::cout &lt;&lt; message &lt;&lt; std::endl;\n\n  do {\n    std::cin >> x;\n    if (!std::cin.fail() && condition(x))\n    {\n      std::cin.ignore(std::cin.rdbuf()->in_avail());\n      return;\n    }\n    else\n    {\n      std::cout &lt;&lt; message &lt;&lt; std::endl;\n      std::cin.clear();\n      std::cin.ignore(std::cin.rdbuf()->in_avail());\n    }\n  } while (true);\n}\n</bool></bool></functional></iomanip></iostream></pre> <p>Основная программа примет вид</p> <p>Файл main.c</p> <pre>\n#include "Series.h"\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    choice = menu();\n\n    if (choice != 3)\n    {\n      double x{};\n      get_value<double>(x, [](double temp) {return abs(temp) &lt;= 1; }, "Введите x  от -1 до 1\\n");\n\n      if (choice == 1)\n      {\n        double Sn{};\n        int N{};\n        get_value<int>(N, [](int temp) {return temp > 0; }, "Введите количество элементов ряда N, где N > 0");\n\n        Sn = sum_series(x, N);\n        print_answer(Sn, "Приближенное значение", N);\n      }\n      else if (choice == 2)\n      {\n        int count{};\n        double eps = 1.0E-12;\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          Sn = sum_series(x, count, eps);\n          print_answer(Sn, "Приближенное значение", count);\n          print_answer(sin(x), "Точное значение");\n\n          eps /= 100;\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, любое другое значение - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n  } while (choice != 3);\n}\n</int></double></pre> </article> ','<article class="article"> <h1>Лекция 7 (11.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#array">Массив</a></p> <p><a href="#for">Перебор массива в цикле</a></p> <p><a href="#task1">Задача 1. Найдите сумму отрицательных элементов массива</a></p> <p><a href="#task2">Задача 2. Написать функцию вывода всех элементов массива</a></p> <p><a href="#array2">Двумерный массив</a></p> <p><a href="#for2">Перебор двумерного массива в цикле</a></p> <p><a href="#task3">Задача 3. Найдите сумму номеров минимального и максимального элементов</a></p> <p><a href="#task4">Задача 4. Дан массив. Вывести сначала элементы на четных местах, затем - на нечетных</a></p> <p><a href="#task5">Задача 5. Дан массив. Определить максимальный элемент массива и элемент, являющийся максимальным без учета этого элемента</a></p> <p><a href="#task6">Задача 6. В массиве из 30 элементов числа образуют неубывающую последовательность. Найти количество различных чисел в массиве</a></p> <p><a href="#task7">Задача 7. Найти элемент, наиболее близкий к среднему значению всех элементов массива</a></p> </article> <article class="article"> <div class="anchor" id="array"></div> <h3>Массив</h3> <p>Массив это ссылочный тип данных. Имя массива это указатель на область памяти, где хранится массив. К указателю можно применить операцию разименования. Под массив выделяется непрерывная область памяти размером, равным размеру типа данных умноженному на число элементов. Можно обратиться к любому элементу за O(1).</p> <h4>Объявление массива</h4> <p>При объявлении сначала пишут тип данных, которые будут храниться в массиве, название массива и его размер</p> <code>int mas[4];</code> <p>Размер записывают в отдельную переменную</p> <code>const int n = 4; int mas[n];</code> <h4>Инициализация массива</h4> <p>Можно сразу при объявлении инициализировать массив значениями по умолчанию</p> <code>int mas[n]{}; // {0,0,0,0}</code> <p>Можно инициализировать значениями</p> <code>int mas[n]{1,2,7,5};</code> <h4>Получение данных из массива</h4> <p>Можно получить значие любого элемента массива через [] квадратные скобки</p> <code>int k = mas[1]; // 2</code> <p>Можно получить значие первого элемента массива по ссылке, используя операцию разименования</p> <code>int k = *mas; // 1</code> <p>Можно получить значие люббого элемента массива по ссылке, используя операцию разименования. К указателю надо прибавить смещение, равное индексу элемента массива</p> <code>int k = *(mas + 1); // 2</code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  // тип_данных название_массива [размерность_массива]\n  const int n = 4;\n  int mas[n]{1,2,7,5};\n  int k1 = mas[0];\n  int k2 = mas[2];\n  int k3 = *mas;\n  int k4 = *(mas + 2);\n\n  std::cout &lt;&lt; "mas[0] " &lt;&lt; k1 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "mas[2] " &lt;&lt; k2 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "*mas " &lt;&lt; k3 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "*(mas + 2) " &lt;&lt; k4 &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <pre>\nmas[0] 1\nmas[2] 7\n*mas 1\n*(mas + 2) 7\n</pre> <h4>Размер массива</h4> <p>Размер массива в байтах</p> <code>int sizebyte = sizeof(mas);</code> <p>Чтобы узнать число элементов массива, нужно его размер в байтах поделить на размер одного элемента в байтах</p> <code>int size = sizeof(mas) / sizeof(mas[0]);</code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 4;\n  int mas[n]{1,2,7,5};\n  int sizebyte = sizeof(mas);\n  int size = sizeof(mas) / sizeof(mas[0]);\n\n  std::cout &lt;&lt; "size byte " &lt;&lt; sizebyte &lt;&lt; std::endl;\n  std::cout &lt;&lt; "size " &lt;&lt; size &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <pre>\nsize byte 16\nsize 4\n</pre> </article> <article class="article"> <div class="anchor" id="for"></div> <h3>Перебор массива в цикле</h3> <p>Обращаемся к элементу по его индексу через [] квадратные скобки</p> <pre>\nfor (int i = 0; i &lt; n; i++)\n{\n  std::cout &lt;&lt; mas[i] &lt;&lt; " ";\n}\n</pre> <p>Обращаемся к элементу через операцию разименования. Прибавляем индекс к указателю на массив</p> <pre>\nfor (int i = 0; i &lt; n; i++)\n{\n  std::cout &lt;&lt; *(mas + i) &lt;&lt; " ";\n}\n</pre> <p>Второй способ перебрать массив</p> <pre>\nfor (int a : mas)\n{\n  std::cout &lt;&lt; a &lt;&lt; " ";\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найдите сумму отрицательных элементов массива</h3> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 10;\n  int mas[n]{1,2,-7,5,-1,-2,7,5,-1,2};\n  int count{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (mas[i] &lt; 0)\n    {\n      count += mas[i];\n    }\n  }\n  std::cout &lt;&lt; count;\n}\n</pre> <p>Output</p> <code>-11</code> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Написать функцию вывода всех элементов массива</h3> <p>Напишем функцию вывода на печать элементов массива.</p> <h4>1 способ. Функция print() принимает массив и его размер.</h4> <pre>\n#include &lt;iostream&gt;\n\nvoid print(int[], const int);\n\nint main()\n{\n  const int n = 10;\n  int mas[n]{1,2,-7,5,-1,-2,7,5,-1,2};\n  int size = sizeof(mas) / sizeof(mas[0]);\n\n  print(mas, size);\n}\n\nvoid print(int nums[], int len)\n{\n  for (int i = 0; i &lt; len; i++)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n}\n\n  <p>Output</p>\n<code>1 2 -7 5 -1 -2 7 5 -1 2</code>\n</pre> <h4>2 способ. Функция print() принимает указатель на начало массива и на конец.</h4> <pre>\n#include &lt;iostream&gt;\n\nvoid print(int*, int*);\n\nint main()\n{\n  const int n = 10;\n  int mas[n]{1,2,-7,5,-1,-2,7,5,-1,2};\n\n  print(mas, mas + n);\n}\n\nvoid print(int *nums, int *end)\n{\n  for (int *ptr = nums; ptr &lt; end; ptr++)\n  {\n    std::cout &lt;&lt; *ptr &lt;&lt; " ";\n  }\n}\n</pre> <p>Output</p> <code>1 2 -7 5 -1 -2 7 5 -1 2</code> </article> <article class="article"> <div class="anchor" id="array2"></div> <h3>Двумерный массив</h3> <p>Объявим двумерный массив размером 2х2 и инициализируем его значениями по умолчанию</p> <code>int nums[2][2]{}; // {{0,0},{0,0}}</code> <p>Объявим двумерный массив размером 2х2 и инициализируем все его элементы значениями</p> <code>int nums[2][2]{1,2,3,4}; // {{1,2},{3,4}}</code> <p>Объявим двумерный массив размером 2х2 и инициализируем только два элемента, остальные получат значения по умолчанию</p> <code>int nums[2][2]{1,2}; // {{1,2},{0,0}}</code> <p>Объявим двумерный массив размером 3х3 и укажем какие элементы инициализировать значениями, остальные получат значения по умолчанию</p> <code>const int n = 3, m = 3;</code> <code>int nums[n][m]{{1,2},{},{7}}; // {{1,2,0},{0,0,0},{7,0,0}}</code> </article> <article class="article"> <div class="anchor" id="for2"></div> <h3>Перебор двумерного массива в цикле</h3> <p>Напечатаем двумерный массив 2х2</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 2, m = 2;\n  int nums[n][m]{1,2};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; " ";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> <p>Output</p> <pre>\n1 2\n0 0\n</pre> <p>Напечатаем двумерный массив 3х3</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3, m = 3;\n  int nums[n][m]{{1,2},{},{7}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; " ";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> <p>Output</p> <pre>\n1 2 0\n0 0 0\n7 0 0\n</pre> <p>Второй способ перебрать массив</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3, m = 3;\n  int nums[n][m]{{1,2},{},{7}};\n\n  for (auto &mas : nums)\n  {\n    for (int num : mas)\n    {\n      std::cout &lt;&lt; num &lt;&lt; " ";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> <p>Output</p> <pre>\n1 2 0\n0 0 0\n7 0 0\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Найдите сумму номеров минимального и максимального элементов</h3> <code>Input : {5,2,1,1,12,3}</code> <code>Output : 9 // 2 + 3 + 4</code> <p>Заведем переменные min и max для минимального и максимального элементов и присвоим им значение первого элемента массива</p> <p>Заведем переменные sum_min и sum_max для индексов минимального и максимального элементов и присвоим им ноль.</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 6;\n  int nums[n]{5,2,1,1,12,3};\n  int min{nums[0]}, max{nums[0]}, sum_min{}, sum_max{};\n\n  for (int i = 1; i &lt; n; i++)\n  {\n    if (nums[i] &lt; min)\n    {\n      min = nums[i];\n      sum_min = i;\n    }\n    else if (nums[i] == min)\n    {\n      sum_min += i;\n    }\n\n    if (nums[i] &gt; max)\n    {\n      max = nums[i];\n      sum_max = i;\n    }\n    else if (nums[i] == max)\n    {\n      sum_max += i;\n    }\n  }\n\n  std::cout &lt;&lt; "Sum min and max = "\n            &lt;&lt; sum_min + sum_max &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Sum min and max = 9</code> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Дан массив. Вывести на экран сначала его элементы, стоящие на четных местах, затем - на нечетных</h3> <p>Два раза пройдем циклом по массиву. Сначала по четным элементам, потом по нечетным.</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 10;\n  int nums[n]{2,3,4,5,6,7,8,9,10,11};\n\n  for (int i = 0; i &lt; n; i += 2)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n  for (int i = 1; i &lt; n; i += 2)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n}\n</pre> <p>Output</p> <code>2 4 6 8 10 3 5 7 9 11</code> </article> <article class="article"> <div class="anchor" id="task5"></div> <h3>Задача 5. Дан массив. Определить максимальный элемент массива и элемент, являющийся максимальным без учета этого элемента</h3> <p>Заведем две переменные max1 и max2 для первого и второго максимума и присвоим им значение первого элемента массива.</p> <p>Циклом пройдем по массиву и обновим максимумы</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 10;\n  int nums[n]{2,3,4,5,6,7,8,9,10,11};\n  int max1{nums[0]}, max2{max1};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (max1 &lt; nums[i])\n    {\n      max2 = max1;\n      max1 = nums[i];\n    }\n    else if (max2 &lt; nums[i])\n    {\n      max2 = nums[i];\n    }\n  }\n\n  std::cout &lt;&lt; "max1 = " &lt;&lt; max1 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "max2 = " &lt;&lt; max2 &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <pre>\nmax1 = 11\nmax2 = 10\n</pre> </article> <article class="article"> <div class="anchor" id="task6"></div> <h3>Задача 6. В массиве из 30 элементов числа образуют неубывающую последовательность. Найти количество различных чисел в массиве</h3> </article> <article class="article"> <div class="anchor" id="task7"></div> <h3>Задача 7. Найти элемент, наиболее близкий к среднему значению всех элементов массива</h3> </article> ','<article class="article"> <h1>Лекция 8 (18.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#array">Одномерный массив</a></p> <p><a href="#array2">Двумерный массив</a></p> <p><a href="#task1">Задача 1. Сумма элементов на основной диагонали матрицы</a></p> <p><a href="#task2">Задача 2. Сумма элементов на побочной диагонали матрицы</a></p> <p><a href="#task3">Задача 3. Сумма элементов на диагоналях матрицы</a></p> <p><a href="#task4">Задача 4. Заполнить в матрице основную диагональ и выше</a></p> <p><a href="#task5">Задача 5. Заполнить в матрице основную диагональ и ниже</a></p> <p><a href="#task6">Задача 6. Заполнить в матрице побочную диагональ и выше</a></p> <p><a href="#task7">Задача 7. Заполнить в матрице побочную диагональ и ниже</a></p> <p><a href="#task8">Задача 8. Заполнить матрицу случайными числами</a></p> <p><a href="#task9">Задача 9. Сумма элементов над основной диагональю матрицы</a></p> <p><a href="#task10">Задача 10. Сумма элементов над побочной диагональю матрицы</a></p> <p><a href="#task11">Задача 11. Сумма элементов под основной диагональю матрицы</a></p> <p><a href="#task12">Задача 12. Сумма элементов под побочной диагональю матрицы</a></p> <p><a href="#task13">Задача 13. Не более двух отрицательных числа в строке</a></p> <p><a href="#task14">Задача 14. Поменять две строки местами в матрице</a></p> <p><a href="#task15">Задача 15. Напечатать массив сумм в строках двумерной матрицы</a></p> </article> <article class="article"> <div class="anchor" id="array"></div> <h3>Одномерный массив</h3> <h4>Создание одномерного массива</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 5;\n\n  // создание массива\n  int nums[n]{1,2,3,4,5};\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n}\n</pre> <p>Output</p> <code>1 2 3 4 5</code> <p>В переменной nums хранится указатель на ячейку памяти, с которой начинается одномерный массив из пяти элементов</p> <h4>Создание одномерного массива в динамической памяти</h4> <p>Ключевое слово <strong>new</strong> для выделения памяти</p> <p>Ключевое слово <strong>delete</strong> для очистки памяти</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3;\n\n  // создание массива\n  int* nums = new int[n]{1,2,3};\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n\n  // очистка памяти\n  delete[] nums;\n}\n</pre> <p>Output</p> <code>1 2 3</code> </article> <article class="article"> <div class="anchor" id="array2"></div> <h3>Двумерный массив</h3> <h4>Создание двумерного массива</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n\n  // создание массива\n  int **nums = new int*[m]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    nums[i] = new int[m]();\n  }\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] nums[i];\n  }\n  delete[] nums;\n}\n</pre> <p>Output</p> <pre>\n1       2       3       4\n2       3       4       5\n3       4       5       6\n</pre> <p>В переменной nums хранится указатель на ячейку памяти, с которой начинается двумерный массив из трех строк. В каждой строке (nums[0], nums[1], nums[2]) хранится указатель на ячейку памяти, с которой начинается очередной массив</p> <h4>Напишем функцию для создания массива</h4> <p>Функция InitMas() принимает размер двумерного массива. Функция InitMas() выделяет область памяти под массив заданного размера и возвращает указатель на ячейку памяти, с которой начинается двумерный массив</p> <pre>\n#include &lt;iostream&gt;\n\nint** InitMas(int, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n\n  // создание массива\n  int **nums = InitMas(n, m);\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] nums[i];\n  }\n  delete[] nums;\n}\n\nint** InitMas(int n, int m)\n{\n  int **mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n  return mas;\n}\n</pre> <h4>Напишем функцию для создания массива</h4> <p>Функция CreateMas() принимает указатель и размер двумерного массива. Функция CreateMas() выделяет область памяти под массив заданного размера, начиная с ячейки на которую указывает указатель. Функция CreateMas() ничего не возвращает</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] nums[i];\n  }\n  delete[] nums;\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n</pre> <h4>Напишем функцию для удаления массива</h4> <p>Функция DeleteMas() принимает указатель и количество строк двумерного массива.</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <h4>Напишем функцию для заполнения массива</h4> <p>Функция FullMas() принимает указатель и размер двумерного массива.</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <h4>Напишем функцию для печати массива</h4> <p>Функция PrintMas() принимает указатель и размер двумерного массива.</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Сумма элементов на основной диагонали матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на основной диагонали матрицы</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 34 // 1 + 6 + 11 + 16</code> <h4>Решение</h4> <p>На основной диагонали для каждого элемента квадратной матрицы номер строки равен номеру столбца. Циклом проходим по строкам матрицы. Прибавляем к сумме элементы с одинаковым номером строки и столбца</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += nums[i][i];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Сумма элементов на побочной диагонали матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на побочной диагонали матрицы</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 22 // 4 + 7 + 10 + 1</code> <h4>Решение</h4> <p>На побочной диагонали для каждого элемента квадратной матрицы номер столбца равен размеру матрицы минус один минус номер строки. Циклом проходим по строкам матрицы. Прибавляем к сумме элементы у которых номер столбца равен размеру матрицы минус один минус номер строки</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += nums[i][n - 1 - i];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Сумма элементов на диагоналях матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на диагоналях матрицы</p> <h4>Пример 1</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 56 // 1 + 6 + 11 + 16 + 4 + 7 + 10 + 1</code> <h4>Пример 2</h4> <code>Input: nums{{1,2,3},{5,6,7},{9,10,11}}</code> <pre>\n1  2  3\n5  6  7\n9 10 11\n</pre> <code>Output 30 // 1 + 6 + 11 + 3 + 9</code> <h4>Решение</h4> <p>Для четной матрицы вычисляем сумму элементов на каждой диагонали и складываем. Для нечетной матрицы, чтобы не посчитать дважды элемент лежащий в центре на обоих диагоналях, на побочной диагонали не будем считать центральный элемент, для которого номер строки равен номеру столбца</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  // int n = 3;\n  // int nums[n][n]{{1,2,3},{5,6,7},{9,10,11}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += nums[i][i];\n    if (i != n - 1 - i)\n    {\n      sum += nums[i][n - 1 - i];\n    }\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Заполнить в матрице основную диагональ и выше</h3> <p>При заполнении матрицы вложенный цикл будем начинать не с нуля, а с номера строки</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = i; j &lt; m; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n1       2       3       4       5       6\n0       3       4       5       6       7\n0       0       5       6       7       8\n0       0       0       7       8       9\n0       0       0       0       9       10\n0       0       0       0       0       11\n</pre> </article> <article class="article"> <div class="anchor" id="task5"></div> <h3>Задача 5. Заполнить в матрице основную диагональ и ниже</h3> <p>При заполнении матрицы вложенный цикл будем начинать с нуля, а заканчивать до номера строки плюс один</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; i + 1; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n1       0       0       0       0       0\n2       3       0       0       0       0\n3       4       5       0       0       0\n4       5       6       7       0       0\n5       6       7       8       9       0\n6       7       8       9       10      11\n</pre> </article> <article class="article"> <div class="anchor" id="task6"></div> <h3>Задача 6. Заполнить в матрице побочную диагональ и выше</h3> <p>При заполнении матрицы вложенный цикл будем начинать с нуля, а заканчивать до размера матрицы минус номер строки</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n - i; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n1       2       3       4       5       6\n2       3       4       5       6       0\n3       4       5       6       0       0\n4       5       6       0       0       0\n5       6       0       0       0       0\n6       0       0       0       0       0\n</pre> </article> <article class="article"> <div class="anchor" id="task7"></div> <h3>Задача 7. Заполнить в матрице побочную диагональ и ниже</h3> <p>При заполнении матрицы вложенный цикл будем начинать с размера матрицы минус один минус номер строки</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = n - 1 - i; j &lt; n; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n0       0       0       0       0       6\n0       0       0       0       6       7\n0       0       0       6       7       8\n0       0       6       7       8       9\n0       6       7       8       9       10\n6       7       8       9       10      11\n</pre> </article> <article class="article"> <div class="anchor" id="task8"></div> <h3>Задача 8. Заполнить матрицу случайными числами</h3> <p>Заполним матрицу случайными числами от 0 до 9, используя выражение rand() % 10</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task9"></div> <h3>Задача 9. Сумма элементов над основной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на основной диагонали и выше</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 70 // 1+2+3+4+6+7+8+11+12+16</code> <h4>Решение</h4> <p>На основной диагонали для каждого элемента квадратной матрицы номер строки равен номеру столбца. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная с номера строки. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = i; j &lt; n; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> <code>Output 70</code> </article> <article class="article"> <div class="anchor" id="task10"></div> <h3>Задача 10. Сумма элементов над побочной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на побочной диагонали и выше</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 48 // 1+2+3+4+5+6+7+9+10+1</code> <h4>Решение</h4> <p>На побочной диагонали для каждого элемента квадратной матрицы номер столбца равен размер матрицы минус один минус номер строки. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная с нуля до побочной диагонали. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n - i; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task11"></div> <h3>Задача 11. Сумма элементов под основной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на основной диагонали и ниже</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 88 // 1+5+6+9+10+11+1+14+15+16</code> <h4>Решение</h4> <p>На основной диагонали для каждого элемента квадратной матрицы номер строки равен номеру столбца. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная с нуля до основной диагонали. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; i + 1; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task12"></div> <h3>Задача 12. Сумма элементов под побочной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на побочной диагонали и ниже</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 98 // 4+7+8+10+11+12+1+14+15+16</code> <h4>Решение</h4> <p>На побочной диагонали для каждого элемента квадратной матрицы номер столбца равен размер матрицы минус один минус номер строки. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная от побочной диагонали. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = n - 1 - i; j &lt; n; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task13"></div> <h3>Задача 13. Не более двух отрицательных числа в строке</h3> <p>Проверить, есть ли в двумерной матрице строки, не содержащие более двух отрицательных элементов</p> <p>Заполним матрицу случайными числами от -9 до 9, используя выражение rand() % 10 - rand() % 10</p> <p>Напишем вспомогательную функцию Count() которая принимает строку матрицы и возвращает количество отрицательных чисел в ней</p> <p>Напишем функцию lessThenThreeNeg() которая возвращает true если есть строки не содержащие более двух отрицательных чисел</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nint Count(int*, int);\nbool lessThenThreeNeg(int**, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // проверка строк\n  if (lessThenThreeNeg(nums, n, m))\n  {\n    std::cout &lt;&lt; "Matrix has less then three negative";\n  }\n  else\n  {\n    std::cout &lt;&lt; "Matrix has not less then three negative";\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10 - rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nint Count(int* str, int n)\n{\n  int count = 0;\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (str[i] &lt; 0)\n    {\n      count++;\n    }\n  }\n  return count;\n}\n\nbool lessThenThreeNeg(int **mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (Count(mas[i], n) &lt; 3)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task14"></div> <h3>Задача 14. Поменять две строки местами в матрице</h3> <p>Заполним матрицу случайными числами от 0 до 9, используя выражение rand() % 10</p> <p>Напишем вспомогательную функцию swap() которая принимает две строки матрицы и меняет их местами</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\nvoid Swap(int*&, int*&);\n\nint main()\n{\n  srand(time(0));\n  const int n = 3; // количество строк\n  const int m = 3; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // меняем строки местами\n  Swap(nums[0], nums[1]);\n  std::cout &lt;&lt; std::endl;\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nvoid Swap(int *&a, int *&b)\n{\n  int* temp = a;\n  a = b;\n  b = temp;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task15"></div> <h3>Задача 15. Напечатать массив сумм в строках двумерной матрицы</h3> <p>Заполним матрицу случайными числами от 0 до 9, используя выражение rand() % 10</p> <p>Напишем вспомогательную функцию Sum() которая принимает массив чисел и возвращает их сумму</p> <p>Напишем функцию sumMas() которая создает и возвращает массив сумм</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\nvoid Swap(int*&, int*&);\nint Sum(int*, int);\nint* sumMas(int**, int, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // создаем и печатаем массив сумм\n  int* s = sumMas(nums, n, m);\n  std::cout &lt;&lt; std::endl;\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; s[i] &lt;&lt; " ";\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nvoid Swap(int *&a, int *&b)\n{\n  int* temp = a;\n  a = b;\n  b = temp;\n}\n\nint Sum(int *row, int n)\n{\n  int sum = 0;\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += row[i];\n  }\n  return sum;\n}\n\nint* sumMas(int **mas, int n, int m)\n{\n  int *new_mas = new int[n];\n  for (int i = 0; i &lt; n; i++)\n  {\n    new_mas[i] = Sum(mas[i], m);\n  }\n  return new_mas;\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 9 (9.12.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#task1">Задача 1. Строки матрицы по невозрастанию сумм</a></p> <p><a href="#task2">Задача 2. Перемещение 0 в конец массива</a></p> <p><a href="#task3">Задача 3. Создадим квадратную матрицу и определим элементы выше, ниже и на главной диагонали</a></p> <p><a href="#task4">Задача 4. Упорядочить строки матрицы по условию</a></p> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Строки матрицы по невозрастанию сумм</h3> <p>Упорядочить строки в двумерной матрице по невозрастанию сумм</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid Print(int*&, int);\nvoid DeleteMas(int**&, int);\nvoid Swap(int*&, int*&);\nint SumRow(int*, int);\nint* sumMas(int**, int, int);\nvoid sortMas(int**&, int, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n  std::cout &lt;&lt; std::endl;\n\n  // сортировка массива\n  sortMas(nums, n, m);\n\n  // печатаем массив\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid Print(int *&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; " ";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nvoid Swap(int *&a, int *&b)\n{\n  int* temp = a;\n  a = b;\n  b = temp;\n}\n\nint SumRow(int *row, int n)\n{\n  int sum = 0;\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += row[i];\n  }\n  return sum;\n}\n\nint* sumMas(int **mas, int n, int m)\n{\n  int *new_mas = new int[n];\n  for (int i = 0; i &lt; n; i++)\n  {\n    new_mas[i] = SumRow(mas[i], m);\n  }\n  return new_mas;\n}\n\nvoid sortMas(int **&mas, int n, int m)\n{\n  int* s = sumMas(mas, n, m);\n  Print(s, n);\n\n  for (int i = 1; i &lt; n; i++)\n  {\n    for (int j = i; j &gt; 0 && s[j-1] &gt; s[j]; j--)\n    {\n      std::swap(s[j-1], s[j]);\n      std::swap(mas[j-1], mas[j]);\n    }\n  }\n  Print(s, n);\n  std::cout &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Перемещение 0 в конец массива</h3> <p>В школе прошёл экзамен по математике.Некоторые ученики списали решения, были замечены и получили 0 баллов. Помогите учителю пересортировать оценки учеников. Все оценки, равные 0, должны быть перемещены в конец списка, при этом порядок остальных оценок должен остаться неизменным.</p> <h4>Решение 1. Создаем новый массив с результатом</h4> <p>Сложность по памяти O(N)</p> <pre>\n#include &lt;iostream&gt;\n\nvoid Print(int*, int);\n\nint main()\n{\n  // ввод длины массива\n  int n{};\n  std::cout &lt;&lt; "Input array length ";\n  std::cin &gt;&gt; n;\n\n  // ввод элементов массива\n  int *nums = new int[n]();\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; "Input element " &lt;&lt; i &lt;&lt; " ";\n    std::cin &gt;&gt; nums[i];\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // печать массива\n  Print(nums, n);\n\n  // создание массива результата\n  int* result = new int[n]();\n  for (int i = 0, j = 0; i &lt; n; i++)\n  {\n    if (nums[i] != 0)\n    {\n      result[j] = nums[i];\n      j++;\n    }\n  }\n\n  // очистка памяти\n  delete[] nums;\n  nums = result;\n\n  // печать результата\n  Print(result, n);\n  Print(nums, n);\n\n  // очистка памяти\n  delete[] nums;\n  result = nullptr;\n  nums = nullptr;\n}\n\nvoid Print(int *mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; "\\t";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n</pre> <h4>Решение 2. Изменяем входной массив</h4> <p>Сложность по памяти O(1)</p> <pre>\n#include &lt;iostream&gt;\n\nvoid Print(int*, int);\nvoid Solution(int*, int);\n\nint main()\n{\n  // ввод длины массива\n  int n{};\n  std::cout &lt;&lt; "Input array length ";\n  std::cin &gt;&gt; n;\n\n  // ввод элементов массива\n  int *nums = new int[n]();\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; "Input element " &lt;&lt; i &lt;&lt; " ";\n    std::cin &gt;&gt; nums[i];\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // печать массива\n  Print(nums, n);\n\n  // изменяем входной массив\n  Solution(nums, n);\n\n  // печать массива\n  Print(nums, n);\n\n  // очистка памяти\n  delete[] nums;\n  nums = nullptr;\n}\n\nvoid Print(int *mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; "\\t";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid Solution(int *mas, int n)\n{\n  int cntZero = 0;\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (mas[i] == 0)\n    {\n      cntZero++;\n    }\n    else\n    {\n      mas[i - cntZero] = mas[i];\n    }\n  }\n\n  for (int i = n - cntZero; i &lt; n; i++)\n  {\n    mas[i] = 0;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Создадим квадратную матрицу и определим элементы выше, ниже и на главной диагонали</h3> <h4>Алгоритм программы</h4> <ol> <li>Введем размер n квадратной матрицы nxn</li> <li>Заполним матрицу случайными числами</li> <li>Запишем 0 в элементы выше главной диагонали</li> <li>Запишем 1 в элементы ниже главной диагонали</li> <li>Запишем 2 в элементы на главной диагонали</li> </ol> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int);\nvoid FullMas(int**&, int);\nvoid PrintMas(int**&, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  // Введем размер n квадратной матрицы nxn\n  int n{};\n  std::cout &lt;&lt; "Input array dimention ";\n  std::cin &gt;&gt; n;\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n);\n\n  // заполнение массива\n  FullMas(nums, n);\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // Запишем 0 в элементы выше главной диагонали\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = i + 1; j &lt; n; j++)\n    {\n      nums[i][j] = 0;\n    }\n  }\n\n  // Запишем 1 в элементы ниже главной диагонали\n  for (int i = 1; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; i; j++)\n    {\n      nums[i][j] = 1;\n    }\n  }\n\n  // Запишем 2 в элементы на главной диагонали\n  for (int i = 0; i &lt; n; i++)\n  {\n    nums[i][i] = 2;\n  }\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[n]();\n  }\n}\n\nvoid FullMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Упорядочить строки матрицы по условию</h3> <p>Дана квадратная матрица. Если сумма элементов матрицы выше главной диагонали больше суммы элементов матрицы ниже главной диагонали, упорядочить строки матрицы в порядке неубывания сумм элементов, стоящих на нечетных позициях каждой строки</p> <h4>Алгоритм программы</h4> <ol> <li>Введем размер n квадратной матрицы nxn</li> <li>Заполним матрицу случайными числами</li> <li>Посчитаем сумму элементов выше главной диагонали</li> <li>Посчитаем сумму элементов ниже главной диагонали</li> <li>Если верхняя сумма больше нижней, то переходим к сортировке</li> <li>Подсчитаем суммы элементов, стоящих на нечетных позициях каждой строки</li> <li>Отсортируем массив в порядке неубывания этих сумм</li> </ol> <p><em>odd - нечетный</em></p> <p><em>even - четный</em></p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int);\nvoid FullMas(int**&, int);\nvoid PrintMas(int**&, int);\nvoid Print(int*&, int);\nvoid DeleteMas(int**&, int);\nint Sum(int**, int, bool flag = true);\nint SumRowOdd(int*, int);\nint* sumMas(int**, int);\nvoid sortMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  // Введем размер n квадратной матрицы nxn\n  int n{};\n  std::cout &lt;&lt; "Input array dimention ";\n  std::cin &gt;&gt; n;\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n);\n\n  // заполнение массива\n  FullMas(nums, n);\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // посчитаем сумму элементов\n  // над и под диагональю\n  int mas_up = Sum(nums, n);\n  int mas_down = Sum(nums, n, false);\n\n  std::cout &lt;&lt; mas_up &lt;&lt; std::endl;\n  std::cout &lt;&lt; mas_down &lt;&lt; std::endl;\n\n  // Если верхняя сумма больше нижней,\n  // то сортируем массив\n  if (mas_up &gt; mas_down)\n  {\n    sortMas(nums, n);\n  }\n  else\n  {\n    std::cout &lt;&lt; "without sort" &lt;&lt; std::endl;\n  }\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[n]();\n  }\n}\n\nvoid FullMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid Print(int *&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; " ";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nint Sum(int **mas, int n, bool flag)\n{\n  int sum{};\n  if (flag)\n  {\n    for (int i = 0; i &lt; n; i++)\n    {\n      for (int j = i + 1; j &lt; n; j++)\n      {\n        sum += mas[i][j];\n      }\n    }\n  }\n  else\n  {\n    for (int i = 1; i &lt; n; i++)\n    {\n      for (int j = 0; j &lt; i; j++)\n      {\n        sum += mas[i][j];\n      }\n    }\n  }\n  return sum;\n}\n\nint SumRowOdd(int *row, int n)\n{\n  int sum{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (i % 2 == 1)\n    {\n      sum += row[i];\n    }\n  }\n  return sum;\n}\n\nint* sumMas(int **mas, int n)\n{\n  int *new_mas = new int[n];\n  for (int i = 0; i &lt; n; i++)\n  {\n    new_mas[i] = SumRowOdd(mas[i], n);\n  }\n  return new_mas;\n}\n\nvoid sortMas(int **&mas, int n)\n{\n  int* s = sumMas(mas, n);\n  Print(s, n);\n\n  for (int i = 1; i &lt; n; i++)\n  {\n    for (int j = i; j &gt; 0 && s[j-1] &gt; s[j]; j--)\n    {\n      std::swap(s[j-1], s[j]);\n      std::swap(mas[j-1], mas[j]);\n    }\n  }\n  Print(s, n);\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 10 (16.12.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#sten">Стенфордский курс</a></p> <p><a href="#task1">Задача 1. Найти соседние элементы массива с минимальной разницей</a></p> <p><a href="#task2">Задача 2. Опасные динозавры</a></p> </article> <article class="article"> <div class="anchor" id="sten"></div> <h3>Стенфордский курс</h3> <h3>CS 106X, Lecture 3</h3> <h3>I/O Streams and Grids</h3> <p>reading: Programming Abstractions in C++, Chapter 4, 5.1</p> <h4>Defining a function (2.3)</h4> <p>A C++ function is like a Java method</p> <pre>\ntype functionName(type name, ..., type name) {\n  statement;\n  ...\n  statement;\n  return expression; // if return type is not void\n}\n</pre> <p>Calling a function</p> <code>functionName(value, ..., value);</code> <h4>Default parameters</h4> <p>You can make a parameter optional by supplying a default value</p> <p>All parameters with default values must appear last in the list</p> <p>Prints a line of characters of the given width</p> <pre>\nvoid printLine(int width = 10, char letter = \'*\') {\n  for (int i = 0; i &lt; width; i++) {\n    cout &lt;&lt; letter;\n  }\n  cout &lt;&lt; endl;\n}\n\nprintLine(7, \'?\'); // ???????\nprintLine(5); // *****\nprintLine(); // **********\n</pre> <h4>Function prototypes (1.4)</h4> <code>type name(type name, ..., type name);</code> <p>Declare the function (without its body) at top of program</p> <pre>\ndouble circleArea(double); // function prototype\n\nint main() {\n  double a = circleArea(2.5); // call the function\n  return 0;\n}\n\ndouble circleArea(double r) {\n  ...\n}\n</pre> <p>With prototype, only declare default values in prototype</p> <h4>Pass by Value</h4> <pre>\nvoid swap(int a, int b) {\n  int temp = a;\n  a = b;\n  b = temp;\n}\n\nint main() {\n  int x = 17;\n  int y = 35;\n  swap(x, y);\n  cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; endl; // 17, 35\n  return 0;\n}\n</pre> <p>By default, C++ parameters are copies</p> <h4>Pass by Reference</h4> <pre>\nvoid swap(int &a, int &b) {\n  int temp = a;\n  a = b;\n  b = temp;\n}\n\nint main() {\n  int x = 17;\n  int y = 35;\n  swap(x, y);\n  cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; endl; // 35, 17\n  return 0;\n}\n</pre> <p>Use "&" to pass the same version</p> <h4>Strings (3.1)</h4> <pre>\n#include &lt;string&gt;\n...\nstring s = "hello";\n</pre> <p>A string is a (possible empty) sequence of characters</p> <p>Strings are mutable (can be changed) in C++</p> <p>There are two types of strings in C++</p> <h4>Operators (3.2)</h4> <p>Concatenate using + or +=</p> <code>string s1 = "Dai";</code> <code>s1 += "sy"; // "Daisy"</code> <p>Compare using relational operators (ASCII ordering)</p> <code>string s2 = "Nicl";</code> <code>if (s1 &lt; s2 != "Joe") {...} // true</code> <p>Strings are mutable and can be changed</p> <code>s2.append(" Troccoli"); // "Nick Troccoli"</code> <code>s2.erase(6,7); // "Nick T"</code> <code>s2[2] = \'e\'; // "Niek T"</code> <h4>C vs C++ strings (3.5)</h4> <p>C++ has tho kinds of strings: C strings (char arrays) and C++ strings (string objects)</p> <p>A string literal such as "hi there" is a C string. C strings don\'t include any methods/behavior shown previously. No member functions like length, find, or operators</p> <p>Converting between the two types</p> <code>string("text"); // C string to C++ string</code> <code>string.c_str(); C++ string to C string</code> <h4>NEW: Const parameters </h4> <p>What if you want to avoid copying a large variable but don\'t want to change it?</p> <p>Use the const keyword to indicate that the parameter won\'t be changed. Usually used with strings and collections. Passing in a non-variable (e.g. printString("hello")) does work</p> <pre>\nvoid printString(const string& str) {\n  cout &lt;&lt; "I will print this string" &lt;&lt; endl;\n  cout &lt;&lt; str &lt;&lt; endl;\n}\n\nint main() {\n  printString("This could be a really long string");\n}\n</pre> <h4>What is a stream?</h4> <p>A stream is a type of variable that you can insert into and remove from using special stream operations like &lt;&lt; , &gt;&gt; , getline, get and put</p> <p>There are input streams and output streams</p> <p>An input stream lets you get data from a source (like user input, a file, a webpage, etc.) and read it in your program</p> <p>An output stream lets you take data from your program and output it to a source (like the console, a file, etc.)</p> <h4>Reading In A File</h4> <ol> <li>Open the file for reading</li> <li>Read the file, one chunk at a time</li> <li>Close the file</li> </ol> <pre>\nThe animal I really dig,\nAbove all others is a pig.\nPigs are noble. Pigs are clever,\nPigs are courteous. However, ...\n-Roald Dahl, "The Three Little Pigs"\n</pre> <h4>Step one: Open the file for reading</h4> <pre>\n#include &lt;fstream&gt;; // for file streams\nifstream infile;\ninfile.open("filename.txt");\n</pre> <pre>\nifstream infile;\nstring myFilename = ...;\ninfile.open(myFilename.c_str());\n</pre> <p>This error-checks the filename (unlike previous)</p> <pre>\n#include &lt;fstream&gt;; // for file streams\n#include "filelib.h"; // for promptUserForFile\nifstream infile;\npromptUserForFile(infile, "Enter a file name: ");\n</pre> <h4>Step Two: Read the file, one line at a time</h4> <pre>\nstring line1;\ngetline(infile, line1); // The animal I realy dig\n</pre> <pre>\nstring line1, line2, line3, line4, line5;\ngetline(infile, line1); // The animal I realy dig\ngetline(infile, line2); // Above all others is the pig\ngetline(infile, line3); // Pigs are noble. Pigs are clever,\ngetline(infile, line4); // Pigs are courteous. However, ...\ngetline(infile, line5); // -Roald Dahl, "The Three Little Pigs"\n</pre> <p>print all lines in the file</p> <pre>\nstring line;\nwhile (getline(infile, line)) {\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n</pre> <h4>Step Three: close the file</h4> <code>infile.close();</code> <h4>One Character at a Time</h4> <pre>\nchar ch;\nwhile(infile.get(ch)) {\n  // do something with ch\n}\ninfile.close();\n</pre> <h4>One Word at a Time</h4> <pre>\nstring word;\nwhile(infile &gt;&gt; word) {\n  // do something with word\n}\ninfile.close();\n</pre> <h4>Writing to a File</h4> <ol> <li>Open the file for writing</li> <li>Write to the file</li> <li>Close the file</li> </ol> <p>Open the file for writing</p> <pre>\nofstream outfile;\npromptUserForFile(outfile, "Enter a file name: ");\n</pre> <p>Write to the file</p> <pre>\nstring word = "my cool string";\nint x = 3;\noutfile &lt;&lt; word &lt;&lt; x;\n</pre> <p>Close the file</p> <code>outfile.close();</code> <h4>That Looks Familiar</h4> <p>If file-writing syntax seems eerily similar to printing to the console, that\'s because it is!</p> <p>cin is a istream; cout is a ostream</p> <p>We can take advantage of this in your code</p> <pre>\nvoid outputUserData(ostream& outputStream, string name, int score, double health) {\n  outputStream &lt;&lt; name &lt;&lt; endl;\n  outputStream &lt;&lt; score &lt;&lt; endl;\n}\n</pre> <h4>Reading files (4.3)</h4> <code>#include &lt;fstream&gt;</code> <p>ifstream, ofstream classes for input/output files</p> <p>inheritance hierarchy, based on parents named istream, ostream</p> <p>cin is an ifstream; cout is an ofstream</p> <p><a href="http://cplusplus.com/reference/istream/istream/">http://cplusplus.com/reference/istream/istream/</a></p> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найти соседние элементы массива с минимальной разницей</h3> <p>Дан отсортированный массив положительных целых чисел. Необходимо найти такую пару соседних элементов, у которых абсолютная разница минимальна</p> <p>Формат входных данных. В первой строчке задается число N- размер массива (количество элементов). Во второй строке вводится массив из N положительных целых чисел, разделенных пробелами.</p> <p>Формат выходных данных. Программа должна вывести два числа - значения пары соседних элементов с наименьшей абсолютной разницей, разделенные пробелом. Если таких пар несколько, вывести первую найденную</p> <p>Файл lec10.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nvoid CreateMas(int*&, int);\nvoid Print(int*, int);\nvoid DeleteMas(int*&);\n\nint main()\n{\n  std::ifstream infile;\n  infile.open("text.txt");\n  int size{};\n  int* array = nullptr;\n  int a{}, b{}, min{-1};\n\n  if (infile.is_open())\n  {\n    infile >> size;\n    CreateMas(array, size);\n\n    for (int i = 0; i &lt; size; i++)\n    {\n      infile >> array[i];\n    }\n\n    Print(array, size);\n\n    for (int i = 0; i &lt; size-1; i++)\n    {\n      if (min &lt; 0)\n      {\n        a = array[i];\n        b = array[i+1];\n        min = b - a;\n      }\n      else if (min > array[i+1] - array[i])\n      {\n        a = array[i];\n        b = array[i+1];\n        min = b - a;\n      }\n    }\n\n    std::cout &lt;&lt; a &lt;&lt; " "\n              &lt;&lt; b &lt;&lt; std::endl;\n    DeleteMas(array);\n\n    infile.close();\n  }\n}\n\nvoid CreateMas(int *&mas, int n)\n{\n  mas = new int[n]{};\n}\n\nvoid Print(int *mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; "\\t";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid DeleteMas(int *&mas)\n{\n  delete[] mas;\n  mas = nullptr;\n}\n\n</pre> <p>Файл text.txt</p> <pre>\n10\n1 3 6 10 12 14 17 19 20 30\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Опасные динозавры</h3> <p>В парке Юрского периода случилась авария и все динозавры разбежались по острову. Необходимо помочь доктору Хэммонду отловить всех опасных динозавров на острове. Опасными считаются динозавры, у которых коэффициент К опасности выше 40. Коэффициент рассчитывается по следующей формуле</p> <code>К = Скорость + Агрессивность + Размеры</code> <p>Если этот динозавр хищник, то коэффициент умножается на 2, если всеядный на 1.5, если травоядный на 1.2</p> <p>На входе подаются строки вида</p> <code>Код Название Тип Скорость Агрессивность Размеры</code> <h4>Пример</h4> <code>1 Раптор Хищник 7 10 5</code> <code>2 Трицератопс Травоядный 7 15 8</code> <code>3 Тиранозавр Хищник 10 10 12</code> <p>Необходимо напечатать сколько выездов потребуется команде доктора, чтобы отловить всех опасных динозавров, если за один могут отловить только 3 динозавров</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nstruct Dino {\n  int id;\n  std::string name;\n  std::string type;\n  int speed;\n  int agr;\n  int size;\n\n  // конструктор\n  Dino(int _id, std::string _name, std::string _type,\n       int _speed, int _agr, int _size) {\n    id = _id;\n    name = _name;\n    type = _type;\n    speed = _speed;\n    agr = _agr;\n    size = _size;\n  }\n\n  // конструктор по умолчанию\n  Dino(){}\n\n  int Dangerous() {\n    int K = speed + agr + size;\n    if (type == "Trav")\n    {\n      K *= 1.2;\n    }\n    else if (type == "Vseyad")\n    {\n      K *= 1.5;\n    }\n    else\n    {\n      K *= 2;\n    }\n    return K;\n  }\n\n  void Print()\n  {\n    std::cout &lt;&lt; id &lt;&lt; " " &lt;&lt; name &lt;&lt; std::endl;\n  }\n};\n\nint main() {\n  // 1й способ задать динозавра\n  // через конструктор по умолчанию\n  Dino Raptor;\n  Raptor.id = 1;\n  Raptor.name = "Raptor";\n  Raptor.type = "Hishnik";\n  Raptor.speed = 10;\n  Raptor.agr = 5;\n  Raptor.size = 15;\n\n  std::cout &lt;&lt; Raptor.name &lt;&lt; " has Dangerous ";\n  std::cout &lt;&lt; Raptor.Dangerous() &lt;&lt; std::endl;\n\n  // 2й способ задать динозавра через конструктор\n  Dino Tirex(2, "Tirex", "Vseyad", 12, 15, 13);\n\n  std::cout &lt;&lt; Tirex.name &lt;&lt; " has Dangerous ";\n  std::cout &lt;&lt; Tirex.Dangerous() &lt;&lt; std::endl;\n\n  // 3й способ задать динозавра через new\n  // создается объект, доступ к его полям через ->\n  Dino* Centavr = new Dino(3, "Centavr", "Trav", 15, 13, 12);\n\n  std::cout &lt;&lt; Centavr->name &lt;&lt; " has Dangerous ";\n  std::cout &lt;&lt; Centavr->Dangerous() &lt;&lt; std::endl;\n\n  // 4й способ задать динозавра из файла\n  std::ifstream infile;\n  infile.open("text_d.txt");\n  Dino* Reks = new Dino();\n  infile &gt;&gt; Reks->id &gt;&gt; Reks->name\n          &gt;&gt; Reks->type &gt;&gt; Reks->speed\n          &gt;&gt; Reks->agr &gt;&gt; Reks->size;\n  Reks->Print();\n\n  std::cout &lt;&lt; Reks->name &lt;&lt; " has Dangerous ";\n  std::cout &lt;&lt; Reks->Dangerous() &lt;&lt; std::endl;\n\n  // 5й способ задать массив динозавров из файла\n  int size{};\n  std::ifstream infile2;\n  infile2.open("text_d2.txt");\n  infile2 &gt;&gt; size;\n  Dino* Dinos = new Dino[size];\n\n  for (int i = 0; i &lt; size; i++)\n  {\n    infile2 &gt;&gt; Dinos[i].id &gt;&gt; Dinos[i].name\n            &gt;&gt; Dinos[i].type &gt;&gt; Dinos[i].speed\n            &gt;&gt; Dinos[i].agr &gt;&gt; Dinos[i].size;\n    Dinos[i].Print();\n  }\n\n  // посчитаем сколько опасных (К>40) динозавров\n  int count{};\n  for (int i = 0; i &lt; size; i++)\n  {\n    if (Dinos[i].Dangerous() > 40) {\n      count++;\n    }\n  }\n\n  std::cout &lt;&lt; "Count Danger Dinos ";\n  std::cout &lt;&lt; count &lt;&lt; std::endl;\n\n  // сколько выездов потребуется команде доктора\n  int result{};\n  for (int i = 0; i &lt; count; i += 3)\n  {\n      result++;\n  }\n\n  std::cout &lt;&lt; "Result ";\n  std::cout &lt;&lt; result &lt;&lt; std::endl;\n\n  return 0;\n}\n</pre> <p>Файл text_d.txt</p> <code>4 Reks Trav 4 8 12</code> <p>Файл text_d2.txt</p> <pre>\n5\n1 Raptor Hishnik 10 5 15\n2 Tirex Vseyad 12 15 13\n3 Centavr Trav 15 13 12\n4 Reks Trav 4 8 12\n5 Tiranozavr Trav 12 13 20\n</pre> </article> ','<article class="article"> <h1>Лекция 11 (23.12.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#task1">Задача 1. Опасные динозавры</a></p> <p><a href="#task2">Задача 2. Покемоны</a></p> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Опасные динозавры</h3> <p>В парке Юрского периода случилась авария и все динозавры разбежались по острову. Необходимо помочь доктору Хэммонду отловить всех опасных динозавров на острове. Опасными считаются динозавры, у которых коэффициент К опасности выше 40. Коэффициент рассчитывается по следующей формуле</p> <code>К = Скорость + Агрессивность + Размеры</code> <p>Если этот динозавр хищник, то коэффициент умножается на 2, если всеядный на 1.5, если травоядный на 1.2</p> <p>На входе подаются строки вида</p> <code>Код Название Тип Скорость Агрессивность Размеры</code> <h4>Пример</h4> <code>1 Раптор Хищник 7 10 5</code> <code>2 Трицератопс Травоядный 7 15 8</code> <code>3 Тиранозавр Хищник 10 10 12</code> <p>Необходимо напечатать сколько выездов потребуется команде доктора, чтобы отловить всех опасных динозавров, если за один могут отловить только 3 динозавров</p> <p>Файл dsr_11.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include "Dino.h"\n\nint main() {\n\n  setlocale(LC_ALL, "Russian");\n\n  // Создаем массив динозавров из файла\n  int size{};\n  std::ifstream infile;\n  infile.open("text.txt");\n  if (!infile.is_open()) {\n    std::cout &lt;&lt; "Ошибка открытия файла";\n    return 1;\n  }\n\n  infile >> size;\n  Dino* Dinos = new Dino[size];\n\n  for (int i = 0; i &lt; size; i++) {\n    infile >> Dinos[i].id >> Dinos[i].name\n          >> Dinos[i].type >> Dinos[i].speed\n          >> Dinos[i].agr >> Dinos[i].size;\n    Dinos[i].Print();\n  }\n  std::cout &lt;&lt; std::endl;\n\n  // посчитаем сколько опасных (К>40) динозавров\n  int count{};\n  for (int i = 0; i &lt; size; i++) {\n    if (Dinos[i].Dangerous() > 40) {\n      std::cout &lt;&lt; Dinos[i].name &lt;&lt; " "\n                &lt;&lt; Dinos[i].Dangerous();\n      count++;\n      std::cout &lt;&lt; std::endl;\n    }\n  }\n  std::cout &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; "Число опасных динозавров: ";\n  std::cout &lt;&lt; count &lt;&lt; std::endl;\n\n  // сколько выездов потребуется команде доктора\n  int result{};\n  for (int i = 0; i &lt; count; i += 3)\n  {\n      result++;\n  }\n\n  std::cout &lt;&lt; "Потребуется поездок: " &lt;&lt; result &lt;&lt; std::endl;\n\n  infile.close();\n  delete[]Dinos;\n  Dinos = nullptr;\n\n  return 0;\n}\n</pre> <p>Файл Dino.h</p> <pre>\n#pragma once\n\n#include &lt;iostream&gt;\n\nstruct Dino {\n  int id;\n  std::string name;\n  std::string type;\n  int speed;\n  int agr;\n  int size;\n\n  // конструктор\n  Dino(int _id, std::string _name, std::string _type,\n       int _speed, int _agr, int _size) {\n    id = _id;\n    name = _name;\n    type = _type;\n    speed = _speed;\n    agr = _agr;\n    size = _size;\n  }\n\n  // конструктор по умолчанию\n  Dino(){}\n\n  int Dangerous();\n\n  void Print()\n  {\n    std::cout &lt;&lt; id &lt;&lt; " "\n              &lt;&lt; name &lt;&lt; std::endl;\n  }\n};\n</pre> <p>Файл Dino.cpp</p> <pre>\n#include "Dino.h"\n\nint Dino::Dangerous() {\n  int K = speed + agr + size;\n  if (type == "Травоядный") {\n    K *= 1.2;\n  }\n  else if (type == "Всеядный") {\n    K *= 1.5;\n  }\n  else if (type == "Хищник") {\n    K *= 2;\n  }\n  return K;\n}\n</pre> <p>Файл text.txt</p> <pre>\n8\n\n1 Раптор Хищник 7 10 5\n2 Трицератопс Травоядный 7 15 8\n3 Тиранозавр Хищник 10 10 12\n4 Птеранодон Всеядный 15 5 4\n5 Стегозавр Травоядный 5 8 10\n6 Аккилозавр Травоядный 6 7 11\n7 Велоцираптор Хищник 9 9 6\n8 Диплодок Травоядный 4 4 15\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Покемоны</h3> <p>Эш с друзьями начал подготовку к турниру за звание величайшего в мире Мастера Покемонов. Для этого ему нужно собрать себе в дорогу самых сильных покемонов различных типов. Необходимо написать программу для того, чтобы выбрать самых сильных покемонов в своей стихии (сильнейшими считаются покемоны А + За + Зд максимально в своем подвиде). Всего могут встречаться покемоны 5 типов: Электрические, Огненные, Водяные, Земляные и Воздушные</p> <p>На входе подаются</p> <code>"Номер в покедексе" "Название покемона" "Стихия покемона" "Атака" "Защита" "Здоровье"</code> <h4>Пример</h4> <code>1 Пикачу Электричество 12 3 30</code> <code>2 Бульбазавр Земляной 33 23 40</code> <code>3 Пиджи Воздух 15 0 40</code> <p>Необходимо сформировать строку из номеров и названий покемонов, которых Эш возьмет в свое путешествие</p> <p>Файл dsr_11.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include "Pokemon.h"\n\nint main() {\n  setlocale(LC_ALL, "Russian");\n\n  std::ifstream infile;\n  infile.open("text.txt");\n\n  if (!infile.is_open()) {\n    std::cout &lt;&lt; "Файл не открылся!";\n    return 1;\n  }\n\n  int size{};\n  infile >> size;\n  Pokemon* pokemons = new Pokemon[size];\n  for (int i = 0; i &lt; size; i++) {\n    std::string s;\n    infile >> pokemons[i].pokemon_id >> pokemons[i].pokemon_name\n           >> s >> pokemons[i].attack\n           >> pokemons[i].defense >> pokemons[i].health;\n\n    if (s == "Электрический") {\n      pokemons[i].pokemon_type = PokemonType::Electric;\n    } else if (s == "Огненный") {\n      pokemons[i].pokemon_type = PokemonType::Fire;\n    } else if (s == "Водяной") {\n      pokemons[i].pokemon_type = PokemonType::Water;\n    } else if (s == "Земляной") {\n      pokemons[i].pokemon_type = PokemonType::Earth;\n    } else if (s == "Воздушный") {\n      pokemons[i].pokemon_type = PokemonType::Air;\n    }\n  }\n\n  for (int i = 0; i &lt; size; i++) {\n    pokemons[i].Print();\n    std::cout &lt;&lt; std::endl;\n  }\n\n  Pokemon* new_team = new Pokemon[5]();\n\n  for (int i = 0; i &lt; size; i++) {\n    if (pokemons[i].Level() > 40) {\n      switch (pokemons[i].pokemon_type) {\n        case PokemonType::Fire: {\n          if (new_team[(int)PokemonType::Fire].pokemon_id &lt; 0) {\n            new_team[(int)PokemonType::Fire] = pokemons[i];\n          } else if (new_team[(int)PokemonType::Fire].Level() > pokemons[i].Level()) {\n            new_team[(int)PokemonType::Fire] = pokemons[i];\n          }\n          break;\n        }\n        case PokemonType::Water: {\n          if (new_team[static_cast&lt;int&gt;(PokemonType::Water)].pokemon_id &lt; 0) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Water)] = pokemons[i];\n          } else if (new_team[static_cast&lt;int&gt;(PokemonType::Water)].Level() > pokemons[i].Level()) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Water)] = pokemons[i];\n          }\n          break;\n        }\n        case PokemonType::Electric: {\n          if (new_team[static_cast&lt;int&gt;(PokemonType::Electric)].pokemon_id &lt; 0) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Electric)] = pokemons[i];\n          } else if (new_team[static_cast&lt;int&gt;(PokemonType::Electric)].Level() > pokemons[i].Level()) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Electric)] = pokemons[i];\n          }\n          break;\n        }\n        case PokemonType::Earth: {\n          if (new_team[static_cast&lt;int&gt;(PokemonType::Earth)].pokemon_id &lt; 0) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Earth)] = pokemons[i];\n          } else if (new_team[static_cast&lt;int&gt;(PokemonType::Earth)].Level() > pokemons[i].Level()) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Earth)] = pokemons[i];\n          }\n          break;\n        }\n        case PokemonType::Air: {\n          if (new_team[static_cast&lt;int&gt;(PokemonType::Air)].pokemon_id &lt; 0) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Air)] = pokemons[i];\n          } else if (new_team[static_cast&lt;int&gt;(PokemonType::Air)].Level() > pokemons[i].Level()) {\n            new_team[static_cast&lt;int&gt;(PokemonType::Air)] = pokemons[i];\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n</pre> <p>Файл Pokemon.h</p> <pre>\n#pragma once\n#include &lt;string&gt;\n\nenum class PokemonType { Fire, Electric, Water, Earth, Air };\n\nstruct Pokemon {\n  int pokemon_id;\n  std::string pokemon_name;\n  PokemonType pokemon_type;\n  int attack;\n  int defense;\n  int health;\n\n  Pokemon (int _pokemon_id, std::string _pokemon_name,\n         PokemonType _pokemon_type, int _attack,\n         int _defense, int _health):\n  pokemon_id(_pokemon_id),\n  pokemon_name(_pokemon_name),\n  pokemon_type(_pokemon_type),\n  attack(_attack),\n  defense(_defense),\n  health(_health) {\n\n  }\n\n  // конструктор по умолчанию\n  Pokemon(){\n    pokemon_id = -1;\n    pokemon_name = "";\n    int attack = -1;\n    int defense = -1;\n    int health = -1;\n  }\n\n  void Print() {\n    std::string s;\n    switch (pokemon_type) {\n      case PokemonType::Fire: {\n        s = "Огненный";\n        break;\n      }\n      case PokemonType::Water: {\n        s = "Водяной";\n        break;\n      }\n      case PokemonType::Electric: {\n        s = "Электрический";\n        break;\n      }\n      case PokemonType::Earth: {\n        s = "Земляной";\n        break;\n      }\n      case PokemonType::Air: {\n        s = "Воздушный";\n        break;\n      }\n    }\n    std::cout &lt;&lt; pokemon_id &lt;&lt; " "\n    &lt;&lt; pokemon_name &lt;&lt; " "\n    &lt;&lt; s &lt;&lt; " "\n    &lt;&lt; attack &lt;&lt; " "\n    &lt;&lt; defense &lt;&lt; " "\n    &lt;&lt; health &lt;&lt; " ";\n  }\n\n  int Level() {\n    return attack + defense + health;\n  }\n};\n</pre> <p>Файл text.txt</p> <pre>\n9\n\n1 Электромон Электрический 12 3 30\n2 Вулканик Огненный 15 4 28\n3 Водяка Водяной 10 5 32\n4 Сандерон Земляной 14 6 35\n5 Стратус Воздушный 13 2 31\n6 Волтекс Электрический 17 5 33\n7 Молния Электрический 19 2 28\n8 Магнитус Электрический 14 4 30\n9 Пламор Огненный 20 3 26\n</pre> </article> ','<article class="article"> <h1>Лекция 12 (11.02.2025)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#p1">Линейный поиск</a></p> <p><a href="#p2">Бинарный поиск</a></p> <p><a href="#p3">Левый и правый бинарный поиск</a></p> <p><a href="#p4">Тернарный поиск</a></p> <p><a href="#p5">Экспоненциальный поиск</a></p> <p><a href="#task1">Задание 1. Найти индекс числа в массиве</a></p> <p><a href="#task2">Задание 2. Найти минимальный диапазон индексов</a></p> <p><a href="#home-work">Домашнее задание</a></p> <p><a href="#leetcode4">(Hard) LeetCode 4. Median of Two Sorted Arrays </a></p> </article> <article class="article"> <div class="anchor" id="p1"></div> <h3>Линейный (последовательный) поиск</h3> <ol> <li>Скорость по времени в наихудшем случае</li> <li>Затраты памяти O(1)</li> <li>Brute-force метод, или метод полного перебора</li> </ol> <h4>Алгоритм</h4> <ol> <li>Начинаем с первого элемента последовательно просматриваем весь массив</li> <li>Сравниваем каждое значение с искомым</li> <li>Если элемент найден, то возвращаем индекс этого элемента</li> </ol> <p>Для нахождения искомого просматриваем каждый элемент</p> <pre>\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint line_search(int* array, int n, int target) {\n  int position{-1};\n\n  for (int i{}; i &lt; n; i++) {\n    if (array[i] == target) {\n      position = i;\n      break;\n    }\n  }\n\n  return position;\n}\n\nint main() {\n  cout &lt;&lt; line_search(new int[12] {1, 2, 3, 4, 6, 7, 8, 11, 14, 15, 16, 17}, 12, 7);\n}\n</pre> </article> <article class="article"> <div class="anchor" id="p2"></div> <h3>Бинарный (двоичный) поиск</h3> <ol> <li>Определяем левую и правую границы в качестве первого и последнего элементов массива</li> <li>Делим всю последовательность пополам и находим элемент в середине</li> <li>Если искомый элемент меньше серединного элемента, то обрабатываем левую сторону, в противном случае - наоборот. Если элемент равен, то возварщаем его индекс</li> <li>Повторяем алгоритм пока не найдем необходимый элемент или не убедимся в его отсутсвии</li> </ol> <h4>Пример 1</h4> <p>Дан массив nums и число target.</p> <code>nums = [1,2,4,6,8,12,15,16,19,20,22,25]; target = 6</code> <h4>Решение</h4> <p>Устанавливаем первоначальные границы</p> <code>int left = 0, right = 11;</code> <p>Вычисляем средний элемент</p> <code>int middle = (left + right) / 2; // (0 + 11) / 2 = 5</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] > target; // 12 > 6</code> <p>Правую границу сдвигаем на middle - 1</p> <code>right = middle - 1; // 5 - 1 = 4</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (0 + 4) / 2 = 2</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] &lt; target; // 4 &lt; 6</code> <p>Левую границу сдвигаем на middle + 1</p> <code>left = middle + 1; // 2 + 1 = 3</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (3 + 4) / 2 = 3</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] == target; // 6 == 6</code> <p>Получили совпадение, возвращаем индекс middle</p> <h4>Пример 2</h4> <p>Дан массив nums и число target.</p> <code>nums = [1,2,4,6,8,12,15,16,19,20,22,25]; target = 7</code> <h4>Решение</h4> <p>Устанавливаем первоначальные границы</p> <code>int left = 0, right = 11;</code> <p>Вычисляем средний элемент</p> <code>int middle = (left + right) / 2; // (0 + 11) / 2 = 5</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] > target; // 12 > 7</code> <p>Правую границу сдвигаем на middle - 1</p> <code>right = middle - 1; // 5 - 1 = 4</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (0 + 4) / 2 = 2</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] &lt; target; // 4 &lt; 7</code> <p>Левую границу сдвигаем на middle + 1</p> <code>left = middle + 1; // 2 + 1 = 3</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (3 + 4) / 2 = 3</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] == target; // 6 &lt; 7</code> <p>Левую границу сдвигаем на middle + 1</p> <code>left = middle + 1; // 3 + 1 = 4</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (4 + 4) / 2 = 4</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] == target; // 8 > 7</code> <p>Совпадения нет, left == right, поис закончен. Возвращаем -1</p> <h4>Рекурсивный подход</h4> <p>+ Код более компактный и читаемый</p> <p>- Больше затрат памяти</p> <p>Возможность переполнения стека</p> <h4>Код рекурсивный метод</h4> <pre>\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint binary_search(int* array, int target, int left, int right) {\n  if (left > right) {\n    return -1;\n  }\n\n  int middle = (left + right) / 2;\n  if (array[middle] == target) {\n    return middle;\n  } else if (array[middle] &lt; target) {\n    return binary_search(array, target, middle + 1, right);\n  } else {\n    return binary_search(array, target, left, middle - 1);\n  }\n}\n\nint binary_search_r(int* array, int n, int target)\n{\n  int left{};\n  int right = n - 1;\n  if (array[left] > target || array[right] &lt; target)\n  {\n    return -1;\n  }\n\n  return binary_search(array, target, left, right);\n}\n\nint main() {\n  cout &lt;&lt; binary_search_r(new int[12] {1, 2, 3, 4, 6, 7, 8, 11, 14, 15, 16, 17}, 12, 7);\n}\n</pre> <h4>Итеративный подход</h4> <p>+ Меньше потребление ресурсов</p> <h4>Код итеративный</h4> <pre>\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint binary_search_i(int* array, int n, int target) {\n  int left{};\n  int right = n - 1;\n\n  if (array[left] > target || array[right] &lt; target) {\n    return -1;\n  }\n  int middle = (left + right) / 2;\n\n  while (left &lt;= right) {\n    if (array[middle] == target) {\n      return middle;\n    } else if (array[middle] &lt; target) {\n      left = middle + 1;\n    } else {\n      right = middle - 1;\n    }\n    middle = (left + right) / 2;\n  }\n\n  return -1;\n}\n\nint main() {\n  cout &lt;&lt; binary_search_i(new int[12] {1, 2, 3, 4, 6, 7, 8, 11, 14, 15, 16, 17}, 12, 7);\n}\n</pre> <p>Возможная проблема - переполнение при поиске середины, когда left и right очень большие</p> <code>middle = (left + right) / 2</code> <p>Вариант решения проблемы</p> <code>middle = left + (right - left) / 2</code> </article> <article class="article"> <div class="anchor" id="p3"></div> <h3>Левый и правый бинарный поиск</h3> <h4>Алгоритм</h4><ol> <li>Цикл продолжается пока не останется два элемента, вмессто одного, как раньше. Условие становится <code>left + 1 &lt; right</code> </li> <li>Двигаем правую и левую границу строго на middle</li> <li>В конце алгоритма, если ищем первое вхождение (левый бинарный поиск), то вначале проверяем индекс левой границы, а потом правой</li> <li>Если ищем последнее вхождение, то сначала выбираем правый, а только потом левый</li> </ol> <h4>Пример 1</h4> <p>Дан массив nums и число target. Найти первое вхождение</p> <code>nums = [1,2,4,6,6,6,6,8,12,20,22,25], target = 6</code> <h4>Решение</h4> <p>Устанавливаем первоначальные границы</p> <code>int left = 0, right = 11;</code> <p>Вычисляем средний элемент</p> <code>int middle = (left + right) / 2; // (0 + 11) / 2 = 5</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] == target; // 6 == 6</code> <p>Правую границу сдвигаем на middle</p> <code>right = middle; // 5</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (0 + 5) / 2 = 2</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] &lt; target; // 4 &lt; 6</code> <p>Левую границу сдвигаем на middle</p> <code>left = middle; // 2</code> <p>Вычисляем средний элемент</p> <code>middle = (left + right) / 2; // (2 + 5) / 2 = 3</code> <p>Сравниваем средний элемент с target</p> <code>nums[middle] == target; // 6 == 6</code> <p>Правую границу сдвигаем на middle</p> <code>right = middle; // 3</code> <p>left и right стоят на соседних элементах. Сначала проверяем левую границу, потом правую. Правая совпадает с target возвращаем правую границу</p> <code>return right; // 3</code> </article> <article class="article"> <div class="anchor" id="p4"></div> <h3>Тернарный поиск</h3> <h4>Алгоритм</h4> <p>Разбиение происходит не на две части, как в бинарном поиске, а на три</p> <ol> <li>Задаются левая и правая границы, точно так же как и в бинарном поиске</li> <li> Вычисляются центральные элементы <code>ml = left + (right - left) / 3</code> <code>mr = right - (right - left) / 3</code> </li> <li>Проверяем ml и mr на равенство target и сдвигаем left и right соответствующим образом</li> <li>Делаем так пока left &lt; right</li> <li>Пересчитываем ml и mr</li> </ol> <h4>Пример</h4> <p>Дан массив nums и число target. Найти его в массиве</p> <code>nums = [1,2,4,6,8,12,15,16,19,20,22,25], target = 12</code> <h4>Решение</h4> <p>Устанавливаем первоначальные границы</p> <code>int left = 0, right = 11;</code> <p>Вычисляем средние элементы</p> <code>ml = 4, mr = 7</code> <p>Сравниваем средние элементы с target</p> <code>nums[ml] &lt; target; // 8 &lt; 12</code> <code>nums[mr] &gt; target; // 16 &gt; 12</code> <p>Левую границу сдвигаем на ml</p> <code>left = ml; // 4</code> <p>Правую границу сдвигаем на mr</p> <code>right = mr; // 7</code> <p>Вычисляем средние элементы</p> <code>ml = 5, mr = 6</code> <p>Сравниваем средние элементы с target</p> <code>nums[ml] == target; // 12 == 12</code> <code>nums[mr] &gt; target; // 15 &gt; 12</code> <p>Левая середина совпала, возвращаем ее</p> <code>return ml</code> <h4>Код рекурсивный метод</h4> <pre>\nint ternary_search(int* array, int target, int left, int right) {\n  if (left > right) {\n    return -1;\n  }\n\n  int ml = left + (right - left) / 3;\n  int mr = right - (right - left) / 3;\n\n  if (array[ml] == target) {\n    return ml;\n  }\n  if (array[mr] == target) {\n    return mr;\n  }\n  if (target &lt; array[ml]) {\n    return ternary_search(array, target, left, ml - 1);\n  } else if (target > array[mr]) {\n    return ternary_search(array, target, mr + 1, right);\n  } else {\n    return ternary_search(array, target, ml + 1, mr - 1);\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="p5"></div> <h3>Экспоненциальный поиск</h3> <h4>Алгоритм</h4> <p>Экспоненциальный поиск предназначен для сужения области поиска</p> <ol> <li>Вводим переменную border = 1</li> <li>Сравнимаем значение border с искомым</li> <li>Если значение под индексом border меньше искомого значения, увеличиваем его в два раза</li> <li>Если border стало больше длины массива, то применяем бинарный поиск от border / 2 до конца массива</li> <li>Если значение элемента под индексом border стало больше искомого элемента, то применяем бинарный поиск от border / 2 до border</li> </ol> <h4>Пример</h4> <p>Дан массив nums и число target. Найти его в массиве</p> <code>nums = [1,2,4,6,8,12,15,16,19,20,22,25], target = 12</code> <h4>Решение</h4> <p>Создаем переменную border равную 1 и находим элемент под индексом border</p> <code>border = 1</code> <code>nums[border] = 2</code> <p>Сравниваем его с target</p> <code>nums[border] &lt; target; // 2 &lt; 12</code> <p>Увеличиваем border в два раза</p> <code>border *= 2; // 2</code> <p>Сравниваем его с target</p> <code>nums[border] &lt; target; // 4 &lt; 12</code> <p>Увеличиваем border в два раза</p> <code>border *= 2; // 4</code> <p>Сравниваем его с target</p> <code>nums[border] &lt; target; // 8 &lt; 12</code> <p>Увеличиваем border в два раза</p> <code>border *= 2; // 8</code> <p>Сравниваем его с target</p> <code>nums[border] &gt; target; // 19 &gt; 12</code> <p>Попали на элемент, который больше target, значит нашли область для поиска от border / 2 до border</p> <p>Теперь применяем бинарный или тернарный поиск</p> <code>middle = (right + left) / 2 ; // (8 + 2) / 2 = 5</code> <p>Сравниваем middle и target</p> <code>nums[middle] == target; // nums[5] == 12</code> <p>middle и target равны. Мы нашли искомый элемент. Можно вернуть его индекс</p> <code>return middle</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задание 1. Найти индекс числа в массиве</h3> <p>Дан осортированный по возрастанию массив целых чисел и заданное число. Если заданное число уже находится в массиве, верните его индекс. Если числа в массиве нет, верните индекс, где оно должно находиться, чтобы сохранить порядок сортировки</p> <h4>Формат входных данных</h4> <p>В первой строке задается число N - количество элементов в массиве.</p> <p>Во второй строке вводится массив из N целых чисел, разделенных пробелами.</p> <p>В третьей строке задается число target, для которого нужно найти индекс.</p> <h4>Формат выходных данных</h4> <p>Программа должна вывести одно число - индекс числа target, если оно уже есть в массиве, или индекс, где оно должно находиться для сохранения порядка сортировки.</p> <h4>Пример</h4> <pre>\n5\n5 7 9 11 13\n6\n</pre> <code>1</code> <details> <summary>Решение</summary> <p>Рекурсивное решение. Ищет только индекс элемента, если он есть в массиве</p> <pre>\n#include &lt;iostream&gt;\n\nint binary_search(int* arr, int target, int left, int right) {\n  if (left > right) {\n    return -1;\n  }\n\n  int middle = left + (right - left) / 2;\n  if (arr[middle] == target) {\n    return middle;\n  } else if (target &lt; arr[middle]) {\n    return binary_search(arr, target, left, middle - 1);\n  } else {\n    return binary_search(arr, target, middle + 1, right);\n  }\n}\n\nint binary_search_r(int* arr, int n, int target) {\n  int left{};\n  int right = n - 1;\n  if (arr[left] > target || arr[right] &lt; target) {\n    return -1;\n  }\n  return binary_search(arr, target, left, right);\n}\n\nint main() {\n  std::cout &lt;&lt; binary_search_r(new int[12] {1,2,3,4,6,7,8,11,14,15,16,17}, 12, 11);\n}\n</pre> </details> <details> <summary>Мое решение</summary> <p>Ищет индекс числа target, если оно уже есть в массиве, или индекс, где оно должно находиться для сохранения порядка сортировки.</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nbool good(std::vector&lt;int&gt; arr, int middle, int target) {\n  return arr[middle] >= target;\n}\n\nint binary_search(std::vector&lt;int&gt; arr, int n, int target) {\n  int left = -1;\n  int right = n - 1;\n\n  // ответ в правом указателе\n  while (right - left > 1) {\n    int middle = left + (right - left) / 2;\n    if (good(arr, middle, target)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n  }\n\n  return right;\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::vector&lt;int&gt; A(n);\n  for (int i = 0; i &lt; n; i++) {\n    std::cin >> A[i];\n  }\n  int target;\n  std::cin >> target;\n\n  std::cout &lt;&lt; binary_search(A, n, target);\n}\n</pre> </details> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задание 2. Найти минимальный диапазон индексов</h3> <p>Дан отсортированный по возрастанию массив целых чисел и некоторое целое число. Ваша задача - найти минимальный диапазон индексов (подмассив), в котором может находиться заданное число. Используйте метод экспоненциального поиска.</p> <h4>Формат входных данных</h4> <p>В первой строке задается число N - количество элементов в массиве</p> <p>Во второй строке вводится массив из N целых чисел, разделенных пробелами</p> <p>В третьей строке задается целое число target, для которого нужно найти диапазон</p> <h4>Формат выходных данных</h4> <p>Программа должна вывести два числа через пробел, представляющие диапазон индексов, где может находиться число target. Если число находится в массиве, это должен быть диапазон, содержащий индекс числа. Если число отсутствует, диапазон должен содержать индексы, где оно могло бы быть вставлено</p> <h4>Пример</h4> <pre>\n11\n8 11 12 16 18 21 33 36 48 54 63\n16\n</pre> <code>2 4</code> <p>Число 16 находится в подмассиве от индекса 2 до индекса 4</p> <details> <summary>Решение</summary> <pre>\n#include &lt;iostream&gt;\n\nint exp_search(int* array, int n, int target) {\n  int border = 1;\n  while (border &lt; n) {\n    if (target &lt; array[border]) {\n      return border;\n    }\n    border *= 2;\n  }\n  return n;\n}\n\nint main () {\n  int n{};\n  std::cin >> n;\n\n  int* array = new int[n]();\n\n  for (int i = 0; i &lt; n; i++) {\n    std::cin >> array[i];\n  }\n\n  int target{};\n  std::cin >> target;\n  int right = exp_search(array, n, target);\n  std::cout &lt;&lt; right / 2 &lt;&lt; " " &lt;&lt; right;\n}\n</pre> </details> </article> <article class="article"> <div class="anchor" id="home-work"></div> <h3>Домашнее задание</h3> <p><a href="https://leetcode.com/problem-list/binary-search/">https://leetcode.com/problem-list/binary-search/</a></p> <p>Можно посмотреть простенькие задачки вот тут, в большей части идут пояснения для решений.</p> </article> <article class="article"> <div class="anchor" id="leetcode4"></div> <h3>(Hard) LeetCode 4. Median of Two Sorted Arrays</h3> <p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/">https://leetcode.com/problems/median-of-two-sorted-arrays/description/</a></p> <p>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.</p> <p>The overall run time complexity should be O(log (m+n)).</p> <h4>Example 1:</h4> <code>Input: nums1 = [1,3], nums2 = [2]</code> <code>Output: 2.00000</code> <p>Explanation: merged array = [1,2,3] and median is 2.</p> <h4>Example 2:</h4> <code>Input: nums1 = [1,2], nums2 = [3,4]</code> <code>Output: 2.50000</code> <p>Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.</p> <details> <summary>Решение</summary> <pre>\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ndouble findMedianSortedArrays(\nvector&lt;int&gt;& nums1, vector&lt;int&gt;& nums2);\n\nint main() {\n  vector&lt;int&gt; nums1 = { 1, 3 }, nums2 = { 2 };\n  double res = findMedianSortedArrays(nums1, nums2);\n  cout &lt;&lt; res &lt;&lt; \'\\n\';\n\n  nums1 = { 1, 2 }, nums2 = { 3, 4 };\n  res = findMedianSortedArrays(nums1, nums2);\n  cout &lt;&lt; res &lt;&lt; \'\\n\';\n}\n\ndouble findMedianSortedArrays(\nvector&lt;int&gt;& nums1, vector&lt;int&gt;& nums2) {\n  int m = nums1.size();\n  int n = nums2.size();\n  int k = m + n;\n  vector&lt;int&gt; nums3;\n  int p1{}, p2{};\n  double median{};\n\n  while (p1 &lt; m && p2 &lt; n) {\n    if (nums1[p1] > nums2[p2]) {\n      nums3.push_back(nums2[p2]);\n      p2++;\n    } else {\n      nums3.push_back(nums1[p1]);\n      p1++;\n    }\n  }\n\n  while (p1 &lt; m) {\n    nums3.push_back(nums1[p1]);\n    p1++;\n  }\n\n  while (p2 &lt; n) {\n    nums3.push_back(nums2[p2]);\n    p2++;\n  }\n\n  if (k % 2 == 1) {\n    median = nums3[k / 2];\n  } else {\n    median = (double)(nums3[k / 2 - 1] + nums3[k / 2]) / 2;\n  }\n\n  return median;\n}\n</pre> </details> </article> ','<article class="article"> <h1>Лекция 13 (18.02.2025)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#p1">Односвязный список</a></p> <p><a href="#task1">Задача 1. Удалить все вхождения заданного элемента из списка</a></p> <p><a href="#task2">Задача 2. Удалить все дубликаты из списка</a></p> <p><a href="#task3">Задача 3. Объединить два упорядоченных списка меняя ссылки в исходных списках</a></p> </article> <article class="article"> <div class="anchor" id="p1"></div> <h3>Односвязный список</h3> <p>Файл dsr.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Tlist.h"\n\nint main() {\n  // 1й способ создать список\n  Node* head = initList(1);\n  printList(head);\n\n  // 2й способ создать список\n  Node* head2 = new Node(2);\n  printList(head2);\n\n  // 3й способ создать список\n  Node* head3;\n  initList(head3, 3);\n  printList(head3);\n\n  addToHead(head, 6);\n  addToHead(head, 7);\n  addToHead(head, 8);\n  addToHead(head, 9);\n  printList(head);\n\n  Node* AfterNode = find(head, 7);\n  addAfterNode(AfterNode, 11);\n  printList(head);\n\n  deleteAfterNode(AfterNode);\n  printList(head);\n\n  AfterNode = find(head, 5);\n  deleteAfterNode(AfterNode);\n  printList(head);\n}\n</pre> <p>Файл Tlist.h</p> <pre>\n#pragma once\n\nstruct Node {\n  int data;\n  Node* next;\n\n  Node() {\n    data = 0;\n    next = nullptr;\n  }\n\n  Node(int element) {\n    data = element;\n    next = nullptr;\n  }\n};\n\nvoid initList(Node*& head, int element);\nNode* initList(int element);\nvoid initList(Node*& head);\nvoid addToHead(Node*& head, int element);\nvoid deleteFromHead(Node*& head);\nbool isEmpty(Node* head);\nvoid printList(Node* head);\nvoid addAfterNode(Node* pNode, int element);\nvoid deleteAfterNode(Node* pNode);\nNode* find(Node* head, int element);\n</pre> <p>Файл Tlist.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Tlist.h"\n\nvoid initList(Node*& head, int element) {\n  head = new Node();\n  head->data = element;\n  head->next = nullptr;\n}\n\nNode* initList(int element) {\n  Node* newNode = new Node();\n  newNode->data = element;\n  newNode->next = nullptr;\n  return newNode;\n}\n\nvoid initList(Node*& head) {\n  head = nullptr;\n}\n\nvoid addToHead(Node*& head, int element) {\n  Node* temp = new Node();\n  temp->data = element;\n  temp->next = head;\n  head = temp;\n}\n\nvoid deleteFromHead(Node*& head) {\n  Node* temp = head;\n  head = head->next;\n  delete temp;\n  temp = nullptr;\n}\n\nbool isEmpty(Node* head) {\n  return head == nullptr;\n}\n\nvoid printList(Node* head) {\n  Node* ptr = head;\n  while (ptr) {\n    std::cout &lt;&lt; ptr->data &lt;&lt; " ";\n    ptr = ptr->next;\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid addAfterNode(Node* pNode, int element) {\n  Node* temp = new Node(element);\n  temp->next = pNode->next;\n  pNode->next = temp;\n}\n\nvoid deleteAfterNode(Node* pNode) {\n  if (isEmpty(pNode)) {\n    return;\n  }\n  Node* temp = pNode->next;\n  if (isEmpty(temp)) {\n    return;\n  }\n  pNode->next = temp->next;\n  delete temp;\n  temp = nullptr;\n}\n\nNode* find(Node* head, int element) {\n  Node* ptr = head;\n  while (ptr) {\n    if (ptr->data == element) {\n      break;\n    }\n    ptr = ptr->next;\n  }\n  return ptr;\n}\n</pre> <p>Рекультат</p> <pre>\n1\n2\n3\n9 8 7 6 1\n9 8 7 11 6 1\n9 8 7 6 1\n9 8 7 6 1\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Удалить все вхождения заданного элемента из списка</h3> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Удалить все дубликаты из списка</h3> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Объединить два упорядоченных списка меняя ссылки в исходных списках</h3> </article> ','<article class="article"> <h1>Лекция 14 (04.03.2025)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#task1">Задача 1. Поиск корня</a></p> <p><a href="#task2">Задача 2. Минимальная сторона квадрата</a></p> <p><a href="#task3">Задача 3. Очень легкая задача</a></p> <p><a href="#p1">Двусвязный список</a></p> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Поиск корня</h3> <p>Поиск корня числа или ближайшего целого к нему</p> <details> <summary>Решение</summary> <pre>\n#include &lt;iostream&gt;\n\nint binarySearch(int);\n\nint main() {\n  int target;\n  std::cout &lt;&lt; "enter number ";\n  std::cin >> target;\n  int result = binarySearch(target);\n  std::cout &lt;&lt; "sqrt = " &lt;&lt; result;\n}\n\nint binarySearch(int target) {\n  int left = 0;\n  int right = target;\n\n  while (right >= left) {\n    int middle = (left + right) / 2;\n    if (middle * middle > target) {\n      right = middle - 1;\n      continue;\n    }\n    if (middle * middle &lt; target) {\n      left = middle + 1;\n      continue;\n    }\n    return middle;\n  }\n\n  return right;\n}</pre> </details> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Минимальная сторона квадрата</h3> <p>Петя активно участвует во всех олимпиадах по математике и физике. Он накопил 9 дипломов, которые лежали в столе, и он не знал, что с ними делать. И вот Петя решил разместить свои награды на квадратной доске</p> <h4>Пример</h4> <p>9 прямоугольных дипломов размером 3 на 4, которые надо разместить на квадратной доске</p> <p>Даны n дипломов и x на y размер доски. Необходимо найти минимальную сторону квадрата для размещения всех дипломов</p> <details> <summary>Решение</summary> <pre>\n#include &lt;iostream&gt;\n\nint binarySearch(int, int, int);\n\nint main() {\n  int n, w, h;\n  std::cout &lt;&lt; "enter n w h ";\n  std::cin >> n >> w >> h;\n  int result = binarySearch(n, w, h);\n  std::cout &lt;&lt; "square side = " &lt;&lt; result;\n}\n\nint binarySearch(int n, int w, int h) {\n  int left = std::max(w, h);\n  int right = left * n;\n\n  while (right >= left) {\n    int middle = (left + right) / 2;\n    int res = (middle/w) * (middle/h);\n    if (res &lt; n) {\n      left = middle;\n    } else {\n      right = middle;\n    }\n    return middle;\n  }\n  return right;\n}\n</pre> </details> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Очень легкая задача</h3> <p>Сегодня утром жюри решило добавить в вариант олимпиады еще одну очень легкую задачу.</p> <p>Ответственный секретарь оргкомитета напечатал ее условие в одном экземпляре и теперь ему нужно до начала олимпиады успеть сделать еще N копий.</p> <p>В его распоряжении имеются два ксерокса, один из которых копирует лист за X минут, а другой - за Y минут.</p> <p>Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.</p> <p>Помогите ему выяснить, какое минимальное время для этого потребуется.</p> <details> <summary>Решение</summary> <pre>\n#include &lt;iostream&gt;\n\nint binCopy(int, int, int);\n\nint main() {\n  int n, x, y;\n  std::cout &lt;&lt; "enter n x y ";\n  std::cin >> n >> x >> y;\n  int result = binCopy(n, x, y);\n  std::cout &lt;&lt; "time = " &lt;&lt; result;\n}\n\nint binCopy(int n, int x, int y) {\n  int left = 0;\n  int right = (n -1) * std::max(x, y);\n\n  while (left + 1 &lt; right) {\n    int middle = (right + left) / 2;\n    if (middle / x + middle / y &lt; n - 1) {\n      left = middle;\n    } else {\n      right = middle;\n    }\n  }\n\n  return right * std::min(x, y);\n}\n</pre> </details> </article> <article class="article"> <div class="anchor" id="p1"></div> <h3>Двусвязный список</h3> <p>Файл lec14.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "TDList.h"\n\nint main() {\n  TDList list("text.txt");\n  list.print();\n  std::cout &lt;&lt; \'\\n\';\n  TDList list1("text.txt", [](int x, int y) {return x > y; });\n  list1.print();\n}\n</pre> <p>Файл TDList.h</p> <pre>\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;functional&gt;\n#include &lt;fstream&gt;\n\nstruct Node {\n  int info;\n  Node* next, * prev;\n  Node(int _info, Node* _next = nullptr, Node* _prev = nullptr) :\n  info(_info), next(_next), prev(_prev) {};\n  ~Node() {\n    next = nullptr;\n    prev = nullptr;\n  }\n};\n\nstruct TDList {\n  Node* head, * tail;\n  int size;\n\n  TDList() {\n    head = nullptr;\n    tail = nullptr;\n  }\n  TDList(std::string file_name);\n  ~TDList() {\n    while (!empty()) {\n      remove(head);\n    }\n  }\n  TDList(std::string file_name, std::function&lt;bool(int, int)&gt; compare);\n  void first_node(int elem);\n  void insert_after(Node*, int elem);\n  void insert_before(Node*, int elem);\n  bool empty();\n  void remove(Node*& ptr);\n  void remove_before(const Node*& ptr);\n\n  void print();\n};\n</pre> <p>Файл TDList.cpp</p> <pre>\n#include "TDList.h"\n\nTDList::TDList(std::string file_name) {\n  std::ifstream file(file_name);\n  if (file.is_open()) {\n    int elem;\n    file >> elem;\n    first_node(elem);\n    while (file >> elem) {\n      insert_after(tail, elem);\n    }\n\n    file.close();\n  }\n}\n\nTDList::TDList(std::string file_name, std::function&lt;bool(int, int)&gt; compare) {\n  std::ifstream file(file_name);\n  if (file.is_open()) {\n    int elem;\n    file >> elem;\n    first_node(elem);\n    auto find_place = [this, compare](int elem)->Node* {\n      Node* p = head;\n      while (p && compare(p->info, elem)) {\n        p = p->next;\n      }\n      return p;\n    };\n    while (file >> elem) {\n      Node* place = find_place(elem);\n      if (place) {\n        insert_before(place, elem);\n      } else {\n        insert_after(place, elem);\n      }\n\n    }\n\n    file.close();\n  }\n}\n\nvoid TDList::first_node(int elem) {\n  head = new Node(elem);\n  tail = head;\n}\n\nvoid TDList::insert_after(Node *ptrNode, int elem) {\n  Node* NewPTR = new Node(elem, ptrNode->next, ptrNode);\n  if (ptrNode == tail) {\n    tail = NewPTR;\n  } else {\n    ptrNode->prev->next = NewPTR;\n  }\n  ptrNode->next = NewPTR;\n}\n\nvoid TDList::insert_before(Node* place, int elem) {\n  Node* p = new Node(elem, place, place->prev);\n  if (place == head) {\n    head = p;\n  } else {\n    place->prev->next = p;\n  }\n  place->prev = p;\n}\n\nbool TDList::empty() {\n  return head == nullptr;\n}\n\nvoid TDList::remove(Node*& ptr) {\n  Node* p = ptr;\n  if (ptr == head) {\n    head = p->next;\n    if (p->next) {\n      p->next->prev = nullptr;\n    }\n  } else if (ptr == tail) {\n    tail = p->prev;\n    if (p->prev) {\n      p->prev->next = nullptr;\n    }\n  } else {\n    ptr = ptr->next;\n    p->next->prev = p->prev;\n    p->prev->next = p->next;\n  }\n  delete p;\n}\n\nvoid TDList::print() {\n  Node* ptr = head;\n  while (ptr) {\n    std::cout &lt;&lt; ptr->info &lt;&lt; " ";\n    ptr = ptr->next;\n  }\n}\n\nvoid TDList::remove_before(const Node*& ptr) {\n  Node* p = ptr->prev;\n  if (ptr != head) {\n    if (p == head) {\n      head = p->next;\n      p->next->prev = nullptr;\n    } else {\n      p->next->prev = p->prev;\n      p->prev->next = p->next;\n    }\n    delete p;\n  }\n}\n</pre> <p>Файл text.txt</p> <code>1 2 10 6 5 4</code> </article> ','<article class="article"> <h1>Лекция 15 (11.03.2025)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#p1">Стек</a></p> <p><a href="#task1">Задача 1. Вагоны и тупик</a></p> </article> <article class="article"> <div class="anchor" id="p1"></div> <h3>Стек</h3> <p>Напишем структуру данных стек в двух файлах stack.cpp и stack.h</p> <p>Файл stack.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Stack.h"\n\nusing namespace std;\n\nint main() {\n  Stack&lt;int&gt; stack1;\n\n  stack1.push(12);\n  stack1.push(123);\n  stack1.push(1235);\n  cout &lt;&lt; stack1.top() &lt;&lt; \'\\n\';\n\n  stack1.pop();\n  cout &lt;&lt; stack1.top() &lt;&lt; \'\\n\';\n}\n</pre> <p>Файл Stack.h</p> <pre>\n#pragma once\n\ntemplate &lt;typename T&gt;\nclass Stack {\n\n  private:\n    struct Node {\n      T data;\n      Node* next;\n      Node(const T& value) :data(value), next(nullptr) {};\n    };\n    Node* topNode;\n  public:\n    Stack() :topNode(nullptr) {};\n    ~Stack() {\n      while (!isEmpty()) {\n        pop();\n      }\n    }\n    void push(const T& value) {\n      Node* newNode = new Node(value);\n      newNode->next = topNode;\n      topNode = newNode;\n    }\n    void pop() {\n      // проверка на пустоту\n      Node* temp = topNode;\n      topNode = topNode->next;\n      delete temp;\n    }\n    T top() {\n      // проверка на пустоту\n      return topNode->data;\n    }\n    bool isEmpty() {\n      return topNode == nullptr;\n    }\n};\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Вагоны и тупик</h3> <p>Дано n вагонов. Вагоны стоят на первом пути.Их нужно перегнать на второй путь используя тупик. В качестве тупика будем использовать структуру данных стек. Вагоны можно брать только по порядку и только по одному. Вагон всегда сначала заходит в стек, а потом вагон из стека может быть отправлен да второй путь. Вагон из стека уже не может вернуться на первый путь.</p> <p>Нужно вернуть "Success" если вагоны можно перегнать на второй путь так чтобы они стояли там по порядку возрастания номеров и "Fault" если нельзя.</p> <p>Заведем переменную exp это ожидаемый вагон. Вначале мы ждем вагон номер 1</p> <p>Файл wagons.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include "Stack.h"\n\nusing namespace std;\n\nint main() {\n  Stack&lt;int&gt; stack1;\n  int N = 4;\n  vector&lt;int&gt; wagons(N);\n  for (int i{}; i &lt; N; i++) {\n    // добавление исправить\n    cin >> wagons[i];\n  }\n\n  int exp = 1;\n  for (int i = 0; i &lt; N; i++) {\n    if (wagons[i] == exp) {\n      // удаление элементов из вектора,\n      // перегонка их в стек и вывод из стека\n      exp++;\n    } else {\n      while (!stack1.isEmpty() && stack1.top() == exp) {\n        stack1.pop();\n        exp++;\n      }\n      stack1.push(wagons[i]);\n    }\n  }\n  while (!stack1.isEmpty() && stack1.top() == exp) {\n    stack1.pop();\n    exp++;\n  }\n  if (exp == N + 1) {\n    cout &lt;&lt; "Success";\n  } else {\n    cout &lt;&lt; "Fault";\n  }\n}\n</pre> <p>Файл Stack.h</p> <pre>\n#pragma once\n\ntemplate &lt;typename T&gt;\nclass Stack {\n\n  private:\n    struct Node {\n      T data;\n      Node* next;\n      Node(const T& value) :data(value), next(nullptr) {};\n    };\n    Node* topNode;\n  public:\n    Stack() :topNode(nullptr) {};\n    ~Stack() {\n      while (!isEmpty()) {\n        pop();\n      }\n    }\n    void push(const T& value) {\n      Node* newNode = new Node(value);\n      newNode->next = topNode;\n      topNode = newNode;\n    }\n    void pop() {\n      // проверка на пустоту\n      Node* temp = topNode;\n      topNode = topNode->next;\n      delete temp;\n    }\n    T top() {\n      // проверка на пустоту\n      return topNode->data;\n    }\n    bool isEmpty() {\n      return topNode == nullptr;\n    }\n};\n</pre> </article> '];function y(){var n=document.querySelector(".lections"),t=document.querySelectorAll(".js-dsr-lecture");if(t){console.log(t);for(var e=function(e){t[e].addEventListener("click",(function(t){t.preventDefault(),b[e]&&(n.innerHTML=b[e],function(){var n=document.querySelector(".lections"),t=document.getElementById("link-to-dsr2024cpp");t&&t.addEventListener("click",(function(t){t.preventDefault(),n.innerHTML=g,y()}))}())}))},i=0;i<t.length;i++)e(i)}}var x,w,k=document.getElementById("maincomponent"),_=document.createElement("section");function j(n){return j="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},j(n)}function M(){M=function(){return n};var n={},t=Object.prototype,e=t.hasOwnProperty,i=Object.defineProperty||function(n,t,e){n[t]=e.value},l="function"==typeof Symbol?Symbol:{},r=l.iterator||"@@iterator",a=l.asyncIterator||"@@asyncIterator",s=l.toStringTag||"@@toStringTag";function o(n,t,e){return Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}),n[t]}try{o({},"")}catch(n){o=function(n,t,e){return n[t]=e}}function d(n,t,e,l){var r=t&&t.prototype instanceof u?t:u,a=Object.create(r.prototype),s=new P(l||[]);return i(a,"_invoke",{value:w(n,e,s)}),a}function c(n,t,e){try{return{type:"normal",arg:n.call(t,e)}}catch(n){return{type:"throw",arg:n}}}n.wrap=d;var p={};function u(){}function m(){}function h(){}var f={};o(f,r,(function(){return this}));var v=Object.getPrototypeOf,g=v&&v(v(N([])));g&&g!==t&&e.call(g,r)&&(f=g);var b=h.prototype=u.prototype=Object.create(f);function y(n){["next","throw","return"].forEach((function(t){o(n,t,(function(n){return this._invoke(t,n)}))}))}function x(n,t){function l(i,r,a,s){var o=c(n[i],n,r);if("throw"!==o.type){var d=o.arg,p=d.value;return p&&"object"==j(p)&&e.call(p,"__await")?t.resolve(p.__await).then((function(n){l("next",n,a,s)}),(function(n){l("throw",n,a,s)})):t.resolve(p).then((function(n){d.value=n,a(d)}),(function(n){return l("throw",n,a,s)}))}s(o.arg)}var r;i(this,"_invoke",{value:function(n,e){function i(){return new t((function(t,i){l(n,e,t,i)}))}return r=r?r.then(i,i):i()}})}function w(n,t,e){var i="suspendedStart";return function(l,r){if("executing"===i)throw new Error("Generator is already running");if("completed"===i){if("throw"===l)throw r;return{value:void 0,done:!0}}for(e.method=l,e.arg=r;;){var a=e.delegate;if(a){var s=k(a,e);if(s){if(s===p)continue;return s}}if("next"===e.method)e.sent=e._sent=e.arg;else if("throw"===e.method){if("suspendedStart"===i)throw i="completed",e.arg;e.dispatchException(e.arg)}else"return"===e.method&&e.abrupt("return",e.arg);i="executing";var o=c(n,t,e);if("normal"===o.type){if(i=e.done?"completed":"suspendedYield",o.arg===p)continue;return{value:o.arg,done:e.done}}"throw"===o.type&&(i="completed",e.method="throw",e.arg=o.arg)}}}function k(n,t){var e=t.method,i=n.iterator[e];if(void 0===i)return t.delegate=null,"throw"===e&&n.iterator.return&&(t.method="return",t.arg=void 0,k(n,t),"throw"===t.method)||"return"!==e&&(t.method="throw",t.arg=new TypeError("The iterator does not provide a '"+e+"' method")),p;var l=c(i,n.iterator,t.arg);if("throw"===l.type)return t.method="throw",t.arg=l.arg,t.delegate=null,p;var r=l.arg;return r?r.done?(t[n.resultName]=r.value,t.next=n.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,p):r:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,p)}function _(n){var t={tryLoc:n[0]};1 in n&&(t.catchLoc=n[1]),2 in n&&(t.finallyLoc=n[2],t.afterLoc=n[3]),this.tryEntries.push(t)}function S(n){var t=n.completion||{};t.type="normal",delete t.arg,n.completion=t}function P(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(_,this),this.reset(!0)}function N(n){if(n){var t=n[r];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var i=-1,l=function t(){for(;++i<n.length;)if(e.call(n,i))return t.value=n[i],t.done=!1,t;return t.value=void 0,t.done=!0,t};return l.next=l}}return{next:T}}function T(){return{value:void 0,done:!0}}return m.prototype=h,i(b,"constructor",{value:h,configurable:!0}),i(h,"constructor",{value:m,configurable:!0}),m.displayName=o(h,s,"GeneratorFunction"),n.isGeneratorFunction=function(n){var t="function"==typeof n&&n.constructor;return!!t&&(t===m||"GeneratorFunction"===(t.displayName||t.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,h):(n.__proto__=h,o(n,s,"GeneratorFunction")),n.prototype=Object.create(b),n},n.awrap=function(n){return{__await:n}},y(x.prototype),o(x.prototype,a,(function(){return this})),n.AsyncIterator=x,n.async=function(t,e,i,l,r){void 0===r&&(r=Promise);var a=new x(d(t,e,i,l),r);return n.isGeneratorFunction(e)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},y(b),o(b,s,"Generator"),o(b,r,(function(){return this})),o(b,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var t=Object(n),e=[];for(var i in t)e.push(i);return e.reverse(),function n(){for(;e.length;){var i=e.pop();if(i in t)return n.value=i,n.done=!1,n}return n.done=!0,n}},n.values=N,P.prototype={constructor:P,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(S),!n)for(var t in this)"t"===t.charAt(0)&&e.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var t=this;function i(e,i){return a.type="throw",a.arg=n,t.next=e,i&&(t.method="next",t.arg=void 0),!!i}for(var l=this.tryEntries.length-1;l>=0;--l){var r=this.tryEntries[l],a=r.completion;if("root"===r.tryLoc)return i("end");if(r.tryLoc<=this.prev){var s=e.call(r,"catchLoc"),o=e.call(r,"finallyLoc");if(s&&o){if(this.prev<r.catchLoc)return i(r.catchLoc,!0);if(this.prev<r.finallyLoc)return i(r.finallyLoc)}else if(s){if(this.prev<r.catchLoc)return i(r.catchLoc,!0)}else{if(!o)throw new Error("try statement without catch or finally");if(this.prev<r.finallyLoc)return i(r.finallyLoc)}}}},abrupt:function(n,t){for(var i=this.tryEntries.length-1;i>=0;--i){var l=this.tryEntries[i];if(l.tryLoc<=this.prev&&e.call(l,"finallyLoc")&&this.prev<l.finallyLoc){var r=l;break}}r&&("break"===n||"continue"===n)&&r.tryLoc<=t&&t<=r.finallyLoc&&(r=null);var a=r?r.completion:{};return a.type=n,a.arg=t,r?(this.method="next",this.next=r.finallyLoc,p):this.complete(a)},complete:function(n,t){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&t&&(this.next=t),p},finish:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.finallyLoc===n)return this.complete(e.completion,e.afterLoc),S(e),p}},catch:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.tryLoc===n){var i=e.completion;if("throw"===i.type){var l=i.arg;S(e)}return l}}throw new Error("illegal catch attempt")},delegateYield:function(n,t,e){return this.delegate={iterator:N(n),resultName:t,nextLoc:e},"next"===this.method&&(this.arg=void 0),p}},n}function S(n,t,e,i,l,r,a){try{var s=n[r](a),o=s.value}catch(n){return void e(n)}s.done?t(o):Promise.resolve(o).then(i,l)}function P(){var n;return n=M().mark((function n(t){return M().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:document.querySelector("#page").appendChild(t);case 2:case"end":return n.stop()}}),n)})),P=function(){var t=this,e=arguments;return new Promise((function(i,l){var r=n.apply(t,e);function a(n){S(r,i,l,a,s,"next",n)}function s(n){S(r,i,l,a,s,"throw",n)}a(void 0)}))},P.apply(this,arguments)}_.classList.add("lections"),k.append(_),(x=document.createElement("div")).classList.add("btn-up","none"),x.innerHTML="НАВЕРХ",x.addEventListener("click",(function(){window.scrollTo({top:0,left:0,behavior:"smooth"})})),window.addEventListener("scroll",(function(){return function(n){(window.scrollY||document.documentElement.scrollTop)>400?n.classList.remove("none"):n.classList.add("none")}(x)})),function(n){P.apply(this,arguments)}(x),w=document.querySelector(".lections"),console.log(w),document.querySelector(".lections").innerHTML=g,y()})()})();
//# sourceMappingURL=index.js.map