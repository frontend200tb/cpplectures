/*! For license information please see index.js.LICENSE.txt */
(()=>{var n={245:()=>{function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n(t)}function t(t,i){for(var e=0;e<i.length;e++){var l=i[e];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(t,(void 0,s=function(t,i){if("object"!==n(t)||null===t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var l=e.call(t,"string");if("object"!==n(l))return l;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(l.key),"symbol"===n(s)?s:String(s)),l)}var s}function i(n){var t="function"==typeof Map?new Map:void 0;return i=function(n){if(null===n||(i=n,-1===Function.toString.call(i).indexOf("[native code]")))return n;var i;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,l)}function l(){return e(n,arguments,a(this).constructor)}return l.prototype=Object.create(n.prototype,{constructor:{value:l,enumerable:!1,writable:!0,configurable:!0}}),s(l,n)},i(n)}function e(n,t,i){return e=l()?Reflect.construct.bind():function(n,t,i){var e=[null];e.push.apply(e,t);var l=new(Function.bind.apply(n,e));return i&&s(l,i.prototype),l},e.apply(null,arguments)}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function s(n,t){return s=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},s(n,t)}function a(n){return a=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},a(n)}var r=document.querySelector("#page"),o=function(i){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&s(n,t)}(p,i);var e,o,c,d,u=(c=p,d=l(),function(){var t,i=a(c);if(d){var e=a(this).constructor;t=Reflect.construct(i,arguments,e)}else t=i.apply(this,arguments);return function(t,i){if(i&&("object"===n(i)||"function"==typeof i))return i;if(void 0!==i)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(t)}(this,t)});function p(){var n;!function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,p),(n=u.call(this)).addEventListener("click",(function(){r.classList.toggle("snow"),t=r.classList.contains("snow")?"snow":"net",localStorage.setItem("snow",t)}));var t=localStorage.getItem("snow")||"snow";return"snow"==t&&r.classList.add("snow"),n}return e=p,(o=[{key:"connectedCallback",value:function(){this.innerHTML='\n    <div id="snow_btn" class="snow_btn"></div>\n    '}}])&&t(e.prototype,o),Object.defineProperty(e,"prototype",{writable:!1}),p}(i(HTMLElement));customElements.define("snow-btn",o)}},t={};function i(e){var l=t[e];if(void 0!==l)return l.exports;var s=t[e]={exports:{}};return n[e](s,s.exports,i),s.exports}(()=>{"use strict";function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n(t)}function t(t,i){for(var e=0;e<i.length;e++){var l=i[e];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(t,(void 0,s=function(t,i){if("object"!==n(t)||null===t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var l=e.call(t,"string");if("object"!==n(l))return l;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(l.key),"symbol"===n(s)?s:String(s)),l)}var s}function e(n){var t="function"==typeof Map?new Map:void 0;return e=function(n){if(null===n||(i=n,-1===Function.toString.call(i).indexOf("[native code]")))return n;var i;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,e)}function e(){return l(n,arguments,r(this).constructor)}return e.prototype=Object.create(n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),a(e,n)},e(n)}function l(n,t,i){return l=s()?Reflect.construct.bind():function(n,t,i){var e=[null];e.push.apply(e,t);var l=new(Function.bind.apply(n,e));return i&&a(l,i.prototype),l},l.apply(null,arguments)}function s(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function a(n,t){return a=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},a(n,t)}function r(n){return r=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},r(n)}var o=function(i){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&a(n,t)}(u,i);var e,l,o,c,d=(o=u,c=s(),function(){var t,i=r(o);if(c){var e=r(this).constructor;t=Reflect.construct(i,arguments,e)}else t=i.apply(this,arguments);return function(t,i){if(i&&("object"===n(i)||"function"==typeof i))return i;if(void 0!==i)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(t)}(this,t)});function u(){return function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,u),d.call(this)}return e=u,(l=[{key:"connectedCallback",value:function(){this.innerHTML='<div class="container"> <header class="header"> <h1>DSR (Doing Software Right)</h1> <div class="snow-right"> <snow-btn></snow-btn> </div> <article class="article"> <h2>C++: Начала программирования</h2> </article> </header> </div> '}}])&&t(e.prototype,l),Object.defineProperty(e,"prototype",{writable:!1}),u}(e(HTMLElement));function c(n){return c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},c(n)}function d(n,t){for(var i=0;i<t.length;i++){var e=t[i];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(n,(void 0,l=function(n,t){if("object"!==c(n)||null===n)return n;var i=n[Symbol.toPrimitive];if(void 0!==i){var e=i.call(n,"string");if("object"!==c(e))return e;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(e.key),"symbol"===c(l)?l:String(l)),e)}var l}function u(n){var t="function"==typeof Map?new Map:void 0;return u=function(n){if(null===n||(i=n,-1===Function.toString.call(i).indexOf("[native code]")))return n;var i;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,e)}function e(){return p(n,arguments,f(this).constructor)}return e.prototype=Object.create(n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),h(e,n)},u(n)}function p(n,t,i){return p=m()?Reflect.construct.bind():function(n,t,i){var e=[null];e.push.apply(e,t);var l=new(Function.bind.apply(n,e));return i&&h(l,i.prototype),l},p.apply(null,arguments)}function m(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function h(n,t){return h=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},h(n,t)}function f(n){return f=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},f(n)}customElements.define("header-component",o),i(245);var v=function(n){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&h(n,t)}(a,n);var t,i,e,l,s=(e=a,l=m(),function(){var n,t=f(e);if(l){var i=f(this).constructor;n=Reflect.construct(t,arguments,i)}else n=t.apply(this,arguments);return function(n,t){if(t&&("object"===c(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}(this,n)});function a(){return function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,a),s.call(this)}return t=a,(i=[{key:"connectedCallback",value:function(){this.innerHTML='<div class="container"> <section id="maincomponent"></section> </div> '}}])&&d(t.prototype,i),Object.defineProperty(t,"prototype",{writable:!1}),a}(u(HTMLElement));customElements.define("main-component",v);const b='<article class="article"> <p>Лекции проходят в главном корпусе ВГУ</p> <p>Аудитория 435, по понедельникам с 18.40 до 20.00</p> <p>Преподаватель - Коток Игорь Дмитриевич</p> <p>Факультет ПММ</p> </article> <article class="article"> <h2>Конспект лекций</h2> <p><a href="lec-1.html" class="js-dsr-lecture">Лекция 1 (16.09.2024)</a></p> <p><a href="lec-2.html" class="js-dsr-lecture">Лекция 2 (23.09.2024)</a></p> <p><a href="lec-3.html" class="js-dsr-lecture">Лекция 3 (7.10.2024)</a></p> <p><a href="lec-4.html" class="js-dsr-lecture">Лекция 4 (14.10.2024)</a></p> <p><a href="lec-5.html" class="js-dsr-lecture">Лекция 5 (21.10.2024)</a></p> <p><a href="lec-6.html" class="js-dsr-lecture">Лекция 6 (5.11.2024)</a></p> <p><a href="lec-7.html" class="js-dsr-lecture">Лекция 7 (11.11.2024)</a></p> <p><a href="lec-8.html" class="js-dsr-lecture">Лекция 8 (18.11.2024)</a></p> <p><a href="lec-9.html" class="js-dsr-lecture">Лекция 9 (9.12.2024)</a></p> </article> ';var y=['<article class="article"> <h1>Лекция 1 (16.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#types">Типы данных</a></p> <p><a href="#base">Основы C++</a></p> <p><a href="#task1">Задача 1. Найти периметр треугольника заданного координатами своих вершин</a></p> <p><a href="#task2">Задача 2. Найти сумму членов арифметической прогрессии</a></p> <p><a href="#task3">Задача 3. Найти сумму членов геометрической прогрессии</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Знакомство</li> <li>Ход курса</li> <li>Типы данных</li> <li>Основы C++</li> </ol> <ol> <li>Теория</li> <li>Практика</li> <li>Домашка</li> </ol> </article> <article class="article"> <div class="anchor" id="types"></div> <h3>Типы данных</h3> <h4>Базовые типы</h4> <ol> <li>bool</li> <li>int</li> <li>float</li> <li>char</li> </ol> <h4>Числовые типы</h4> <ol> <li>short 2 байта</li> <li>int 2-4 байта</li> <li>long 4-8 байт</li> <li>long long 8 байт</li> <li>float 4 байта</li> <li>double 8 байт</li> <li>long double 8+ байт</li> </ol> <h4>Символьные типы</h4> <ol> <li>char 1 байт (ASCII)</li> <li>wchar_t 2-4 байта</li> <li>char8_t 1 байт</li> <li>char16_t 2 байта</li> <li>char32_t 4 байта</li> </ol> <p>Раньше строковые типы данных представлялись массивами типа char</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout &lt;&lt; "Hello, world!\\n";\n  return 0;\n}\n</pre> <p>Output</p> <code>Hello, world!</code> </article> <article class="article"> <div class="anchor" id="base"></div> <h3>Основы C++</h3> <p>Необходимо установить Visual Studio Community</p> <p>Фигурные скобки {} нужно использовать везде где есть логические блоки</p> <h4>Объявление переменной</h4> <p>При объявлении переменной сначала пишут тип данных потом название переменной. При объявлении переменной компилятор выделяет область памяти, размером указанного типа данных, для значения переменной</p> <code>int valInt;</code> <h4>Инициализация переменной</h4> <p>Можно сразу при объявлении инициализировать переменную значением по умолчанию. Для типа int это 0</p> <code>int valInt{}; // 0</code> <p>Можно инициализировать переменную значением</p> <pre>\nint valInt2 = 5;\nint valInt3(6);\nint valInt4{12};\n</pre> <p>Инициализация через {} безопасная, при неправильном значении проект даже не запустится</p> <h4>Операторы ввода и вывода</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int count;\n  std::cout &lt;&lt; "Введите количество кроликов" &lt;&lt; std::endl;\n  std::cin &gt;&gt; count;\n  std::cout &lt;&lt; "Количество кроликов " &lt;&lt; count;\n\n  return 0;\n}\n</pre> <h4>Подключение русской локализации</h4> <p>Если файл не в кодировке UTF-8, то можно подключить русскую локализацию</p> <code>setlocale(LC_ALL, "Russian");</code> <p>Если файл в кодировке UTF-8, то также используют функцию <strong>setlocale()</strong>. В UTF-8 для каждого символа отводится не 1 байт, а 2 или 4 байта. Поэтому нужно использовать другой формат вывода. Вместо объекта <strong>cout</strong> применяется объект <strong>wcout</strong>, который работает с символами Unicode. А перед строкой надо указать символ <strong>L</strong></p> <pre>\n#include &lt;iostream&gt;\nint main() {\n  setlocale(LC_ALL, "");\n  std::wcout &lt;&lt; L"Привет, мир!";\n  return 0;\n}\n</pre> <p>Output</p> <code>Привет, мир!</code> <h4>Количество байт, выделенные под переменные</h4> <code>sizeof(bool)</code> <code>sizeof(int)</code> <code>sizeof(double)</code> <h4>Использование namespase std нежелательно</h4> <code>namespace std; // нежелательно, потому что могут совпадать имена</code> <h4>Возведение в квадрат</h4> <code>a * a; // хорошо</code> <code>pow(a, 2); хуже, потому что выделяется лишняя память</code> <h4>Приостановить действие программы</h4> <code>system("pause");</code> <h4>Очистить поток ввода</h4> <code>std::cin.clear();</code> <code>std::cin.ignore(32767,n);</code> <code>std::cin.get</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найти периметр треугольника заданного координатами своих вершин</h3> <p>Треугольник задан на плоскости координатами своих вершин. Найти его периметр</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x1, x2, x3, y1, y2, y3, a, b, c, p;\n\n  std::cout &lt;&lt; "Введите первую вершину x1 y1" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x1 &gt;&gt; y1;\n  std::cout &lt;&lt; "Введите вторую вершину x2 y2" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x2 &gt;&gt; y2;\n  std::cout &lt;&lt; "Введите третью вершину x3 y3" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x3 &gt;&gt; y3;\n\n  a = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n  b = sqrt((x2-x3)*(x2-x3) + (y2-y3)*(y2-y3));\n  c = sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3));\n  p = a+b+c;\n\n  std::cout &lt;&lt; "Периметр " &lt;&lt; p &lt;&lt; std::endl;\n  return 0;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Найти сумму членов арифметической прогрессии</h3> <p>Дана арифметическая прогрессия</p> <code>10 20 30 40 50</code> <p>Первый член 10, шаг 10, количество членов 5</p> <p>Найти сумму членов арифметической прогрессии Sa</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double a1, d, na, Sa;\n  a1 = 10;\n  d = 10;\n  na = 5;\n\n  Sa = (2*a1+d*(na-1))/2*na;\n\n  std::cout &lt;&lt; Sa;\n}\n</pre> <p>Output</p> <code>150</code> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Найти сумму членов геометрической прогрессии</h3> <p>Дана геометрическая прогрессия</p> <code>10 20 40 80 160</code> <p>Первый член 10, множитель 2, количество членов 5</p> <p>Найти сумму членов геометрической прогрессии Sb</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n  double b1, q, nb, Sb;\n  b1 = 10;\n  q = 2;\n  nb = 5;\n\n  Sb = b1*(1-pow(q,nb))/(1-q);\n\n  std::cout &lt;&lt; Sb;\n}\n</pre> <p>Output</p> <code>310</code> </article> ','<article class="article"> <h1>Лекция 2 (23.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#conv">Преобразования типов</a></p> <p><a href="#task1">Задача 1. Дальнобойщик</a></p> <p><a href="#oper">Операции</a></p> <p><a href="#if">Условие if-else</a></p> <p><a href="#task2">Задача 2. Количество набранных очков</a></p> <p><a href="#task3">Задача 3. Площадь заштрихованной области</a></p> <p><a href="#switch">Условие switch-case</a></p> <p><a href="#task4">Задача 4. Принадлежит ли точка заштрихованной области</a></p> </article> <article class="article"> <div class="anchor" id="conv"></div> <h3>Преобразования типов</h3> <h4>Неявные преобразования типов</h4> <p>bool принимает другой тип</p> <code>bool flag_1 = 3; // true</code> <code>bool flag_2 = 2.5; // true</code> <code>bool flag_3 = 0; // false</code> <p>другой тип приниимает bool</p> <code>int var_int = true; // 1</code> <code>double var_double = false; // 0.00000</code> <p>целочисленное принимает вещественное</p> <code>int var_int_1 = 3.4; // 3</code> <code>int var_int_2 = 6.7; // 6</code> <p>вещественное принимает целочисленное</p> <code>float var_float = 324234222; // 324234208</code> <code>double var_double = 120000000000000011; // 1.2000000000000002e+17</code> <p>Если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается</p> <p>беззнаковые переменные принимают выходящие из диапазона</p> <code>unsigned char a = -5; // 251</code> <code>unsigned short b = -12; // 65524</code> <code>int c = -1; // 4294967295</code> <h4>Безопасные преобразования</h4> <p>bool - char - short - int - double - long double</p> <p>bool - char - short - int - long - long long</p> <p>unsigned char - unsigned short - unsigned int - unsigned long</p> <p>float - double - long double</p> <p>В арифметических операциях из двух типов выбирается максимальный и к нему приводится наименьший из них</p> <h4>Явные преобразования типов</h4> <p>Есть два способа язвного преобразования типа</p> <ol> <li><strong>(type) (value)</strong></li> <li><strong>static_cast&lt;type&gt;(value)</strong></li> </ol> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Дальнобойщик</h3> <p>Дальнобойщик проехал расстояние 130.21км со средней скоростью 8 км/ч. Сколько часов необходимо оплатить ему за проделанную поездку?</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double distance{ 130.21 };\n  unsigned int speed{ 8 };\n\n  unsigned int hours{ (unsigned int) (distance / speed) };\n\n  std::cout &lt;&lt; "Hours = "\n            &lt;&lt; hours &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Hours = 16</code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double distance{ 130.21 };\n  unsigned int speed{ 8 };\n\n  unsigned int hours{ static_cast&lt;unsigned int&gt;(distance / speed) };\n\n  std::cout &lt;&lt; "Hours = "\n            &lt;&lt; hours &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Hours = 16</code> </article> <article class="article"> <div class="anchor" id="oper"></div> <h3>Операции</h3> <h4>Базовые арифметические операции</h4> <p>Сложение a + b</p> <p>Вычитание a - b</p> <p>Умножение a * b</p> <p>Деление a / b</p> <p>Остаток от деления a % b</p> <h4>Операторы присваивания</h4> <p>a += b</p> <p>a -= b</p> <p>a *= b</p> <p>a /= b</p> <p>a %= b</p> <h4>Инкремент и декремент</h4> <p>префиксный инкремент ++a</p> <p>постфиксный инкремент a++</p> <p>префиксный декремент --a</p> <p>постфиксный декремент a--</p> <h4>Внимание подстава!</h4> <pre>\nint a{ 3 };\nint new_a{ --a };\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl; // a = 2\nstd::cout &lt;&lt; "new_a = " &lt;&lt; new_a &lt;&lt; std::endl; // new_a = 2\n</pre> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Приоритет операций</h4> <ol> <li>++, -- (инкремент, декремент)</li> <li>* (умножение), / (деление), % (остаток от деления)</li> <li>+ (сложение), - (вычитание)</li> </ol> <h4>Неоднозначный пример</h4> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Операции сравнения</h4> <p>a == b равно</p> <p>a &lt; b меньше</p> <p>a &lt;= b меньше или равно</p> <p>a &gt; b больше</p> <p>a &gt;= b больше или равно</p> <p>a != b не равно</p> <h4>Операции сравнения</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1{ a == b }; // false</code> <code>bool F2{ a &lt; b }; // true</code> <code>bool F3{ a &lt;= b }; // true</code> <code>bool F4{ a &gt; b }; // false</code> <code>bool F5{ a &gt;= b }; // false</code> <code>bool F6{ a != b }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> <h4>Логические операции</h4> <p>!a отрицание</p> <p>a && b И</p> <p>a || b ИЛИ</p> <p>a ^ b Исключающее ИЛИ</p> <h4>Логические операции</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1( a == b && b > 3 }; // false</code> <code>bool F2( a != b || a == 3 }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> </article> <article class="article"> <div class="anchor" id="if"></div> <h3>Условие if-else</h3> <h4>if</h4> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\n</pre> <h4>if - else</h4> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a &lt;= b\\n";\n}\n</pre> <h4>if - else if - else</h4> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse if (a &lt; b)\n{\n  std::cout &lt;&lt; "a &lt; b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a == b\\n";\n}\n</pre> <h4>Тернарный оператор</h4> <code>a > b ? a++ : b++;</code> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Количество набранных очков</h3> <p>Определить по введенным пользователем координатам попадания выстрела в мишень количество набранных очков</p> <p>3 очка если попали в круг радиусом 5 с центром в (0, 0)</p> <p>2 очка если попали в круг радиусом 10</p> <p>1 очко если попали в круг радиусом 15</p> <h4>Решение</h4> <p>Точка с координатами x, y попадет в круг радиуса r, если расстояние от центра круга до точки меньше r. То есть должно выполняться условие</p> <code>x<sup>2</sup> + y<sup>2</sup> &lt;= r<sup>2</sup></code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  // объявление и инициализация переменных\n  double x{}, y{};\n  int score{};\n\n  // заполнение переменных\n  std::cout &lt;&lt; "Input coords x y\\n";\n  std::cin >> x >> y;\n\n  // Проверка на попадание\n  if (x * x + y * y &lt;= 5 * 5)\n  {\n    score = 3;\n  }\n  else if (x * x + y * y &lt;= 10 * 10)\n  {\n    score = 2;\n  }\n  else if (x * x + y * y &lt;= 15 * 15)\n  {\n    score = 1;\n  }\n\n  // Вывод результатов работы\n  if (score > 0)\n  {\n    std::cout &lt;&lt; "Congratulations! Score = " &lt;&lt; score &lt;&lt; "\\n";\n  }\n  else{\n    std::cout &lt;&lt; "Try again\\n";\n  }\n}\n</pre> <h4>Можно использовать условие</h4> <code>if (score)</code> <p>Потому что score может принимать значения только 0, 1, 2, 3.</p> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Площадь заштрихованной области</h3> <p>Заштрихованная область находится внутри большого круга радиусом 3 с центром в (0, 0) и вне малкенького круга радиусом 1.5 с центром в (0, 1.5)</p> <p>Вычислить значение площади заштрихованной области, если точка с заданными координатами (x, y) попадает в эту область. В противном случае вывести соответствующее сообщение</p> <h4>Решение</h4> <p>Чтобы точка с координатами x, y попала в заштрихованную область должны выполниться два условия. Первое точка должна попасть в круг радиуса R. Второе точка должна не попасть в круг радиуса r с центром rx, ry. То есть</p> <code>x<sup>2</sup> + y<sup>2</sup> &lt;= R<sup>2</sup></code> <code>(x - rx)<sup>2</sup> + (y - ry)<sup>2</sup> &gt;= r<sup>2</sup></code> <p>Площадь заштрихованной области равна площади круга радиуса R минус площадь круга радиуса r</p> <code>pi * R<sup>2</sup> - pi * r<sup>2</sup></code> <pre>\n#define _USE_MATH_DEFINES\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  // объявление и инициализация переменных\n  double x{}, y{}, s{};\n\n  // заполнение переменных\n  std::cout &lt;&lt; "Input x y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  // Проверка на попадание\n  if (x * x + y * y &lt;= 9 && x * x + (y + 1.5) * (y + 1.5) >= 2.25)\n  {\n    std::cout &lt;&lt; "Square =  " &lt;&lt; M_PI * 9 - M_PI * 2.25;\n  }\n  else\n  {\n    std::cout &lt;&lt; "Try again" &lt;&lt; std::endl;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="switch"></div> <h3>Условие switch-case</h3> <pre>\nswitch (/*выражение*/)\n{\n  case // значение1: инструкции1; break;\n  case // значение2: инструкции2; break;\n  default: // инструкции;\n}\n</pre> <h4>Пример реализации</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int counter{ 2 };\n\n  switch (counter)\n  {\n    case 1:\n      std::cout &lt;&lt; "counter = 1" &lt;&lt; std::endl;\n      break;\n    case 2:\n      std::cout &lt;&lt; "counter = 2" &lt;&lt; std::endl;\n      break;\n    case 3:\n      std::cout &lt;&lt; "counter = 3" &lt;&lt; std::endl;\n      break;\n    default:\n      std::cout &lt;&lt; "counter is undefined" &lt;&lt; std::endl;\n      break;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Принадлежит ли точка заштрихованной области</h3> <p>Заштрихованная область ограничена сверху графиком функции y = 2 - x<sup>2</sup>. При x &lt; 0 ограничена снизу функцией y = x. При x &gt;= 0 ограничена снизу функцией y = 0.</p> <p>Требуется написать программу, которая принимает с клавиатуры координаты точки на плоскости (x, y - вещественные числа) и определяет принадлежность точки заштрихованной области, включая ее границы</p> <p>Пояснение</p> <p>Область C лежит в первой четверти (x >= 0, y >= 0). Ограничена сверху графиком y = x. Ограничена снизу графиком y = 0</p> <p>Область G лежит в третьей четверти (x &lt 0, y &lt 0). Ограничена сверху графиком y = x. Ограничена снизу графиком y = 2 - x<sup>2</sup></p> <p>Нужно отдельно проверить через switch попадание в области C и G. Пользователю выводится меню, где указано "Чтобы проверить точку G введите 1" и т.д. switch обрабатывает запрос пользователя и выдает результат проверки на попадание в запрашиваемую область</p> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  // объявление и инициализация переменных\n  double x{}, y{}, s{};\n  int command{};\n\n  // заполнение переменных\n  std::cout &lt;&lt; "Input x y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  // ввод команды\n  std::cout &lt;&lt; "Check all area - press 1" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Check C-area - press 2" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Check G-area - press 3" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Press 1 or 2 or 3" &lt;&lt; std::endl;\n  std::cin >> command;\n\n  switch (command)\n  {\n    case 1:\n      if (x&lt;=0 && y>=x && y &lt;= 2-x*x || x>0 && y&lt;=2-x*x && y>=0)\n      {\n        std::cout &lt;&lt; "In the area\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Out of the area\\n";\n      }\n      break;\n    case 2:\n      if (y&lt;=x && y&lt;=2-x*x && x>0 && y>=0)\n      {\n        std::cout &lt;&lt; "In the C-area\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Out of the C-area\\n";\n      }\n      break;\n    case 3:\n      if (y&lt;=x && y>=2-x*x && y&lt;=0)\n      {\n        std::cout &lt;&lt; "In the G-area\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Out of the G-area\\n";\n      }\n      break;\n    default:\n      std::cout &lt;&lt; "Invalid command\\n";\n  }\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 3 (7.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#while">Цикл while</a></p> <p><a href="#task1">Задача 1. Найти сумму чисел от 1 до 100</a></p> <p><a href="#while2">Вложенный цикл while</a></p> <p><a href="#task2">Задача 2. Вывести таблицу умножения от 1 до 9 while</a></p> <p><a href="#loop">Бесконечные циклы</a></p> <p><a href="#for">Цикл for</a></p> <p><a href="#task3">Задача 3. Вывести квадраты четных чисел от 0 до 20</a></p> <p><a href="#task4">Задача 4. Вывести таблицу умножения от 1 до 9 for</a></p> <p><a href="#task5">Задача 5. Просуммировать все числа от 1 до n</a></p> <p><a href="#dowhile">Цикл do-while</a></p> <p><a href="#task6">Задача 6. Вычитать случайное число</a></p> <p><a href="#bad">Обработка "плохих" данных</a></p> <p><a href="#task7">Задача 7. Вычислить сумму числовой последовательности</a></p> <p><a href="#task8">Задача 8. Вычислить сумму числовой последовательности</a></p> <p><a href="#task9">Задача 9. Вычислить сумму числовой последовательности</a></p> </article> <article class="article"> <div class="anchor" id="while"></div> <h3>Цикл while</h3> <h4>Определение цикла while</h4> <pre>\nwhile (/*выражение*/)\n{\n  //тело_цикла\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найти сумму чисел от 1 до 100</h3> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int i = 0;\n  int sum = 0;\n\n  while (i &lt; 100)\n  {\n    i++;\n    sum += i;\n  }\n\n  std::cout &lt;&lt; "Sum from 1 to 100 = "\n            &lt;&lt; sum &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Sum from 1 to 100 = 5050</code> </article> <article class="article"> <div class="anchor" id="while2"></div> <h3>Вложенный цикл while</h3> <h4>Определение вложенных циклов</h4> <pre>\nwhile (/*выражение1*/)\n{\n  //тело_цикла1\n  while (/*выражение2*/)\n  {\n    //тело_цикла2\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Вывести таблицу умножения от 1 до 9</h3> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы while</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int a{}, b{};\n\n  while (a &lt; 10)\n  {\n    while (b &lt; 10)\n    {\n      std::cout &lt;&lt; a &lt;&lt; "\\tx\\t" &lt;&lt; b\n                &lt;&lt; "\\t=\\t" &lt;&lt; a * b &lt;&lt; std::endl;\n      b++;\n    }\n    std::cout &lt;&lt; std::endl;\n    a++;\n    b = 0;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="loop"></div> <h3>Бесконечные циклы</h3> <pre>\nwhile (true)\n{\n  // этот цикл будет выполняться бесконечно\n}\n</pre> <pre>\nint count = 12;\n\nwhile (count &lt; 20) // всегда будет true\n{\n  std::cout &lt;&lt; count &lt;&lt; " "; // эта строка будет выполняться бесконечно\n}\nreturn 0; // эта строка никогда не выполнится\n</pre> <p>Единственный способ выйти из бесконечного цикла - использовать операторы return, break, goto, выбросить исключение или воспользоваться функцией exit()</p> <h4>continue</h4> <p>Нужно вывести все четные числа от 0 до 30</p> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 == 0)\n  {\n    std::cout &lt;&lt; i &lt;&lt; " ";\n  }\n}\n</pre> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 != 0)\n  {\n    continue;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <h4>break</h4> <pre>\nwhile (i != 0)\n{\n  i--;\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nwhile (1)\n{\n  i--;\n  if (i == 0)\n  {\n    break;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nint count = 1;\nwhile (count &lt;= 50)\n{\n  if (count &lt; 10)\n  {\n    std::cout &lt;&lt; "0" &lt;&lt; count &lt;&lt; " ";\n  }\n  else\n  {\n    std::cout &lt;&lt; count &lt;&lt; " "\n  }\n  if (count % 10 == 0)\n  {\n    std::cout &lt;&lt; "\\n";\n  }\n  ++count;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="for"></div> <h3>Цикл for</h3> <h4>Определение цикла for</h4> <pre>\nfor (/*объявление_переменных*/;/*условие*/;/*инкремент_декремент*/)\n{\n  //тело цикла\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Вывести квадраты четных чисел от 0 до 20</h3> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int num{20};\n\n  for (int i = 0; i &lt; num; i++)\n  {\n    if (i % 2 == 0)\n    {\n      std::cout &lt;&lt; i * i &lt;&lt; " ";\n    }\n  }\n}\n</pre> <p>Output</p> <code>0 4 16 36 64 100 144 196 256 324</code> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Вывести таблицу умножения от 1 до 9</h3> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы for</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  for (int i{1}; i &lt; 10; i++)\n  {\n    for (int j{1}; j &lt; 10; j++)\n    {\n      std::cout &lt;&lt; i &lt;&lt; "\\t x \\t" &lt;&lt; j\n                &lt;&lt; "\\t = \\t" &lt;&lt; i * j &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task5"></div> <h3>Задача 5. Просуммировать все числа от 1 до n</h3> <p>Напишите программу, где пользователь вводит любое целое положительное число. А программа суммирует все числа от 1 до введенного пользователем числа.</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  unsigned int n{};\n  int sum{};\n\n  std::cout &lt;&lt; "Input n ";\n  std::cin >> n;\n\n  for (int i{1}; i &lt;= n; i++)\n  {\n    sum += i;\n  }\n\n  std::cout &lt;&lt; "Sum from 1 to " &lt;&lt; n &lt;&lt; " = "\n            &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="dowhile"></div> <h3>Цикл do-while</h3> <h4>Определение цикла</h4> <pre>\ndo {\n  //тело_цикла\n} while (//условие);\n</pre> </article> <article class="article"> <div class="anchor" id="task6"></div> <h3>Задача 6. Вычитать случайное число</h3> <h4>Библиотека ctime, функции srand(), rand()</h4> <p>Библиотека ctime содержит функции srand(), rand(). Функция srand() устанавливает зерно. Функция rand() вычисляет псевдослучайное число относительно зерна. По умолчанию зерно равно 0.</p> <p>Дано целое число balance = 8. Вычитать из него случайное целое число от 0 до 3, пока balance не станет равным нулю.</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nint main()\n{\n  srand(time(0));\n  int balance = 8;\n\n  do\n  {\n    std::cout &lt;&lt; "balance = " &lt;&lt; balance &lt;&lt; std::endl;\n    int removal = rand() % 3;\n    std::cout &lt;&lt; "removal = " &lt;&lt; removal &lt;&lt; std::endl;\n    balance -= removal;\n  } while (balance > 0);\n\n  std::cout &lt;&lt; "balance = " &lt;&lt; balance &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="bad"></div> <h3>Обработка "плохих" данных</h3> <h4>Оператор извлечения</h4> <p>Если во входном буфере есть данные, то эти данные используются для извлечения.</p> <p>Если во входном буфере нет данных, то пользователю предлагается ввести данные (обычно именно это и происходит в большинстве случаев). Когда пользователь нажимает Enter, символ новой строки \\n помещается во входной буфер</p> <h4>Оператор извлечения &gt;&gt;</h4> <p>Оператор &gt;&gt; извлекает столько данных из входного буфера в переменную, сколько позволяет размер самой переменной (игнорируя любые пробелы, табы и \\n)</p> <p>Любые данные, которые не были извлечены остаются во входном буфере для последующего извлечения</p> <pre>\nint a;\nstd::cin &gt;&gt; a;\n</pre> <p>Пользователь вводит 21Z. 21 записывается в переменную a, при этом в буфере остается Z\\n</p> <h4>Ошибка 1: Извлечение выполняется успешно, но данные бесполезны</h4> <pre>\nwhile (true) // пока пользователь не введет корректные данные\n{\n  std::cout &lt;&lt; "Enter \'+\', \'-\', \'*\', \'/\' :";\n  char sm;\n  std::cin &gt;&gt; sm;\n\n  // вывполняем проверку значений\n  if (sm == \'+\'\' || sm ==\'-\' || sm == \'*\' || sm == \'/\') {\n    return sm; // возвращаем данные в функцию main()\n  } else { // иначе, сообщаем что что-то пошло не так\n    std::cout &lt;&lt; "Invalid input. Try again.\\n";\n  }\n}\n</pre> <h4>Ошибка 2: Извлечение выполняется успешно, но пользователь вводит лишний текст</h4> <pre>\nstd::cout &lt;&lt; "Enter a double value: ";\ndouble a;\nstd::cin &gt;&gt; a;\nstd::cin.ignore(32767, \'\\n\'); // удаляем до 32767 символов\n// из входного буфера вплоть до появления символа \'\\n\'\n\nstd::cin.ignore(std::cin.rdbuf()->in_avail());\n// зачищаем только то, что использовано\n</pre> <h4>Ошибка 3: Извлечение не выполняется</h4> <pre>\nwhile (true) // пока пользователь не введет корректное значение1\n{\n  std::cout &lt;&lt; "Enter a double value: ";\n  double a;\n  std::cin &gt;&gt; a;\n\n  if (std::cin.fail()) // если предыдущее значение оказалось неудачным\n  {\n    std::cin.clear(); // возвращаем cin в обычный режим работы\n    std::cin.ignore(32767, \'\\n\'); // удаляем значения предыдущего ввода из входного буфера\n  }\n  else // если все хорошо, выходим используя break\n  {\n    std::cin.ignore(32767, \'\\n\');\n    break;\n  }\n}\n</pre> <h4>Ошибка 4: Извлечение выполняется успешно, но пользователь ввел слишком большое числовое значение</h4> <pre>\nstd::int16_t x{ 0 };\n// переменная x занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number x between -32768 and 32767: ";\nstd::cin &gt;&gt; x;\n\nstd::int16_t y{ 0 };\n// переменная y занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number y between -32768 and 32767: ";\nstd::cin &gt;&gt; y;\n\nstd::cout &lt;&lt; "The sum is: " &lt;&lt; x + y &lt;&lt; \'\\n\';\n</pre> </article> <article class="article"> <div class="anchor" id="task7"></div> <h3>Задача 7. Вычислить сумму числовой последовательности</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>1 + 1/3 + 1/(3<sup>2</sup>) + ... + 1/(3<sup>8</sup>)</code> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double sum {1};\n  double denominator {1};\n\n  for (int i = 0; i &lt; 8; i++)\n  {\n    denominator *= 3;\n    sum += 1 / denominator;\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> <p>Output</p> <code>1.49992</code> </article> <article class="article"> <div class="anchor" id="task8"></div> <h3>Задача 8. Вычислить сумму числовой последовательности</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>x + x<sup>3</sup>/3 + x<sup>5</sup>/5 + ... + x<sup>11</sup>/11</code> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double sum {};\n  int n {5};\n  double x {2.0};\n  double temp = x;\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += temp;\n    temp = temp * (2 * i - 1) * x * x / (2 * i + 1);\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> <p>Output</p> <code>-115.41</code> </article> <article class="article"> <div class="anchor" id="task9"></div> <h3>Задача 9. Вычислить сумму числовой последовательности</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>e<sup>x</sup> = 1 + x + x<sup>2</sup>/2! + x<sup>3</sup>/3! + x<sup>4</sup>/4! + ...</code> <code>cos x = 1 - x<sup>2</sup>/2! + x<sup>4</sup>/4! + x<sup>6</sup>/6! + ...</code> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! + x<sup>7</sup>/7! + ...</code> </article> ','<article class="article"> <h1>Лекция 4 (14.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#ref">Ссылки</a></p> <p><a href="#point">Указатели</a></p> <p><a href="#t1">Практика. Sum(int, int)</a></p> <p><a href="#t2">Практика. Max(int, int)</a></p> <p><a href="#t3">Практика. Swap(int&, int&)</a></p> <p><a href="#t4">Практика. Print()</a></p> <p><a href="#t5">Практика. Swap(int*, int*)</a></p> <p><a href="#t6">Практика. Sum(int, int, int = 3)</a></p> <p><a href="#t7">Практика. init(int*)</a></p> <p><a href="#t8">Практика. init(int*&)</a></p> </article> <article class="article"> <div class="anchor" id="ref"></div> <h3>Ссылки</h3> <h4>Определение ссылки</h4> <code>тип_данных & название_ссылки = переменная_типа_ссылки;</code> <pre>\nint main()\n{\n  int a = 3;\n  int &refa = a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 3\n\n  refa++;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 4\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 4\n}\n</pre> </article> <article class="article"> <div class="anchor" id="point"></div> <h3>Указатели</h3> <h4>Определение указателя</h4> <code>тип_данных * название_указателя;</code> <pre>\nint main()\n{\n  int a = 3;\n  int *pointA = &amp;a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl;\n\n  std::cout&lt;&lt;&a&lt;&lt;std::endl; // 000000C2E6DAFBF4\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl; //\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;*pointA&lt;&lt;std::endl; // 3\n}\n</pre> <h4>Указатель</h4> <p>Количество выделяемой памяти не изменяется в зависимости от типа переменных на которую ссылается указатель.</p> <pre>\nint *pint{};\ndouble *pdouble{};\n\nstd::cout&lt;&lt;sizeof(pint)&lt;&lt;std::endl; // 8\nstd::cout&lt;&lt;sizeof(pdouble)&lt;&lt;std::endl; // 8\n</pre> <h4>Указатель</h4> <pre>\nint a {10};\nint b {2};\n\nint *pa {&a};\nint *pb {&b};\n\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\nstd::cout&lt;&lt;"pb: address="&lt;&lt;pb&lt;&lt;"\\t value="&lt;&lt;*pb&lt;&lt;std::endl;\n\npa = pb;\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\n*pa = 125;\nstd::cout&lt;&lt;"b value="&lt;&lt;b&lt;&lt;std::endl;\n</pre> <code>pa: address=00000072CAFEFA54 value=10</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>b value=125</code> <h4>Указатель</h4> <pre>\nint a {10};\nint b {6};\n\nint *p{};\nint *&pRef {p};\n\npRef = &a;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n\n*pRef = 70;\nstd::cout&lt;&lt;"a value="&lt;&lt;a&lt;&lt;std::endl;\n\npRef = &b;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n</pre> <code>p value=10</code> <code>a value=70</code> <code>p value=6</code> <h4>Операторы new и delete</h4> <pre>\nint *ptr = new int;\nint *ptr_1 = new int();\nint *ptr_2 {new int(12)};\n\nstd::cout &lt;&lt; *ptr &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_2 &lt;&lt; std::endl;\n\ndelete ptr;\ndelete ptr_1;\ndelete ptr_2;\n\nptr = nullptr;\nptr_1 = nullptr;\nptr_2 = nullptr;\n</pre> <code>-842150451</code> <code>0</code> <code>12</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Sum(int, int)</h3> <p>Найдем сумму двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = a + b;\n}\n</pre> <p>Разделим программу на несколько файлов</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b) = " &lt;&lt; sum &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Практика. Max(int, int)</h3> <p>Добавим в проект функцию Max, возвращающую максимум из двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Max(a,b) = " &lt;&lt; max &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t3"></div> <h3>Практика. Swap(int&, int&)</h3> <p>Добавим в проект функцию Swap, которая ничего не возвращает, принимает адреса двух переменных и меняет местами их значения</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(&a, &b);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t4"></div> <h3>Практика. Print()</h3> <p>Добавим вывод на экран слова Bob. Добавим функцию Print, которая выводит на экран число, сколько раз функция Print вызывалась</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> <p>Статическая переменная i, объявленная внутри функции Print() инициализируется только один раз - при первом вызове функции. Она получает значение i = 0. При повторных вызовах, инициализация не производится.</p> </article> <article class="article"> <div class="anchor" id="t5"></div> <h3>Практика. Swap(int*, int*)</h3> <p>Перепишем функцию Swap(), при которой она будет принимать не адреса, а указатели на две переменные.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  int *pa = &a;\n  int *pb = &b;\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(pa, pb);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t6"></div> <h3>Практика. Sum(int, int, int = 3)</h3> <p>Перепишем функцию Sum(), при которой она будет принимать не два, а три параметра. Причем третий параметр будет необязательным и в случае его отсутствия будет подставляться значение по умолчанию.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "default c = " &lt;&lt; 3 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,c) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  sum = Sum(a, b, 25);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,25) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int, int = 3);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y, int z)\n{\n  return x + y + z;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t7"></div> <h3>Практика. init(int*)</h3> <p>Напишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t8"></div> <h3>Практика. init(int*&)</h3> <p>Перепишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(&a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article>','<article class="article"> <h1>Лекция 5 (21.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#func">Перегрузка функции</a></p> <p><a href="#const1">Константы</a></p> <p><a href="#const2">Указатели на константы</a></p> <p><a href="#const3">Константный указатель</a></p> <p><a href="#const4">Константный указатель на константу</a></p> <p><a href="#const5">Константные параметры</a></p> <p><a href="#const6">Константные ссылочные параметры</a></p> <p><a href="#const7">Вопросы по перегрузке</a></p> <p><a href="#t1">Практика. Сумма ряда</a></p> <p><a href="#t2">Код программы</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Ссылки и указатели</li> <li>Функции</li> <li>Массивы</li> </ol> </article> <article class="article"> <div class="anchor" id="func"></div> <h3>Перегрузка функции</h3> <p>Напишем функцию sum(), которая складывает два целых числа и функцию sum(), которая скаладывает два вещественных числа</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n</pre> <code>9</code> <code>4.1</code> <p>Добавим еще одну функцию sum(), которая складывает три целых числа, причем третий параметр не обязательный, при его отсутствии будет подставляться значение по умолчанию.</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\nint sum(int, int, int = 2);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n\nint sum(int a, int b, int c)\n{\n  return a + b + c;\n}\n</pre> <p>Компилятор не знает какую функцию запустить</p> </article> <article class="article"> <div class="anchor" id="const1"></div> <h3>Константы</h3> <p>const тип_данных & имя_переменной = значение_переменной</p> <p>Объявим константу с инициализацией, а потом попробуем присвоить ей новое значение</p> <pre>\nconst int a = 3;\na = 10; // нельзя\n</pre> <p>Компилятор не будет компилировать, потому что константе нельзя присвоить новое значение</p> <p>Объявим константу без инициализации, а потом попробуем ее инициализировать</p> <pre>\nconst int age; // нельзя\nage = 6;\n</pre> <p>Компилятор не будет компилировать, потому что константу нужно инициализировать только при объявлении.</p> </article> <article class="article"> <div class="anchor" id="const2"></div> <h3>Указатели на константы</h3> <p>const тип_данных * имя_указателя = адресс_переменной</p> <pre>\nconst int a {10};\nconst int *pa {&a};\n\nstd::cout &lt;&lt; "address = " &lt;&lt; pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 4; // нельзя\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nconst int b {45};\npa = &b; // можно\n\nstd::cout &lt;&lt; "*pa = " &lt;&lt; *pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\na = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n</pre> </article> <article class="article"> <div class="anchor" id="const3"></div> <h3>Константный указатель</h3> <p>тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nint *const pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\nint b {45};\npa = &b; // нельзя\n</pre> </article> <article class="article"> <div class="anchor" id="const4"></div> <h3>Константный указатель на константу</h3> <p>const тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nconst int *const pa {&a};\nint b {45};\n</pre> </article> <article class="article"> <div class="anchor" id="const5"></div> <h3>Константные параметры</h3> <pre>\nvoid square(int);\n//void square(const int);\n\nint main()\n{\n  int number {12};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int a)\n{\n  std::cout &lt;&lt; "a * a = " &lt;&lt; a * a &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 144</code> </article> <article class="article"> <div class="anchor" id="const6"></div> <h3>Константные ссылочные параметры</h3> <pre>\nvoid square(const int&);\n\nint main()\n{\n  const int number {6};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int &n)\n{\n  std::cout &lt;&lt; "n * n = " &lt;&lt; n * n &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 36</code> </article> <article class="article"> <div class="anchor" id="const7"></div> <h3>Вопросы по перегрузке</h3> <pre>\nvoid show(int);\nvoid show(int&);\n\nvoid print(int);\nvoid print(const int);\n\nint square(int*);\nint square(const int*);\n\nint square(int* num)\n{\n  return *num * *num;\n}\n\nint square(const int* num)\n{\n  return *num * *num;\n}\n</pre> <p>Компилятор не различает в данном случае & и const от простой реализации</p> <pre>\nconst int n1{2};\nint n2{3};\n\nint square_n1 {square(&n1)};\nint square_n2 {square(&n2)};\n\nstd::cout &lt;&lt; "square(n1) = " &lt;&lt; square_n1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; "square(n2) = " &lt;&lt; square_n2 &lt;&lt; std::endl;\n</pre> <code>4</code> <code>9</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Сумма ряда</h3> <p>Вычислить суммму ряда</p> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ...</code> <p>Для начала попробуем упростить выражение</p> <code>S<sub>n</sub> = sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ... + (-1)<sup>n</sup> * (x<sup>2n+1</sup>)/(2n+1)!</code> <code>q = a<sub>n</sub>/a<sub>n-1</sub></code> <code>q = (-1)<sup>n</sup> * x<sup>2n+1</sup>/(2n+1)! * (2n-1)!/(x<sup>2n-1</sup> * (-1)<sup>n-1</sup>)</code> <code>q = (-1)<sup>n-n+1</sup> * x<sup>2n+1-2n+1</sup> * (2n-1)!/(2n+1)!</code> <p>Так как</p> <code>n! = 1*2*3*...*n</code> <code>(n-1)! = 1*2*3*...*(n-1)</code> <p>То</p> <code>n! = (n-1)!*n</code> <p>Тогда</p> <code>(2n+1)! = (2n-1)! * 2n * (2n+1)</code> <p>Подставим это вместо (2n+1)!</p> <code>q = (-1) * x<sup>2</sup> * (2n-1)! / ((2n-1)! * 2n * (2n+1))</code> <code>q = (-1) * x<sup>2</sup> / (2n * (2n+1))</code> <h4>1 часть</h4> <p>Так как при i=0 множитель даст деление на 0, начинаем с 1, а самое первое значение заносим заранее в ai</p> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; i &lt; n; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <h4>2 часть</h4> <p>Посчитаем с погрешностью. Пусть погрешность будет очень маленькая величина</p> <code>eps = 1.0e-10;</code> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; abs(ai)>eps; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <p>С каждым шагом ai стремится к нашей точности eps, уменьшается. Чем выше точность eps (чем оно меньше), тем ближе к значению S<sub>точ</sub>. Таким образом мы считаем S<sub>n</sub>до тех пор, пока абсолютное значение ai не станет меньше eps</p> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Код программы</h3> <pre>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    std::cout &lt;&lt; "Введите 1- Сумма ряда" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 2- Сумма ряда c погрешностью" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 3- Завершение программы" &lt;&lt; std::endl;\n\n    bool isError{ true };\n    do {\n\n      std::cin >> choice;\n      if (!std::cin.fail()&& choice&lt;=3 && choice>=1)\n      {\n        isError = false;\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n      else\n      {\n        std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n        std::cin.clear();\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n\n    } while (isError);\n\n    if (choice != 3)\n    {\n      double x{};\n      isError = true;\n      do {\n\n        std::cout &lt;&lt; "Введите x " &lt;&lt; std::endl;\n        std::cin >> x;\n        if (!std::cin.fail())\n        {\n          isError = false;\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n        else\n        {\n          std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n          std::cin.clear();\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n\n      } while (isError);\n\n      if (choice == 1)\n      {\n\n        double Sn{};\n        int N{};\n        std::cout &lt;&lt; "Введите кол-во элементов ряда" &lt;&lt; std::endl;\n        std::cin >> N;\n        double ai{ x };\n        for (int i = 1; i &lt; N; i++)//ошибочка\n        {\n          Sn += ai;\n          ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n        }\n        std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; N\n        &lt;&lt; " элементах ряда =" &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n\n\n      }\n      else if (choice == 2)\n      {\n\n\n        int i{};\n        double eps = 1.0E-12;\n\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          double ai{ x };\n\n          for (i = 1; abs(ai) > eps; i++)\n          {\n            Sn += ai;\n            ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n          }\n          std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; i\n          &lt;&lt; " элементах ряда ="&lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n          std::cout &lt;&lt; "Точное значение" &lt;&lt; sin(x) &lt;&lt; std::endl;\n          eps /= 100;\n\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, другое - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n\n\n  } while (choice != 3);\n\n}\n</iomanip></iostream></pre> </article> ','<article class="article"> <h1>Лекция 6 (5.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#lamb">Лямбда-функции</a></p> <p><a href="#lamb1">Определение лямбда-функций</a></p> <p><a href="#lamb2">"Захват" лямбда-выражения</a></p> <p><a href="#lamb3">Примеры использования</a></p> <p><a href="#t1">Код программы</a></p> </article> <article class="article"> <div class="anchor" id="lamb"></div> <h3>Лямбда-функции</h3> </article> <article class="article"> <div class="anchor" id="lamb1"></div> <h3>Определение лямбда-функций</h3> <pre>\n     1   2     3       4       5\n     |   |     |       |       |\n    --- --- ------- ------- --------\n    [=] ()  mutable throw() -> int\n  |  {\n  |    int n = x + y;\n  |\n  |    x = y;\n6-|    y = n;\n  |\n  |    return n;\n  |  }\n</pre> <ol> <li>Capture clause - список внешних захватываемых параметров</li> <li>Список передаваемых параметров</li> <li>Спецификация изменений</li> <li>Спецификация исключений</li> <li>Тип возвращаемого значения</li> <li>Тело функции</li> </ol> </article> <article class="article"> <div class="anchor" id="lamb2"></div> <h3>"Захват" лямбда-выражения</h3> <ol> <li> <h4>По значению</h4> <pre>\nint n{10};\nstd::function&lt;void(int)&gt; add =\n       [=](int x) { std::cout &lt;&lt; x + n &lt;&lt; std::endl; };\n\nadd(5); // выведет 15\n</pre> <p>[=] Внешнюю переменную n изменять нельзя - программа не скомпилируется</p> </li> <li> <h4>По ссылке</h4> <pre>\nint n{10};\nstd::function&lt;void(int)&gt; add =\n       [&](int x) { std::cout &lt;&lt; x + ++n &lt;&lt; std::endl; };\n\nadd(5); // выведет 16\ncout &lt;&lt; n; // выведет 11\n</pre> <p>[&] Внешнюю переменную n изменять можно. Она также изменится за пределами функции</p> </li> <li> <h4>mutable</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n{10};\n  auto increment = [=]() mutable {\n    n++; // увеличиваем значение внешней переменной\n    std::cout &lt;&lt; "n inside lambda: " &lt;&lt; n &lt;&lt; std::endl;\n  };\n  increment();\n  std::cout &lt;&lt; "n outside lambda: " &lt;&lt; n &lt;&lt; std::endl;\n}\n</pre> <p>mutable Внешняя переменная n передается по значению, но внутри лямбда-выражения ее можно изменять. За пределами она не изменится</p> </li> <li> <h4>Все по значению, кроме одной по ссылке</h4> <pre>\nint n{10}, n_2{ 8 };\nauto add = [=, &n](int x)\n{ std::cout &lt;&lt; x + ++n + n_2 &lt;&lt; std::endl; };\n\nadd(5); // выведет 24\ncout &lt;&lt; nl // выведет 11\n</pre> <p>[=, &n] все переменные передаются по значению и их изменять нельзя, но переменная n передается по ссылке и ее изменять можно. За пределами функции она тоже изменится.</p> </li> <li> <h4>Ошибка</h4> <pre>\nint n{10}, n_2{ 8 };\nauto add = [&, &n](int x)\n{ std::cout &lt;&lt; x + ++n + n_2 &lt;&lt; std::endl; };\n\nadd(5); // ошибка\ncout &lt;&lt; n_2; // ошибка\n</pre> <p>[&, &n] все переменные передаются по ссылке и переменная n тоже передается по ссылке. Это условие избыточное. Компилироваться такая строчка не будет</p> </li> <li> <h4>Все по значению, кроме одной по ссылке</h4> <pre>\n#include &lt;iostream&gt;\n#include &lt;function&gt;\n\nusing namespace std;\n\nint main()\n{\n  int n{ 10 }, n_2{ 8 };\n  std::function&lt;void(int)&gt; lambda_func = [=, &n_2](int x)\n  { std::cout &lt;&lt; x + ++n_2 - n &lt;&lt; std::endl; };\n\n  lambda_func(5); // выведет 13\n}\n</pre> <p>[=, &n_2] все переменные передаются по значению и их изменять нельзя, но переменная n_2 передается по ссылке и ее изменять можно. За пределами функции она тоже изменится.</p> </li> </ol> </article> <article class="article"> <div class="anchor" id="lamb3"></div> <h3>Примеры использования</h3> <ol> <li> <h4>Логические выражения. Передача по значению</h4> <pre>\nint n{ 4 };\nstd::function&lt;bool(int)&gt; lambda_func_bool =\n       [](int x) { return x &gt; 1 && x &lt; 3; };\ncout &lt;&lt; lambda_func_bool(n); // 0\n\ndouble r{ 5 };\ndouble x{ 4 }, y{ 2 };\nauto lambda_func_r =\n       [r](double x, double y) { return x * x + y * y &lt;= r * r; };\ncout &lt;&lt; lambda_func_r(x, y); // 1\n\nr = 1;\ncout &lt;&lt; lambda_func_r(x, y); // 1\n</pre> <p>[r] переменная r передается по значению и равна значению, которое было при первом вызове лямбда-функции. Если после вызова лямбда-функции переменную r изменить, то при следующем вызове лямбда-функции все равно останется ее старое значение</p> </li> <li> <h4>Логические выражения. Передача по ссылке</h4> <pre>\nint n{ 4 };\nstd::function&lt;bool(int)&gt; lambda_func_bool =\n       [](int x) { return x &gt; 1 && x &lt; 3; };\ncout &lt;&lt; lambda_func_bool(n); // 0\n\ndouble r{ 5 };\ndouble x{ 4 }, y{ 2 };\nauto lambda_func_r =\n       [&r](double x, double y) { return x * x + y * y &lt;= r * r; };\ncout &lt;&lt; lambda_func_r(x, y); // 1\n\nr = 1;\ncout &lt;&lt; lambda_func_r(x, y); // 0\n</pre> <p>[&r] переменная r передается по ссылке. Если после вызова лямбда-функции переменную r изменить, то при следующем вызове лямбда-функции она тоже изменится</p> </li> <li> <h4>Замена переменных</h4> <pre>\ndouble a{ 4 }, b{ 2 };\nstd::function&lt;void(double&, double&)&gt; lambda_func_swap\n= [](double& x, double& y)\n{\n  double temp = x;\n  x = y;\n  y = temp;\n};\n\nlambda_func_swap(a, b);\ncout &lt;&lt; a &lt;&lt; " " &lt;&lt; b; // 2 4\n</pre> </li> </ol> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Код программы</h3> <p>Вынесем в отдельный файл функцию</p> <p>Файл Series.cpp</p> <pre>\n#include "Series.h"\n\nint menu() {\n  std::cout &lt;&lt; "Введите 1 - Сумма ряда" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Введите 2 - Сумма ряда c погрешностью" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Введите 3 - Завершение программы" &lt;&lt; std::endl;\n\n  int choice{};\n  get_value<int>(choice, [](int temp) { return temp >= 1 && temp &lt;= 3; },\n  "Введите значение в диапазоне от 1 до 3\\n");\n\n\treturn choice;\n}\n//void get_value(int& choice, std::function&lt;bool(int)&gt;\n//condition, const std::string& message)\n//{\n//  std::cout &lt;&lt; message &lt;&lt; std::endl;\n//\n//  do {\n//    std::cin >> choice;\n//    if (!std::cin.fail() && condition(choice))\n//    {\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//      return;\n//    }\n//    else\n//    {\n//      std::cout &lt;&lt; message &lt;&lt; std::endl;\n//      std::cin.clear();\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//    }\n//  } while (true);\n//}\n//void get_value(double& x, std::function&lt;bool(double)&gt;\n//condition, const std::string& message)\n//{\n//  std::cout &lt;&lt; message &lt;&lt; std::endl;\n//\n//  do {\n//    std::cin >> x;\n//    if (!std::cin.fail() && condition(x))\n//    {\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//      return;\n//    }\n//    else\n//    {\n//      std::cout &lt;&lt; message &lt;&lt; std::endl;\n//      std::cin.clear();\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//    }\n//  } while (true);\n//}\n\ndouble sum_series(double x, int n)\n{\n  double Sn{};\n  double ai{ x };\n  for (int i = 1; i &lt; n; i++)\n  {\n    Sn += ai;\n    ai *= (-1) * (x * x) / (2 * i * (2 * i + 1));\n  }\n  return Sn;\n}\n\ndouble sum_series(double x, int& count, double eps)\n{\n  double Sn{};\n  double ai{ x };\n\n  for (count = 1; abs(ai) >= eps; count++)\n  {\n    Sn += ai;\n    ai *= (-1) * (x * x) / (2 * count * (2 * count + 1));\n  }\n  return Sn;\n}\n\nvoid print_answer(double Sn, const std::string& message, int n)\n{\n  std::cout&lt;&lt;std::setw(35) &lt;&lt; std::left &lt;&lt; message &lt;&lt; std::fixed\n  &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n  if (n > 0)\n  {\n    std::cout &lt;&lt; std::setw(35) &lt;&lt; std::left\n    &lt;&lt; "Количество элементов ряда" &lt;&lt; std::fixed &lt;&lt; n &lt;&lt; std::endl;\n  }\n}\n</int></pre> <p>Файл Series.h</p> <pre>\n#pragma once\n#include <iostream>\n#include <iomanip>\n#include <functional>\n\nint menu();\n//void get_value(int& choice, std::function<bool (int)> condition, const std::string& message);\n//void get_value(double& x, std::function<bool (double)> condition, const std::string& message);\n\ndouble sum_series(double x, int n);\ndouble sum_series(double x, int& count, double eps);\nvoid print_answer(double Sn, const std::string& message, int n = 0);\n\ntemplate&lt;typename T&gt;\nvoid get_value(T& x, std::function&lt;bool(T)&gt; condition, const std::string& message)\n{\n  std::cout &lt;&lt; message &lt;&lt; std::endl;\n\n  do {\n    std::cin >> x;\n    if (!std::cin.fail() && condition(x))\n    {\n      std::cin.ignore(std::cin.rdbuf()->in_avail());\n      return;\n    }\n    else\n    {\n      std::cout &lt;&lt; message &lt;&lt; std::endl;\n      std::cin.clear();\n      std::cin.ignore(std::cin.rdbuf()->in_avail());\n    }\n  } while (true);\n}\n</bool></bool></functional></iomanip></iostream></pre> <p>Основная программа примет вид</p> <p>Файл main.c</p> <pre>\n#include "Series.h"\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    choice = menu();\n\n    if (choice != 3)\n    {\n      double x{};\n      get_value<double>(x, [](double temp) {return abs(temp) &lt;= 1; }, "Введите x  от -1 до 1\\n");\n\n      if (choice == 1)\n      {\n        double Sn{};\n        int N{};\n        get_value<int>(N, [](int temp) {return temp > 0; }, "Введите количество элементов ряда N, где N > 0");\n\n        Sn = sum_series(x, N);\n        print_answer(Sn, "Приближенное значение", N);\n      }\n      else if (choice == 2)\n      {\n        int count{};\n        double eps = 1.0E-12;\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          Sn = sum_series(x, count, eps);\n          print_answer(Sn, "Приближенное значение", count);\n          print_answer(sin(x), "Точное значение");\n\n          eps /= 100;\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, любое другое значение - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n  } while (choice != 3);\n}\n</int></double></pre> </article> ','<article class="article"> <h1>Лекция 7 (11.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#array">Массив</a></p> <p><a href="#for">Перебор массива в цикле</a></p> <p><a href="#task1">Задача 1. Найдите сумму отрицательных элементов массива</a></p> <p><a href="#task2">Задача 2. Написать функцию вывода всех элементов массива</a></p> <p><a href="#array2">Двумерный массив</a></p> <p><a href="#for2">Перебор двумерного массива в цикле</a></p> <p><a href="#task3">Задача 3. Найдите сумму номеров минимального и максимального элементов</a></p> <p><a href="#task4">Задача 4. Дан массив. Вывести сначала элементы на четных местах, затем - на нечетных</a></p> <p><a href="#task5">Задача 5. Дан массив. Определить максимальный элемент массива и элемент, являющийся максимальным без учета этого элемента</a></p> <p><a href="#task6">Задача 6. В массиве из 30 элементов числа образуют неубывающую последовательность. Найти количество различных чисел в массиве</a></p> <p><a href="#task7">Задача 7. Найти элемент, наиболее близкий к среднему значению всех элементов массива</a></p> </article> <article class="article"> <div class="anchor" id="array"></div> <h3>Массив</h3> <p>Массив это ссылочный тип данных. Имя массива это указатель на область памяти, где хранится массив. К указателю можно применить операцию разименования. Под массив выделяется непрерывная область памяти размером, равным размеру типа данных умноженному на число элементов. Можно обратиться к любому элементу за O(1).</p> <h4>Объявление массива</h4> <p>При объявлении сначала пишут тип данных, которые будут храниться в массиве, название массива и его размер</p> <code>int mas[4];</code> <p>Размер записывают в отдельную переменную</p> <code>const int n = 4; int mas[n];</code> <h4>Инициализация массива</h4> <p>Можно сразу при объявлении инициализировать массив значениями по умолчанию</p> <code>int mas[n]{}; // {0,0,0,0}</code> <p>Можно инициализировать значениями</p> <code>int mas[n]{1,2,7,5};</code> <h4>Получение данных из массива</h4> <p>Можно получить значие любого элемента массива через [] квадратные скобки</p> <code>int k = mas[1]; // 2</code> <p>Можно получить значие первого элемента массива по ссылке, используя операцию разименования</p> <code>int k = *mas; // 1</code> <p>Можно получить значие люббого элемента массива по ссылке, используя операцию разименования. К указателю надо прибавить смещение, равное индексу элемента массива</p> <code>int k = *(mas + 1); // 2</code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  // тип_данных название_массива [размерность_массива]\n  const int n = 4;\n  int mas[n]{1,2,7,5};\n  int k1 = mas[0];\n  int k2 = mas[2];\n  int k3 = *mas;\n  int k4 = *(mas + 2);\n\n  std::cout &lt;&lt; "mas[0] " &lt;&lt; k1 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "mas[2] " &lt;&lt; k2 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "*mas " &lt;&lt; k3 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "*(mas + 2) " &lt;&lt; k4 &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <pre>\nmas[0] 1\nmas[2] 7\n*mas 1\n*(mas + 2) 7\n</pre> <h4>Размер массива</h4> <p>Размер массива в байтах</p> <code>int sizebyte = sizeof(mas);</code> <p>Чтобы узнать число элементов массива, нужно его размер в байтах поделить на размер одного элемента в байтах</p> <code>int size = sizeof(mas) / sizeof(mas[0]);</code> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 4;\n  int mas[n]{1,2,7,5};\n  int sizebyte = sizeof(mas);\n  int size = sizeof(mas) / sizeof(mas[0]);\n\n  std::cout &lt;&lt; "size byte " &lt;&lt; sizebyte &lt;&lt; std::endl;\n  std::cout &lt;&lt; "size " &lt;&lt; size &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <pre>\nsize byte 16\nsize 4\n</pre> </article> <article class="article"> <div class="anchor" id="for"></div> <h3>Перебор массива в цикле</h3> <p>Обращаемся к элементу по его индексу через [] квадратные скобки</p> <pre>\nfor (int i = 0; i &lt; n; i++)\n{\n  std::cout &lt;&lt; mas[i] &lt;&lt; " ";\n}\n</pre> <p>Обращаемся к элементу через операцию разименования. Прибавляем индекс к указателю на массив</p> <pre>\nfor (int i = 0; i &lt; n; i++)\n{\n  std::cout &lt;&lt; *(mas + i) &lt;&lt; " ";\n}\n</pre> <p>Второй способ перебрать массив</p> <pre>\nfor (int a : mas)\n{\n  std::cout &lt;&lt; a &lt;&lt; " ";\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Найдите сумму отрицательных элементов массива</h3> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 10;\n  int mas[n]{1,2,-7,5,-1,-2,7,5,-1,2};\n  int count{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (mas[i] &lt; 0)\n    {\n      count += mas[i];\n    }\n  }\n  std::cout &lt;&lt; count;\n}\n</pre> <p>Output</p> <code>-11</code> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Написать функцию вывода всех элементов массива</h3> <p>Напишем функцию вывода на печать элементов массива.</p> <h4>1 способ. Функция print() принимает массив и его размер.</h4> <pre>\n#include &lt;iostream&gt;\n\nvoid print(int[], const int);\n\nint main()\n{\n  const int n = 10;\n  int mas[n]{1,2,-7,5,-1,-2,7,5,-1,2};\n  int size = sizeof(mas) / sizeof(mas[0]);\n\n  print(mas, size);\n}\n\nvoid print(int nums[], int len)\n{\n  for (int i = 0; i &lt; len; i++)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n}\n\n  <p>Output</p>\n<code>1 2 -7 5 -1 -2 7 5 -1 2</code>\n</pre> <h4>2 способ. Функция print() принимает указатель на начало массива и на конец.</h4> <pre>\n#include &lt;iostream&gt;\n\nvoid print(int*, int*);\n\nint main()\n{\n  const int n = 10;\n  int mas[n]{1,2,-7,5,-1,-2,7,5,-1,2};\n\n  print(mas, mas + n);\n}\n\nvoid print(int *nums, int *end)\n{\n  for (int *ptr = nums; ptr &lt; end; ptr++)\n  {\n    std::cout &lt;&lt; *ptr &lt;&lt; " ";\n  }\n}\n</pre> <p>Output</p> <code>1 2 -7 5 -1 -2 7 5 -1 2</code> </article> <article class="article"> <div class="anchor" id="array2"></div> <h3>Двумерный массив</h3> <p>Объявим двумерный массив размером 2х2 и инициализируем его значениями по умолчанию</p> <code>int nums[2][2]{}; // {{0,0},{0,0}}</code> <p>Объявим двумерный массив размером 2х2 и инициализируем все его элементы значениями</p> <code>int nums[2][2]{1,2,3,4}; // {{1,2},{3,4}}</code> <p>Объявим двумерный массив размером 2х2 и инициализируем только два элемента, остальные получат значения по умолчанию</p> <code>int nums[2][2]{1,2}; // {{1,2},{0,0}}</code> <p>Объявим двумерный массив размером 3х3 и укажем какие элементы инициализировать значениями, остальные получат значения по умолчанию</p> <code>const int n = 3, m = 3;</code> <code>int nums[n][m]{{1,2},{},{7}}; // {{1,2,0},{0,0,0},{7,0,0}}</code> </article> <article class="article"> <div class="anchor" id="for2"></div> <h3>Перебор двумерного массива в цикле</h3> <p>Напечатаем двумерный массив 2х2</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 2, m = 2;\n  int nums[n][m]{1,2};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; " ";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> <p>Output</p> <pre>\n1 2\n0 0\n</pre> <p>Напечатаем двумерный массив 3х3</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3, m = 3;\n  int nums[n][m]{{1,2},{},{7}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; " ";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> <p>Output</p> <pre>\n1 2 0\n0 0 0\n7 0 0\n</pre> <p>Второй способ перебрать массив</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3, m = 3;\n  int nums[n][m]{{1,2},{},{7}};\n\n  for (auto &mas : nums)\n  {\n    for (int num : mas)\n    {\n      std::cout &lt;&lt; num &lt;&lt; " ";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n</pre> <p>Output</p> <pre>\n1 2 0\n0 0 0\n7 0 0\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Найдите сумму номеров минимального и максимального элементов</h3> <code>Input : {5,2,1,1,12,3}</code> <code>Output : 9 // 2 + 3 + 4</code> <p>Заведем переменные min и max для минимального и максимального элементов и присвоим им значение первого элемента массива</p> <p>Заведем переменные sum_min и sum_max для индексов минимального и максимального элементов и присвоим им ноль.</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 6;\n  int nums[n]{5,2,1,1,12,3};\n  int min{nums[0]}, max{nums[0]}, sum_min{}, sum_max{};\n\n  for (int i = 1; i &lt; n; i++)\n  {\n    if (nums[i] &lt; min)\n    {\n      min = nums[i];\n      sum_min = i;\n    }\n    else if (nums[i] == min)\n    {\n      sum_min += i;\n    }\n\n    if (nums[i] &gt; max)\n    {\n      max = nums[i];\n      sum_max = i;\n    }\n    else if (nums[i] == max)\n    {\n      sum_max += i;\n    }\n  }\n\n  std::cout &lt;&lt; "Sum min and max = "\n            &lt;&lt; sum_min + sum_max &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <code>Sum min and max = 9</code> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Дан массив. Вывести на экран сначала его элементы, стоящие на четных местах, затем - на нечетных</h3> <p>Два раза пройдем циклом по массиву. Сначала по четным элементам, потом по нечетным.</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 10;\n  int nums[n]{2,3,4,5,6,7,8,9,10,11};\n\n  for (int i = 0; i &lt; n; i += 2)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n  for (int i = 1; i &lt; n; i += 2)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n}\n</pre> <p>Output</p> <code>2 4 6 8 10 3 5 7 9 11</code> </article> <article class="article"> <div class="anchor" id="task5"></div> <h3>Задача 5. Дан массив. Определить максимальный элемент массива и элемент, являющийся максимальным без учета этого элемента</h3> <p>Заведем две переменные max1 и max2 для первого и второго максимума и присвоим им значение первого элемента массива.</p> <p>Циклом пройдем по массиву и обновим максимумы</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 10;\n  int nums[n]{2,3,4,5,6,7,8,9,10,11};\n  int max1{nums[0]}, max2{max1};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (max1 &lt; nums[i])\n    {\n      max2 = max1;\n      max1 = nums[i];\n    }\n    else if (max2 &lt; nums[i])\n    {\n      max2 = nums[i];\n    }\n  }\n\n  std::cout &lt;&lt; "max1 = " &lt;&lt; max1 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "max2 = " &lt;&lt; max2 &lt;&lt; std::endl;\n}\n</pre> <p>Output</p> <pre>\nmax1 = 11\nmax2 = 10\n</pre> </article> <article class="article"> <div class="anchor" id="task6"></div> <h3>Задача 6. В массиве из 30 элементов числа образуют неубывающую последовательность. Найти количество различных чисел в массиве</h3> </article> <article class="article"> <div class="anchor" id="task7"></div> <h3>Задача 7. Найти элемент, наиболее близкий к среднему значению всех элементов массива</h3> </article> ','<article class="article"> <h1>Лекция 8 (18.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#array">Одномерный массив</a></p> <p><a href="#array2">Двумерный массив</a></p> <p><a href="#task1">Задача 1. Сумма элементов на основной диагонали матрицы</a></p> <p><a href="#task2">Задача 2. Сумма элементов на побочной диагонали матрицы</a></p> <p><a href="#task3">Задача 3. Сумма элементов на диагоналях матрицы</a></p> <p><a href="#task4">Задача 4. Заполнить в матрице основную диагональ и выше</a></p> <p><a href="#task5">Задача 5. Заполнить в матрице основную диагональ и ниже</a></p> <p><a href="#task6">Задача 6. Заполнить в матрице побочную диагональ и выше</a></p> <p><a href="#task7">Задача 7. Заполнить в матрице побочную диагональ и ниже</a></p> <p><a href="#task8">Задача 8. Заполнить матрицу случайными числами</a></p> <p><a href="#task9">Задача 9. Сумма элементов над основной диагональю матрицы</a></p> <p><a href="#task10">Задача 10. Сумма элементов над побочной диагональю матрицы</a></p> <p><a href="#task11">Задача 11. Сумма элементов под основной диагональю матрицы</a></p> <p><a href="#task12">Задача 12. Сумма элементов под побочной диагональю матрицы</a></p> <p><a href="#task13">Задача 13. Не более двух отрицательных числа в строке</a></p> <p><a href="#task14">Задача 14. Поменять две строки местами в матрице</a></p> <p><a href="#task15">Задача 15. Напечатать массив сумм в строках двумерной матрицы</a></p> </article> <article class="article"> <div class="anchor" id="array"></div> <h3>Одномерный массив</h3> <h4>Создание одномерного массива</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 5;\n\n  // создание массива\n  int nums[n]{1,2,3,4,5};\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n}\n</pre> <p>Output</p> <code>1 2 3 4 5</code> <p>В переменной nums хранится указатель на ячейку памяти, с которой начинается одномерный массив из пяти элементов</p> <h4>Создание одномерного массива в динамической памяти</h4> <p>Ключевое слово <strong>new</strong> для выделения памяти</p> <p>Ключевое слово <strong>delete</strong> для очистки памяти</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3;\n\n  // создание массива\n  int* nums = new int[n]{1,2,3};\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; nums[i] &lt;&lt; " ";\n  }\n\n  // очистка памяти\n  delete[] nums;\n}\n</pre> <p>Output</p> <code>1 2 3</code> </article> <article class="article"> <div class="anchor" id="array2"></div> <h3>Двумерный массив</h3> <h4>Создание двумерного массива</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n\n  // создание массива\n  int **nums = new int*[m]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    nums[i] = new int[m]();\n  }\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] nums[i];\n  }\n  delete[] nums;\n}\n</pre> <p>Output</p> <pre>\n1       2       3       4\n2       3       4       5\n3       4       5       6\n</pre> <p>В переменной nums хранится указатель на ячейку памяти, с которой начинается двумерный массив из трех строк. В каждой строке (nums[0], nums[1], nums[2]) хранится указатель на ячейку памяти, с которой начинается очередной массив</p> <h4>Напишем функцию для создания массива</h4> <p>Функция InitMas() принимает размер двумерного массива. Функция InitMas() выделяет область памяти под массив заданного размера и возвращает указатель на ячейку памяти, с которой начинается двумерный массив</p> <pre>\n#include &lt;iostream&gt;\n\nint** InitMas(int, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n\n  // создание массива\n  int **nums = InitMas(n, m);\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] nums[i];\n  }\n  delete[] nums;\n}\n\nint** InitMas(int n, int m)\n{\n  int **mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n  return mas;\n}\n</pre> <h4>Напишем функцию для создания массива</h4> <p>Функция CreateMas() принимает указатель и размер двумерного массива. Функция CreateMas() выделяет область памяти под массив заданного размера, начиная с ячейки на которую указывает указатель. Функция CreateMas() ничего не возвращает</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] nums[i];\n  }\n  delete[] nums;\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n</pre> <h4>Напишем функцию для удаления массива</h4> <p>Функция DeleteMas() принимает указатель и количество строк двумерного массива.</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      nums[i][j] = 1 + i + j;\n    }\n  }\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <h4>Напишем функцию для заполнения массива</h4> <p>Функция FullMas() принимает указатель и размер двумерного массива.</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; nums[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <h4>Напишем функцию для печати массива</h4> <p>Функция PrintMas() принимает указатель и размер двумерного массива.</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 3; // количество строк\n  const int m = 4; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Сумма элементов на основной диагонали матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на основной диагонали матрицы</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 34 // 1 + 6 + 11 + 16</code> <h4>Решение</h4> <p>На основной диагонали для каждого элемента квадратной матрицы номер строки равен номеру столбца. Циклом проходим по строкам матрицы. Прибавляем к сумме элементы с одинаковым номером строки и столбца</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += nums[i][i];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Сумма элементов на побочной диагонали матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на побочной диагонали матрицы</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 22 // 4 + 7 + 10 + 1</code> <h4>Решение</h4> <p>На побочной диагонали для каждого элемента квадратной матрицы номер столбца равен размеру матрицы минус один минус номер строки. Циклом проходим по строкам матрицы. Прибавляем к сумме элементы у которых номер столбца равен размеру матрицы минус один минус номер строки</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += nums[i][n - 1 - i];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Сумма элементов на диагоналях матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на диагоналях матрицы</p> <h4>Пример 1</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 56 // 1 + 6 + 11 + 16 + 4 + 7 + 10 + 1</code> <h4>Пример 2</h4> <code>Input: nums{{1,2,3},{5,6,7},{9,10,11}}</code> <pre>\n1  2  3\n5  6  7\n9 10 11\n</pre> <code>Output 30 // 1 + 6 + 11 + 3 + 9</code> <h4>Решение</h4> <p>Для четной матрицы вычисляем сумму элементов на каждой диагонали и складываем. Для нечетной матрицы, чтобы не посчитать дважды элемент лежащий в центре на обоих диагоналях, на побочной диагонали не будем считать центральный элемент, для которого номер строки равен номеру столбца</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  // int n = 3;\n  // int nums[n][n]{{1,2,3},{5,6,7},{9,10,11}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += nums[i][i];\n    if (i != n - 1 - i)\n    {\n      sum += nums[i][n - 1 - i];\n    }\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Заполнить в матрице основную диагональ и выше</h3> <p>При заполнении матрицы вложенный цикл будем начинать не с нуля, а с номера строки</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = i; j &lt; m; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n1       2       3       4       5       6\n0       3       4       5       6       7\n0       0       5       6       7       8\n0       0       0       7       8       9\n0       0       0       0       9       10\n0       0       0       0       0       11\n</pre> </article> <article class="article"> <div class="anchor" id="task5"></div> <h3>Задача 5. Заполнить в матрице основную диагональ и ниже</h3> <p>При заполнении матрицы вложенный цикл будем начинать с нуля, а заканчивать до номера строки плюс один</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; i + 1; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n1       0       0       0       0       0\n2       3       0       0       0       0\n3       4       5       0       0       0\n4       5       6       7       0       0\n5       6       7       8       9       0\n6       7       8       9       10      11\n</pre> </article> <article class="article"> <div class="anchor" id="task6"></div> <h3>Задача 6. Заполнить в матрице побочную диагональ и выше</h3> <p>При заполнении матрицы вложенный цикл будем начинать с нуля, а заканчивать до размера матрицы минус номер строки</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n - i; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n1       2       3       4       5       6\n2       3       4       5       6       0\n3       4       5       6       0       0\n4       5       6       0       0       0\n5       6       0       0       0       0\n6       0       0       0       0       0\n</pre> </article> <article class="article"> <div class="anchor" id="task7"></div> <h3>Задача 7. Заполнить в матрице побочную диагональ и ниже</h3> <p>При заполнении матрицы вложенный цикл будем начинать с размера матрицы минус один минус номер строки</p> <pre>\n#include &lt;iostream&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = n - 1 - i; j &lt; n; j++)\n    {\n      mas[i][j] = 1 + i + j;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> <p>Output</p> <pre>\n0       0       0       0       0       6\n0       0       0       0       6       7\n0       0       0       6       7       8\n0       0       6       7       8       9\n0       6       7       8       9       10\n6       7       8       9       10      11\n</pre> </article> <article class="article"> <div class="anchor" id="task8"></div> <h3>Задача 8. Заполнить матрицу случайными числами</h3> <p>Заполним матрицу случайными числами от 0 до 9, используя выражение rand() % 10</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task9"></div> <h3>Задача 9. Сумма элементов над основной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на основной диагонали и выше</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 70 // 1+2+3+4+6+7+8+11+12+16</code> <h4>Решение</h4> <p>На основной диагонали для каждого элемента квадратной матрицы номер строки равен номеру столбца. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная с номера строки. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = i; j &lt; n; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> <code>Output 70</code> </article> <article class="article"> <div class="anchor" id="task10"></div> <h3>Задача 10. Сумма элементов над побочной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на побочной диагонали и выше</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 48 // 1+2+3+4+5+6+7+9+10+1</code> <h4>Решение</h4> <p>На побочной диагонали для каждого элемента квадратной матрицы номер столбца равен размер матрицы минус один минус номер строки. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная с нуля до побочной диагонали. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n - i; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task11"></div> <h3>Задача 11. Сумма элементов под основной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на основной диагонали и ниже</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 88 // 1+5+6+9+10+11+1+14+15+16</code> <h4>Решение</h4> <p>На основной диагонали для каждого элемента квадратной матрицы номер строки равен номеру столбца. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная с нуля до основной диагонали. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; i + 1; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task12"></div> <h3>Задача 12. Сумма элементов под побочной диагональю матрицы</h3> <p>Дана матрица. Подсчитать сумму элементов на побочной диагонали и ниже</p> <h4>Пример</h4> <code>Input: nums{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}}</code> <pre>\n1  2  3  4\n5  6  7  8\n9 10 11 12\n1 14 15 16\n</pre> <code>Output 98 // 4+7+8+10+11+12+1+14+15+16</code> <h4>Решение</h4> <p>На побочной диагонали для каждого элемента квадратной матрицы номер столбца равен размер матрицы минус один минус номер строки. Циклом проходим по строкам матрицы. Внутренним циклом проходим по столбцам начиная от побочной диагонали. Прибавляем элементы к сумме</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n = 4;\n  int sum{};\n  int nums[n][n]{{1,2,3,4},{5,6,7,8},{9,10,11,12},{1,14,15,16}};\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = n - 1 - i; j &lt; n; j++)\n    sum += nums[i][j];\n  }\n\n  std::cout &lt;&lt; sum;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task13"></div> <h3>Задача 13. Не более двух отрицательных числа в строке</h3> <p>Проверить, есть ли в двумерной матрице строки, не содержащие более двух отрицательных элементов</p> <p>Заполним матрицу случайными числами от -9 до 9, используя выражение rand() % 10 - rand() % 10</p> <p>Напишем вспомогательную функцию Count() которая принимает строку матрицы и возвращает количество отрицательных чисел в ней</p> <p>Напишем функцию lessThenThreeNeg() которая возвращает true если есть строки не содержащие более двух отрицательных чисел</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nint Count(int*, int);\nbool lessThenThreeNeg(int**, int, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // проверка строк\n  if (lessThenThreeNeg(nums, n, m))\n  {\n    std::cout &lt;&lt; "Matrix has less then three negative";\n  }\n  else\n  {\n    std::cout &lt;&lt; "Matrix has not less then three negative";\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10 - rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nint Count(int* str, int n)\n{\n  int count = 0;\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (str[i] &lt; 0)\n    {\n      count++;\n    }\n  }\n  return count;\n}\n\nbool lessThenThreeNeg(int **mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (Count(mas[i], n) &lt; 3)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task14"></div> <h3>Задача 14. Поменять две строки местами в матрице</h3> <p>Заполним матрицу случайными числами от 0 до 9, используя выражение rand() % 10</p> <p>Напишем вспомогательную функцию swap() которая принимает две строки матрицы и меняет их местами</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\nvoid Swap(int*&, int*&);\n\nint main()\n{\n  srand(time(0));\n  const int n = 3; // количество строк\n  const int m = 3; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // меняем строки местами\n  Swap(nums[0], nums[1]);\n  std::cout &lt;&lt; std::endl;\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nvoid Swap(int *&a, int *&b)\n{\n  int* temp = a;\n  a = b;\n  b = temp;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task15"></div> <h3>Задача 15. Напечатать массив сумм в строках двумерной матрицы</h3> <p>Заполним матрицу случайными числами от 0 до 9, используя выражение rand() % 10</p> <p>Напишем вспомогательную функцию Sum() которая принимает массив чисел и возвращает их сумму</p> <p>Напишем функцию sumMas() которая создает и возвращает массив сумм</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid DeleteMas(int**&, int);\nvoid Swap(int*&, int*&);\nint Sum(int*, int);\nint* sumMas(int**, int, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n\n  // создаем и печатаем массив сумм\n  int* s = sumMas(nums, n, m);\n  std::cout &lt;&lt; std::endl;\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; s[i] &lt;&lt; " ";\n  }\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nvoid Swap(int *&a, int *&b)\n{\n  int* temp = a;\n  a = b;\n  b = temp;\n}\n\nint Sum(int *row, int n)\n{\n  int sum = 0;\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += row[i];\n  }\n  return sum;\n}\n\nint* sumMas(int **mas, int n, int m)\n{\n  int *new_mas = new int[n];\n  for (int i = 0; i &lt; n; i++)\n  {\n    new_mas[i] = Sum(mas[i], m);\n  }\n  return new_mas;\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 9 (9.12.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#task1">Задача 1. Строки матрицы по невозрастанию сумм</a></p> <p><a href="#task2">Задача 2. Перемещение 0 в конец массива</a></p> <p><a href="#task3">Задача 3. Создадим квадратную матрицу и определим элементы выше, ниже и на главной диагонали</a></p> <p><a href="#task4">Задача 4. Упорядочить строки матрицы по условию</a></p> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1. Строки матрицы по невозрастанию сумм</h3> <p>Упорядочить строки в двумерной матрице по невозрастанию сумм</p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int, int);\nvoid FullMas(int**&, int, int);\nvoid PrintMas(int**&, int, int);\nvoid Print(int*&, int);\nvoid DeleteMas(int**&, int);\nvoid Swap(int*&, int*&);\nint SumRow(int*, int);\nint* sumMas(int**, int, int);\nvoid sortMas(int**&, int, int);\n\nint main()\n{\n  srand(time(0));\n  const int n = 6; // количество строк\n  const int m = 6; // количество столбцов\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n, m);\n\n  // заполнение массива\n  FullMas(nums, n, m);\n\n  // печать массива\n  PrintMas(nums, n, m);\n  std::cout &lt;&lt; std::endl;\n\n  // сортировка массива\n  sortMas(nums, n, m);\n\n  // печатаем массив\n  PrintMas(nums, n, m);\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n, int m)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[m]();\n  }\n}\n\nvoid FullMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n, int m)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; m; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid Print(int *&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; " ";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nvoid Swap(int *&a, int *&b)\n{\n  int* temp = a;\n  a = b;\n  b = temp;\n}\n\nint SumRow(int *row, int n)\n{\n  int sum = 0;\n  for (int i = 0; i &lt; n; i++)\n  {\n    sum += row[i];\n  }\n  return sum;\n}\n\nint* sumMas(int **mas, int n, int m)\n{\n  int *new_mas = new int[n];\n  for (int i = 0; i &lt; n; i++)\n  {\n    new_mas[i] = SumRow(mas[i], m);\n  }\n  return new_mas;\n}\n\nvoid sortMas(int **&mas, int n, int m)\n{\n  int* s = sumMas(mas, n, m);\n  Print(s, n);\n\n  for (int i = 1; i &lt; n; i++)\n  {\n    for (int j = i; j &gt; 0 && s[j-1] &gt; s[j]; j--)\n    {\n      std::swap(s[j-1], s[j]);\n      std::swap(mas[j-1], mas[j]);\n    }\n  }\n  Print(s, n);\n  std::cout &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2. Перемещение 0 в конец массива</h3> <p>Дан массив оценок учеников за экзамен от 0 до 5. Все оценки равные 0 должны быть перемещены в конец массива</p> <h4>Решение 1. Создаем новый массив с результатом</h4> <p>Сложность по памяти O(N)</p> <pre>\n#include &lt;iostream&gt;\n\nvoid Print(int*, int);\n\nint main()\n{\n  // ввод длины массива\n  int n{};\n  std::cout &lt;&lt; "Input array length ";\n  std::cin &gt;&gt; n;\n\n  // ввод элементов массива\n  int *nums = new int[n]();\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; "Input element " &lt;&lt; i &lt;&lt; " ";\n    std::cin &gt;&gt; nums[i];\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // печать массива\n  Print(nums, n);\n\n  // создание массива результата\n  int* result = new int[n]();\n  for (int i = 0, j = 0; i &lt; n; i++)\n  {\n    if (nums[i] != 0)\n    {\n      result[j] = nums[i];\n      j++;\n    }\n  }\n\n  // очистка памяти\n  delete[] nums;\n  nums = result;\n\n  // печать результата\n  Print(result, n);\n  Print(nums, n);\n\n  // очистка памяти\n  delete[] nums;\n  result = nullptr;\n  nums = nullptr;\n}\n\nvoid Print(int *mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; "\\t";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n</pre> <h4>Решение 2. Изменяем входной массив</h4> <p>Сложность по памяти O(1)</p> <pre>\n#include &lt;iostream&gt;\n\nvoid Print(int*, int);\nvoid Solution(int*, int);\n\nint main()\n{\n  // ввод длины массива\n  int n{};\n  std::cout &lt;&lt; "Input array length ";\n  std::cin &gt;&gt; n;\n\n  // ввод элементов массива\n  int *nums = new int[n]();\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; "Input element " &lt;&lt; i &lt;&lt; " ";\n    std::cin &gt;&gt; nums[i];\n    std::cout &lt;&lt; std::endl;\n  }\n\n  // печать массива\n  Print(nums, n);\n\n  // изменяем входной массив\n  Solution(nums, n);\n\n  // печать массива\n  Print(nums, n);\n\n  // очистка памяти\n  delete[] nums;\n  nums = nullptr;\n}\n\nvoid Print(int *mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; "\\t";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid Solution(int *mas, int n)\n{\n  int cntZero = 0;\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (mas[i] == 0)\n    {\n      cntZero++;\n    }\n    else\n    {\n      mas[i - cntZero] = mas[i];\n    }\n  }\n\n  for (int i = n - cntZero; i &lt; n; i++)\n  {\n    mas[i] = 0;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3. Создадим квадратную матрицу и определим элементы выше, ниже и на главной диагонали</h3> <h4>Алгоритм программы</h4> <ol> <li>Введем размер n квадратной матрицы nxn</li> <li>Заполним матрицу случайными числами</li> <li>Запишем 0 в элементы выше главной диагонали</li> <li>Запишем 1 в элементы ниже главной диагонали</li> <li>Запишем 2 в элементы на главной диагонали</li> </ol> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int);\nvoid FullMas(int**&, int);\nvoid PrintMas(int**&, int);\nvoid DeleteMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  // Введем размер n квадратной матрицы nxn\n  int n{};\n  std::cout &lt;&lt; "Input array dimention ";\n  std::cin &gt;&gt; n;\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n);\n\n  // заполнение массива\n  FullMas(nums, n);\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // Запишем 0 в элементы выше главной диагонали\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = i + 1; j &lt; n; j++)\n    {\n      nums[i][j] = 0;\n    }\n  }\n\n  // Запишем 1 в элементы ниже главной диагонали\n  for (int i = 1; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; i; j++)\n    {\n      nums[i][j] = 1;\n    }\n  }\n\n  // Запишем 2 в элементы на главной диагонали\n  for (int i = 0; i &lt; n; i++)\n  {\n    nums[i][i] = 2;\n  }\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[n]();\n  }\n}\n\nvoid FullMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4. Упорядочить строки матрицы по условию</h3> <p>Дана квадратная матрица. Если сумма элементов матрицы выше главной диагонали больше суммы элементов матрицы ниже главной диагонали, упорядочить строки матрицы в порядке неубывания сумм элементов, стоящих на нечетных позициях каждой строки</p> <h4>Алгоритм программы</h4> <ol> <li>Введем размер n квадратной матрицы nxn</li> <li>Заполним матрицу случайными числами</li> <li>Посчитаем сумму элементов выше главной диагонали</li> <li>Посчитаем сумму элементов ниже главной диагонали</li> <li>Если верхняя сумма больше нижней, то переходим к сортировке</li> <li>Подсчитаем суммы элементов, стоящих на нечетных позициях каждой строки</li> <li>Отсортируем массив в порядке неубывания этих сумм</li> </ol> <p><em>odd - нечетный</em></p> <p><em>even - четный</em></p> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nvoid CreateMas(int**&, int);\nvoid FullMas(int**&, int);\nvoid PrintMas(int**&, int);\nvoid Print(int*&, int);\nvoid DeleteMas(int**&, int);\nint Sum(int**, int, bool flag = true);\nint SumRowOdd(int*, int);\nint* sumMas(int**, int);\nvoid sortMas(int**&, int);\n\nint main()\n{\n  srand(time(0));\n  // Введем размер n квадратной матрицы nxn\n  int n{};\n  std::cout &lt;&lt; "Input array dimention ";\n  std::cin &gt;&gt; n;\n  int **nums;\n\n  // создание массива\n  CreateMas(nums, n);\n\n  // заполнение массива\n  FullMas(nums, n);\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // посчитаем сумму элементов\n  // над и под диагональю\n  int mas_up = Sum(nums, n);\n  int mas_down = Sum(nums, n, false);\n\n  std::cout &lt;&lt; mas_up &lt;&lt; std::endl;\n  std::cout &lt;&lt; mas_down &lt;&lt; std::endl;\n\n  // Если верхняя сумма больше нижней,\n  // то сортируем массив\n  if (mas_up &gt; mas_down)\n  {\n    sortMas(nums, n);\n  }\n  else\n  {\n    std::cout &lt;&lt; "without sort" &lt;&lt; std::endl;\n  }\n\n  // печать массива\n  PrintMas(nums, n);\n  std::cout &lt;&lt; std::endl;\n\n  // очистка памяти\n  DeleteMas(nums, n);\n}\n\nvoid CreateMas(int **&mas, int n)\n{\n  mas = new int*[n]{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    mas[i] = new int[n]();\n  }\n}\n\nvoid FullMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      mas[i][j] = rand() % 10;\n    }\n  }\n}\n\nvoid PrintMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    for (int j = 0; j &lt; n; j++)\n    {\n      std::cout &lt;&lt; mas[i][j] &lt;&lt; "\\t";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nvoid Print(int *&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    std::cout &lt;&lt; mas[i] &lt;&lt; " ";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n\nvoid DeleteMas(int **&mas, int n)\n{\n  for (int i = 0; i &lt; n; i++)\n  {\n    delete[] mas[i];\n  }\n  delete[] mas;\n}\n\nint Sum(int **mas, int n, bool flag)\n{\n  int sum{};\n  if (flag)\n  {\n    for (int i = 0; i &lt; n; i++)\n    {\n      for (int j = i + 1; j &lt; n; j++)\n      {\n        sum += mas[i][j];\n      }\n    }\n  }\n  else\n  {\n    for (int i = 1; i &lt; n; i++)\n    {\n      for (int j = 0; j &lt; i; j++)\n      {\n        sum += mas[i][j];\n      }\n    }\n  }\n  return sum;\n}\n\nint SumRowOdd(int *row, int n)\n{\n  int sum{};\n  for (int i = 0; i &lt; n; i++)\n  {\n    if (i % 2 == 1)\n    {\n      sum += row[i];\n    }\n  }\n  return sum;\n}\n\nint* sumMas(int **mas, int n)\n{\n  int *new_mas = new int[n];\n  for (int i = 0; i &lt; n; i++)\n  {\n    new_mas[i] = SumRowOdd(mas[i], n);\n  }\n  return new_mas;\n}\n\nvoid sortMas(int **&mas, int n)\n{\n  int* s = sumMas(mas, n);\n  Print(s, n);\n\n  for (int i = 1; i &lt; n; i++)\n  {\n    for (int j = i; j &gt; 0 && s[j-1] &gt; s[j]; j--)\n    {\n      std::swap(s[j-1], s[j]);\n      std::swap(mas[j-1], mas[j]);\n    }\n  }\n  Print(s, n);\n}\n</pre> </article> '];function g(){var n=document.querySelector(".lections"),t=document.querySelectorAll(".js-dsr-lecture");if(t){console.log(t);for(var i=function(i){t[i].addEventListener("click",(function(t){t.preventDefault(),y[i]&&(n.innerHTML=y[i],function(){var n=document.querySelector(".lections"),t=document.getElementById("link-to-dsr2024cpp");t&&t.addEventListener("click",(function(t){t.preventDefault(),n.innerHTML=b,g()}))}())}))},e=0;e<t.length;e++)i(e)}}var x,w,j=document.getElementById("maincomponent"),M=document.createElement("section");function _(n){return _="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},_(n)}function S(){S=function(){return n};var n={},t=Object.prototype,i=t.hasOwnProperty,e=Object.defineProperty||function(n,t,i){n[t]=i.value},l="function"==typeof Symbol?Symbol:{},s=l.iterator||"@@iterator",a=l.asyncIterator||"@@asyncIterator",r=l.toStringTag||"@@toStringTag";function o(n,t,i){return Object.defineProperty(n,t,{value:i,enumerable:!0,configurable:!0,writable:!0}),n[t]}try{o({},"")}catch(n){o=function(n,t,i){return n[t]=i}}function c(n,t,i,l){var s=t&&t.prototype instanceof p?t:p,a=Object.create(s.prototype),r=new P(l||[]);return e(a,"_invoke",{value:w(n,i,r)}),a}function d(n,t,i){try{return{type:"normal",arg:n.call(t,i)}}catch(n){return{type:"throw",arg:n}}}n.wrap=c;var u={};function p(){}function m(){}function h(){}var f={};o(f,s,(function(){return this}));var v=Object.getPrototypeOf,b=v&&v(v(O([])));b&&b!==t&&i.call(b,s)&&(f=b);var y=h.prototype=p.prototype=Object.create(f);function g(n){["next","throw","return"].forEach((function(t){o(n,t,(function(n){return this._invoke(t,n)}))}))}function x(n,t){function l(e,s,a,r){var o=d(n[e],n,s);if("throw"!==o.type){var c=o.arg,u=c.value;return u&&"object"==_(u)&&i.call(u,"__await")?t.resolve(u.__await).then((function(n){l("next",n,a,r)}),(function(n){l("throw",n,a,r)})):t.resolve(u).then((function(n){c.value=n,a(c)}),(function(n){return l("throw",n,a,r)}))}r(o.arg)}var s;e(this,"_invoke",{value:function(n,i){function e(){return new t((function(t,e){l(n,i,t,e)}))}return s=s?s.then(e,e):e()}})}function w(n,t,i){var e="suspendedStart";return function(l,s){if("executing"===e)throw new Error("Generator is already running");if("completed"===e){if("throw"===l)throw s;return{value:void 0,done:!0}}for(i.method=l,i.arg=s;;){var a=i.delegate;if(a){var r=j(a,i);if(r){if(r===u)continue;return r}}if("next"===i.method)i.sent=i._sent=i.arg;else if("throw"===i.method){if("suspendedStart"===e)throw e="completed",i.arg;i.dispatchException(i.arg)}else"return"===i.method&&i.abrupt("return",i.arg);e="executing";var o=d(n,t,i);if("normal"===o.type){if(e=i.done?"completed":"suspendedYield",o.arg===u)continue;return{value:o.arg,done:i.done}}"throw"===o.type&&(e="completed",i.method="throw",i.arg=o.arg)}}}function j(n,t){var i=t.method,e=n.iterator[i];if(void 0===e)return t.delegate=null,"throw"===i&&n.iterator.return&&(t.method="return",t.arg=void 0,j(n,t),"throw"===t.method)||"return"!==i&&(t.method="throw",t.arg=new TypeError("The iterator does not provide a '"+i+"' method")),u;var l=d(e,n.iterator,t.arg);if("throw"===l.type)return t.method="throw",t.arg=l.arg,t.delegate=null,u;var s=l.arg;return s?s.done?(t[n.resultName]=s.value,t.next=n.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,u):s:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,u)}function M(n){var t={tryLoc:n[0]};1 in n&&(t.catchLoc=n[1]),2 in n&&(t.finallyLoc=n[2],t.afterLoc=n[3]),this.tryEntries.push(t)}function k(n){var t=n.completion||{};t.type="normal",delete t.arg,n.completion=t}function P(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(M,this),this.reset(!0)}function O(n){if(n){var t=n[s];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var e=-1,l=function t(){for(;++e<n.length;)if(i.call(n,e))return t.value=n[e],t.done=!1,t;return t.value=void 0,t.done=!0,t};return l.next=l}}return{next:E}}function E(){return{value:void 0,done:!0}}return m.prototype=h,e(y,"constructor",{value:h,configurable:!0}),e(h,"constructor",{value:m,configurable:!0}),m.displayName=o(h,r,"GeneratorFunction"),n.isGeneratorFunction=function(n){var t="function"==typeof n&&n.constructor;return!!t&&(t===m||"GeneratorFunction"===(t.displayName||t.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,h):(n.__proto__=h,o(n,r,"GeneratorFunction")),n.prototype=Object.create(y),n},n.awrap=function(n){return{__await:n}},g(x.prototype),o(x.prototype,a,(function(){return this})),n.AsyncIterator=x,n.async=function(t,i,e,l,s){void 0===s&&(s=Promise);var a=new x(c(t,i,e,l),s);return n.isGeneratorFunction(i)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},g(y),o(y,r,"Generator"),o(y,s,(function(){return this})),o(y,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var t=Object(n),i=[];for(var e in t)i.push(e);return i.reverse(),function n(){for(;i.length;){var e=i.pop();if(e in t)return n.value=e,n.done=!1,n}return n.done=!0,n}},n.values=O,P.prototype={constructor:P,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var t in this)"t"===t.charAt(0)&&i.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var t=this;function e(i,e){return a.type="throw",a.arg=n,t.next=i,e&&(t.method="next",t.arg=void 0),!!e}for(var l=this.tryEntries.length-1;l>=0;--l){var s=this.tryEntries[l],a=s.completion;if("root"===s.tryLoc)return e("end");if(s.tryLoc<=this.prev){var r=i.call(s,"catchLoc"),o=i.call(s,"finallyLoc");if(r&&o){if(this.prev<s.catchLoc)return e(s.catchLoc,!0);if(this.prev<s.finallyLoc)return e(s.finallyLoc)}else if(r){if(this.prev<s.catchLoc)return e(s.catchLoc,!0)}else{if(!o)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return e(s.finallyLoc)}}}},abrupt:function(n,t){for(var e=this.tryEntries.length-1;e>=0;--e){var l=this.tryEntries[e];if(l.tryLoc<=this.prev&&i.call(l,"finallyLoc")&&this.prev<l.finallyLoc){var s=l;break}}s&&("break"===n||"continue"===n)&&s.tryLoc<=t&&t<=s.finallyLoc&&(s=null);var a=s?s.completion:{};return a.type=n,a.arg=t,s?(this.method="next",this.next=s.finallyLoc,u):this.complete(a)},complete:function(n,t){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&t&&(this.next=t),u},finish:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.finallyLoc===n)return this.complete(i.completion,i.afterLoc),k(i),u}},catch:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc===n){var e=i.completion;if("throw"===e.type){var l=e.arg;k(i)}return l}}throw new Error("illegal catch attempt")},delegateYield:function(n,t,i){return this.delegate={iterator:O(n),resultName:t,nextLoc:i},"next"===this.method&&(this.arg=void 0),u}},n}function k(n,t,i,e,l,s,a){try{var r=n[s](a),o=r.value}catch(n){return void i(n)}r.done?t(o):Promise.resolve(o).then(e,l)}function P(){var n;return n=S().mark((function n(t){return S().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:document.querySelector("#page").appendChild(t);case 2:case"end":return n.stop()}}),n)})),P=function(){var t=this,i=arguments;return new Promise((function(e,l){var s=n.apply(t,i);function a(n){k(s,e,l,a,r,"next",n)}function r(n){k(s,e,l,a,r,"throw",n)}a(void 0)}))},P.apply(this,arguments)}M.classList.add("lections"),j.append(M),(x=document.createElement("div")).classList.add("btn-up","none"),x.innerHTML="НАВЕРХ",x.addEventListener("click",(function(){window.scrollTo({top:0,left:0,behavior:"smooth"})})),window.addEventListener("scroll",(function(){return function(n){(window.scrollY||document.documentElement.scrollTop)>400?n.classList.remove("none"):n.classList.add("none")}(x)})),function(n){P.apply(this,arguments)}(x),w=document.querySelector(".lections"),console.log(w),document.querySelector(".lections").innerHTML=b,g()})()})();
//# sourceMappingURL=index.js.map