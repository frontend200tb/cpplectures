/*! For license information please see index.js.LICENSE.txt */
(()=>{"use strict";function t(n){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(n)}function n(n,e){for(var l=0;l<e.length;l++){var i=e[l];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,(void 0,r=function(n,e){if("object"!==t(n)||null===n)return n;var l=n[Symbol.toPrimitive];if(void 0!==l){var i=l.call(n,"string");if("object"!==t(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(i.key),"symbol"===t(r)?r:String(r)),i)}var r}function e(t){var n="function"==typeof Map?new Map:void 0;return e=function(t){if(null===t||(e=t,-1===Function.toString.call(e).indexOf("[native code]")))return t;var e;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(t))return n.get(t);n.set(t,i)}function i(){return l(t,arguments,a(this).constructor)}return i.prototype=Object.create(t.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),r(i,t)},e(t)}function l(t,n,e){return l=i()?Reflect.construct.bind():function(t,n,e){var l=[null];l.push.apply(l,n);var i=new(Function.bind.apply(t,l));return e&&r(i,e.prototype),i},l.apply(null,arguments)}function i(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function r(t,n){return r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,n){return t.__proto__=n,t},r(t,n)}function a(t){return a=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},a(t)}var o=function(e){!function(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(n&&n.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),n&&r(t,n)}(p,e);var l,o,c,s,d=(c=p,s=i(),function(){var n,e=a(c);if(s){var l=a(this).constructor;n=Reflect.construct(e,arguments,l)}else n=e.apply(this,arguments);return function(n,e){if(e&&("object"===t(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(n)}(this,n)});function p(){return function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,p),d.call(this)}return l=p,(o=[{key:"connectedCallback",value:function(){this.innerHTML='<div class="container"> <section id="maincomponent"></section> </div> '}}])&&n(l.prototype,o),Object.defineProperty(l,"prototype",{writable:!1}),p}(e(HTMLElement));customElements.define("main-component",o);const c='<h1>DSR (Doing Software Right)</h1> <article class="article"> <h2>C++: Начала программирования</h2> </article> <article class="article"> <p>Лекции проходят в главном корпусе ВГУ</p> <p>Аудитория 435, по понедельникам с 18.40 до 20.00</p> <p>Преподаватель - Коток Игорь Дмитриевич</p> <p>Факультет ПММ</p> </article> <article class="article"> <div class="anchor" id="konspekt"></div> <h2>Конспект лекций</h2> <p><a href="dsr2024cpp/lec-1.html" class="js-dsr-lecture">Лекция 1 (16.09.2024)</a></p> <p><a href="dsr2024cpp/lec-2.html" class="js-dsr-lecture">Лекция 2 (23.09.2024)</a></p> <p><a href="dsr2024cpp/lec-3.html" class="js-dsr-lecture">Лекция 3 (07.10.2024)</a></p> <p><a href="dsr2024cpp/lec-4.html" class="js-dsr-lecture">Лекция 4 (14.10.2024)</a></p> <p><a href="dsr2024cpp/lec-5.html" class="js-dsr-lecture">Лекция 5 (21.10.2024)</a></p> </article> ';var s=['<article class="article"> <h1>Лекция 1 (16.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#types">Типы данных</a></p> <p><a href="#base">Основы C++</a></p> <p><a href="#task1">Задача 1</a></p> <p><a href="#task2">Задача 2</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Знакомство</li> <li>Ход курса</li> <li>Типы данных</li> <li>Основы C++</li> </ol> <ol> <li>Теория</li> <li>Практика</li> <li>Домашка</li> </ol> </article> <article class="article"> <div class="anchor" id="types"></div> <h3>Типы данных</h3> <h4>Базовые типы</h4> <ol> <li>bool</li> <li>int</li> <li>float</li> <li>char</li> </ol> <h4>Числовые типы</h4> <ol> <li>short 2 байта</li> <li>int 2-4 байта</li> <li>long 4-8 байт</li> <li>long long 8 байт</li> <li>float 4 байта</li> <li>double 8 байт</li> <li>long double 8+ байт</li> </ol> <h4>Символьные типы</h4> <ol> <li>char 1 байт (ASCII)</li> <li>wchar_t 2-4 байта</li> <li>char8_t 1 байт</li> <li>char16_t 2 байта</li> <li>char32_t 4 байта</li> </ol> <p>Раньше строковые типы данных представлялись массивами типа char</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout &lt;&lt; "Hello, world!\\n";\n  return 0;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="base"></div> <h3>Основы C++</h3> <p>Необходимо установить Visual Studio Community</p> <p>Фигурные скобки {} нужно использовать везде где есть логические блоки</p> <h4>Объявление и инициализация переменных</h4> <pre>\nint main()\n{\n  int valInt;\n  int valInt2 = 5;\n  int valInt3(6);\n  int valInt4{12};\n}\n</pre> <p>Инициализация через {} безопасная, при неправильном значении проект даже не запустится</p> <h4>Операторы ввода и вывода</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int count;\n  std::cout &lt;&lt; "Введите количество кроликов" &lt;&lt; std::endl;\n  std::cin &gt;&gt; count;\n  std::cout &lt;&lt; "Количество кроликов " &lt;&lt; count;\n\n  return 0;\n}\n</pre> <h4>Подключение русской локализации</h4> <code>setlocale(LC_ALL, "Russian");</code> <h4>Количество байт, выделенные под переменные</h4> <code>sizeof(bool)</code> <code>sizeof(int)</code> <code>sizeof(double)</code> <p>Использование namespase std нежелательно</p> <code>namespace std;</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1</h3> <p>Треугольник задан на плоскости координатами своих вершин. Найти его периметр</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x1, x2, x3, y1, y2, y3, a, b, c, p;\n\n  std::cout &lt;&lt; "Введите первую вершину" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x1 &gt;&gt; y1;\n  std::cout &lt;&lt; "Введите вторую вершину" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x2 &gt;&gt; y2;\n  std::cout &lt;&lt; "Введите третью вершину" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x3 &gt;&gt; y3;\n\n  a = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n  b = sqrt((x2-x3)*(x2-x3) + (y2-y3)*(y2-y3));\n  c = sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3));\n  p = a+b+c;\n\n  std::cout &lt;&lt; "Периметр " &lt;&lt; p &lt;&lt; std::endl;\n  return 0;\n}\n</pre> <p>Возведение в квадрат</p> <code>a * a; // хорошо</code> <code>pow(a, 2); хуже, потому что выделяется лишняя память</code> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2</h3> <p>Найти сумму членов арифметической и геометрической прогрессии</p> <pre>\ndouble a1, d, Sa, na, b1, q, Sb, nb;\n\nSa = (2*a1+d*(na-1))/2*na;\nSb = b1*(1-pow(q,n,b))/(1-q);\n</pre> <code>system("pouse");</code> <code>std::cin.clear();</code> <code>std::cin.ignore(32767,n);</code> <code>std::cin.get</code> </article>','<article class="article"> <h1>Лекция 2 (23.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#conv">Преобразования типов</a></p> <p><a href="#oper">Операции</a></p> <p><a href="#task1">Задача 1</a></p> <p><a href="#task2">Задача 2</a></p> <p><a href="#task3">Задача 3</a></p> </article> <article class="article"> <div class="anchor" id="conv"></div> <h3>Преобразования типов</h3> <h4>Неявные преобразования типов</h4> <p>bool принимает другой тип</p> <code>bool flag_1 = 3; // true</code> <code>bool flag_2 = 2.5; // true</code> <code>bool flag_3 = 0; // false</code> <p>другой тип приниимает bool</p> <code>int var_int = true; // 1</code> <code>double var_double = false; // 0.00000</code> <p>целочисленное принимает вещественное</p> <code>int var_int_1 = 3.4; // 3</code> <code>int var_int_2 = 6.7; // 6</code> <p>вещественное принимает целочисленное</p> <code>float var_float = 324234222; // 324234208</code> <code>double var_double = 120000000000000011; // 1.2000000000000002e+17</code> <p>Если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается</p> <p>беззнаковые переменные принимают выходящие из диапазона</p> <code>unsigned char a = -5; // 251</code> <code>unsigned short b = -12; // 65524</code> <code>int c = -1; // 4294967295</code> <h4>Безопасные преобразования</h4> <p>bool - char - short - int - double - long double</p> <p>bool - char - short - int - long - long long</p> <p>unsigned char - unsigned short - unsigned int - unsigned long</p> <p>float - double - long double</p> <p>В арифметических операциях из двух типов выбирается максимальный и к нему приводится наименьший из них</p> <h4>Явные преобразования типов</h4> <h4>static_cast&lt;type&gt;(value)</h4> <p>Дальнобойщик проехал расстояние 130.21км со средней скоростью 8 км/ч. Сколько часов необходимо оплатить ему за проделанную поездку?</p> <pre>\ndouble distance{ 130.21 };\nunsigned int speed{ 8 };\nunsigned int hours{ static_cast<unsigned int>(distance / speed) } // hours = 16\n// unsigned int hours{ (unsigned int) (distance / speed) }; // hours = 16\nstd::cout &lt;&lt; "Затрачено часов = " &lt;&lt; hours &lt;&lt; std::endl;\n</unsigned></pre> </article> <article class="article"> <div class="anchor" id="oper"></div> <h3>Операции</h3> <h4>Базовые арифметические операции</h4> <p>Сложение a + b</p> <p>Вычитание a - b</p> <p>Умножение a * b</p> <p>Деление a / b</p> <p>Остаток от деления a % b</p> <h4>Операторы присваивания</h4> <p>a += b</p> <p>a -= b</p> <p>a *= b</p> <p>a /= b</p> <p>a %= b</p> <h4>Инкремент и декремент</h4> <p>префиксный инкремент ++a</p> <p>постфиксный инкремент a++</p> <p>префиксный декремент --a</p> <p>постфиксный декремент a--</p> <h4>Внимание подстава!</h4> <pre>\nint a{ 3 };\nint new_a{ --a };\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl; // a = 2\nstd::cout &lt;&lt; "new_a = " &lt;&lt; new_a &lt;&lt; std::endl; // new_a = 2\n</pre> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Приоритет операций</h4> <ol> <li>++, -- (инкремент, декремент)</li> <li>* (умножение), / (деление), % (остаток от деления)</li> <li>+ (сложение), - (вычитание)</li> </ol> <h4>Неоднозначный пример</h4> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Операции сравнения</h4> <p>a == b равно</p> <p>a &lt; b меньше</p> <p>a &lt;= b меньше или равно</p> <p>a &gt; b больше</p> <p>a &gt;= b больше или равно</p> <p>a != b не равно</p> <h4>Операции сравнения</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1{ a == b }; // false</code> <code>bool F2{ a &lt; b }; // true</code> <code>bool F3{ a &lt;= b }; // true</code> <code>bool F4{ a &gt; b }; // false</code> <code>bool F5{ a &gt;= b }; // false</code> <code>bool F6{ a != b }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> <h4>Логические операции</h4> <p>!a отрицание</p> <p>a && b И</p> <p>a || b ИЛИ</p> <p>a ^ b Исключающее ИЛИ</p> <h4>Логические операции</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1( a == b && b > 3 }; // false</code> <code>bool F2( a != b || a == 3 }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> <h4>Определение оператора</h4> <p>if</p> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\n</pre> <p>if - else</p> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a &lt;= b\\n";\n}\n</pre> <p>if - else if - else</p> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse if (a &lt; b)\n{\n  std::cout &lt;&lt; "a &lt; b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a == b\\n";\n}\n</pre> <h4>Тернарный оператор</h4> <code>a > b ? a++ : b++;</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1</h3> <p>Определить по введенным пользователем координатам попадания выстрела в мишень количество набранных очков</p> <p>3 очка если попали в круг радиусом 5 с центром в (0, 0)</p> <p>2 очка если попали в круг радиусом 10</p> <p>1 очко если попали в круг радиусом 15</p> <h4>Решение</h4> <h4>Инициализация и заполнение переменных</h4> <pre>\ndouble x{}, y{};\nint score{};\n\nstd::cout &lt;&lt; "Введите координаты выстрела\\n";\nstd::cin >> x >> y;\n</pre> <h4>Проверка на попадание</h4> <pre>\nif (x * x + y * y &lt;= 5)\n{\n  score = 3;\n}\nelse if (x * x + y * y &lt;= 10)\n{\n  score = 2;\n}\nelse if (x * x + y * y &lt;= 15)\n{\n  score = 1;\n}\n</pre> <h4>Вывод результатов работы</h4> <pre>\nif (score > 0)\n{\n  std::cout &lt;&lt; "Поздравляем! Вы выбили - " &lt;&lt; score &lt;&lt; "\\n";\n}\nelse{\n  std::cout &lt;&lt; "Вы промахнулись, нужно стараться лучше\\n";\n}\n</pre> <h4>Имеет ли право на жизнь?</h4> <pre>\nif (score)\n{\n  std::cout &lt;&lt; "Поздравляем! Вы выбили - " &lt;&lt; score &lt;&lt; "\\n";\n}\nelse{\n  std::cout &lt;&lt; "Вы промахнулись, нужно стараться лучше\\n";\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2</h3> <p>Составить программу для вычисления значения площади заштрихованной области, если точка с заданными координатами (x, y) попадает в эту область. В противном случае вывести соответствующее сообщение</p> <p>Большой круг радиусом 3 с центром в (0, 0). Малкенький круг с радиусом 1.5 с центром в (0, 1.5)</p> <h4>Решение</h4> <pre>\n#define _USE_MATH_DEFINES\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x{}, y{}, s{};\n\n  std::cout &lt;&lt; "Введите x и y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  if (x * x + y * y &lt;= 9 && x * x + (y + 1.5) * (y + 1.5) >= 2.25)\n  {\n    std::cout &lt;&lt; "Площадь равна " &lt;&lt; M_PI * 9 - M_PI * 2.25;\n  }\n  else\n  {\n    std::cout &lt;&lt; "Вы не попали в область" &lt;&lt; std::endl;\n  }\n}\n</pre> <h4>Определение switch case</h4> <pre>\nswitch (/*выражение*/)\n{\n  case // значение1: инструкции1; break;\n  case // значение2: инструкции2; break;\n  default: // инструкции;\n}\n</pre> <h4>Пример реализации</h4> <pre>\nint counter{ 2 };\n\nswitch (counter)\n{\n  case 1:\n    std::cout &lt;&lt; "counter = 1" &lt;&lt; std::endl;\n    break;\n  case 2:\n    std::cout &lt;&lt; "counter = 2" &lt;&lt; std::endl;\n    break;\n  case 3:\n    std::cout &lt;&lt; "counter = 3" &lt;&lt; std::endl;\n    break;\n  default:\n    std::cout &lt;&lt; "counter is undefined" &lt;&lt; std::endl;\n    break;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3</h3> <p>Требуется написать программу, которая принимает с клавиатуры координаты точки на плоскости (x, y - вещественные числа) и определяет принадлежность точки заштрихованной области, включая ее границы</p> <p>Область на плоскости лежит между графиками двух функций. Ниже y = 2 - x*x. Выше y = x</p> <p>Пояснение</p> <p>Нужно отдельно проверить через switch попадание в области C и G. Пользователю выводится меню, где указано "Чтобы проверить точку G введите 1" и т.д. switch обрабатывает запрос пользователя и выдает результат проверки на попадание в запрашиваемую область</p> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x{}, y{}, s{};\n\n  std::cout &lt;&lt; "Введите x и y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  std::cout &lt;&lt; "Чтобы проверить всю область, нажмите 1" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Чтобы проверить область C, нажмите 2" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Чтобы проверить область G, нажмите 3" &lt;&lt; std::endl;\n\n  int command{};\n\n  std::cout &lt;&lt; "Введите команду" &lt;&lt; std::endl;\n  std::cin >> command;\n\n  switch (command)\n  {\n    case 1:\n      if (x&lt;=0 && y>=x && y &lt;= 2-x*x || x>0 && y&lt;=2-x*x && y>=0)\n      {\n        std::cout &lt;&lt; "Вы попали в закрашенную область\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Вы не попали в закрашенную область\\n";\n      }\n      break;\n    case 2:\n      if (y&lt;=x && y&lt;=2-x*x && x>0 && y>=0)\n      {\n        std::cout &lt;&lt; "Вы попали в область C\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Вы не попали в область C\\n";\n      }\n      break;\n    case 3:\n      if (y&lt;=x && y>=2-x*x && y&lt;=0)\n      {\n        std::cout &lt;&lt; "Вы попали в область G\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Вы не попали в область G\\n";\n      }\n      break;\n    default:\n      std::cout &lt;&lt; "Вы ввели неправильную команду\\n";\n  }\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 3 (07.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#loop">Циклы</a></p> <p><a href="#task1">Задача 1</a></p> <p><a href="#bad">Обработка "плохих" данных</a></p> <p><a href="#task2">Задача 2</a></p> <p><a href="#task3">Задача 3</a></p> <p><a href="#task4">Задача 4</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>while</li> <li>for</li> <li>do while</li> <li>foreach</li> <li>Обработка "плохих" данных</li> </ol> </article> <article class="article"> <div class="anchor" id="loop"></div> <h3>Циклы</h3> <h4>Определение цикла while</h4> <pre>\nwhile (/*выражение*/)\n{\n  //тело_цикла\n}\n</pre> <p>Найти сумму чисел от 1 до 100</p> <pre>\nint i = 0;\nint sum = 0;\n\nwhile (i &lt; 100)\n{\n  i++;\n  sum += i;\n}\n\nstd::cout &lt;&lt; "Сумма чисел от 1 до 100 = " &lt;&lt; sum &lt;&lt; std::endl;\n</pre> <h4>Определение вложенных циклов</h4> <pre>\nwhile (/*выражение1*/)\n{\n  //тело_цикла1\n  while (/*выражение2*/)\n  {\n    //тело_цикла2\n  }\n}\n</pre> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы while</p> <pre>\nint a{}, b{};\n\nwhile (a &lt; 10)\n{\n  a++;\n  while (b &lt; 10)\n  {\n    b++;\n    std::cout &lt;&lt; a &lt;&lt; "\\tx\\t" &lt;&lt; b &lt;&lt; "\\t=\\t" &lt;&lt; a * b &lt;&lt; std::endl;\n  }\n  std::cout &lt;&lt; std::endl;\n  b = 0;\n}\n</pre> <h4>Бесконечные циклы</h4> <pre>\nwhile (true)\n{\n  // этот цикл будет выполняться бесконечно\n}\n</pre> <pre>\nint count = 12;\n\nwhile (count &lt; 20) // всегда будет true\n{\n  std::cout &lt;&lt; count &lt;&lt; " "; // эта строка будет выполняться бесконечно\n}\nreturn 0; // эта строка никогда не выполнится\n</pre> <p>Единственный способ выйти из бесконечного цикла - использовать операторы return, break, goto, выбросить исключение или воспользоваться функцией exit()</p> <h4>continue</h4> <p>Нужно вывести все четные числа от 0 до 30</p> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 == 0)\n  {\n    std::cout &lt;&lt; i &lt;&lt; " ";\n  }\n}\n</pre> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 != 0)\n  {\n    continue;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <h4>break</h4> <pre>\nwhile (i != 0)\n{\n  i--;\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nwhile (1)\n{\n  i--;\n  if (i == 0)\n  {\n    break;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nint count = 1;\nwhile (count &lt;= 50)\n{\n  if (count &lt; 10)\n  {\n    std::cout &lt;&lt; "0" &lt;&lt; count &lt;&lt; " ";\n  }\n  else\n  {\n    std::cout &lt;&lt; count &lt;&lt; " "\n  }\n  if (count % 10 == 0)\n  {\n    std::cout &lt;&lt; "\\n";\n  }\n  ++count;\n}\n</pre> <h4>Определение цикла for</h4> <p>Вывести квадраты четных чисел от 0 до 20</p> <pre>\nint length{20};\n\nfor (int i = 0; i &lt; length; i++)\n{\n  if (i % 2 == 0)\n  {\n    std::cout &lt;&lt; i * i &lt;&lt; " ";\n  }\n}\n</pre> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы for</p> <pre>\nfor (int i{1}; i &lt; 10; i++)\n{\n  for (int j{1}; j &lt; 10; j++)\n  {\n    std::cout &lt;&lt; i &lt;&lt; "\\t x \\t" &lt;&lt; j &lt;&lt; "\\t = \\t" &lt;&lt; i * j &lt;&lt; std::endl;\n  }\n  std::cout &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1</h3> <p>Напишите программу, где пользователь вводит любое целое положительное число. А программа суммирует все числа от 1 до введенного пользователем числа.</p> <pre>\nunsigned int temp{};\nint sum{};\nstd::cin >> temp;\n\nfor (int j{1}; j &lt; temp; j++)\n{\n  sum += j;\n}\n</pre> <h4>ctime, srand, rand</h4> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nint main()\n{\n  srand(time(0));\n  int balance = 8;\n\n  do\n  {\n    std::cout &lt;&lt; "balance = " &lt;&lt; balance &lt;&lt; std::endl;\n    int removal = rand() % 3;\n    std::cout &lt;&lt; "removal = " &lt;&lt; removal &lt;&lt; std::endl;\n    balance -= removal;\n  } while (balance > 0);\n\n  return 0;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="bad"></div> <h3>Обработка "плохих" данных</h3> <h4>Оператор извлечения</h4> <p>Если во входном буфере есть данные, то эти данные используются для извлечения.</p> <p>Если во входном буфере нет данных, то пользователю предлагается ввести данные (обычно именно это и происходит в большинстве случаев). Когда пользователь нажимает Enter, символ новой строки \\n помещается во входной буфер</p> <h4>Оператор извлечения &gt;&gt;</h4> <p>Оператор &gt;&gt; извлекает столько данных из входного буфера в переменную, сколько позволяет размер самой переменной (игнорируя любые пробелы, табы и \\n)</p> <p>Любые данные, которые не были извлечены остаются во входном буфере для последующего извлечения</p> <pre>\nint a;\nstd::cin &gt;&gt; a;\n</pre> <p>Пользователь вводит 21Z. 21 записывается в переменную a, при этом в буфере остается Z\\n</p> <h4>Ошибка 1: Извлечение выполняется успешно, но данные бесполезны</h4> <pre>\nwhile (true) // пока пользователь не введет корректные данные\n{\n  std::cout &lt;&lt; "Enter \'+\', \'-\', \'*\', \'/\' :";\n  char sm;\n  std::cin &gt;&gt; sm;\n\n  // вывполняем проверку значений\n  if (sm == \'+\'\' || sm ==\'-\' || sm == \'*\' || sm == \'/\') {\n    return sm; // возвращаем данные в функцию main()\n  } else { // иначе, сообщаем что что-то пошло не так\n    std::cout &lt;&lt; "Invalid input. Try again.\\n";\n  }\n}\n</pre> <h4>Ошибка 2: Извлечение выполняется успешно, но пользователь вводит лишний текст</h4> <pre>\nstd::cout &lt;&lt; "Enter a double value: ";\ndouble a;\nstd::cin &gt;&gt; a;\nstd::cin.ignore(32767, \'\\n\'); // удаляем до 32767 символов\n// из входного буфера вплоть до появления символа \'\\n\'\n\nstd::cin.ignore(std::cin.rdbuf()->in_avail());\n// зачищаем только то, что использовано\n</pre> <h4>Ошибка 3: Извлечение не выполняется</h4> <pre>\nwhile (true) // пока пользователь не введет корректное значение1\n{\n  std::cout &lt;&lt; "Enter a double value: ";\n  double a;\n  std::cin &gt;&gt; a;\n\n  if (std::cin.fail()) // если предыдущее значение оказалось неудачным\n  {\n    std::cin.clear(); // возвращаем cin в обычный режим работы\n    std::cin.ignore(32767, \'\\n\'); // удаляем значения предыдущего ввода из входного буфера\n  }\n  else // если все хорошо, выходим используя break\n  {\n    std::cin.ignore(32767, \'\\n\');\n    break;\n  }\n}\n</pre> <h4>Ошибка 4: Извлечение выполняется успешно, но пользователь ввел слишком большое числовое значение</h4> <pre>\nstd::int16_t x{ 0 };\n// переменная x занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number x between -32768 and 32767: ";\nstd::cin &gt;&gt; x;\n\nstd::int16_t y{ 0 };\n// переменная y занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number y between -32768 and 32767: ";\nstd::cin &gt;&gt; y;\n\nstd::cout &lt;&lt; "The sum is: " &lt;&lt; x + y &lt;&lt; \'\\n\';\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>1 + 1/3 + 1/(3<sup>2</sup>) + ... + 1/(3<sup>8</sup>)</code> <h4>Решение</h4> <pre>\ndouble sum {1};\ndouble denominator {1};\n\nfor (int i = 0; i &lt; 8; i++)\n{\n  denominator *= 3;\n  sum += 1 / denominator;\n}\n\nstd::cout &lt;&lt; sum;\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>x + x<sup>3</sup>/3 + x<sup>5</sup>/5 + ... + x<sup>11</sup>/11</code> <h4>Решение</h4> <pre>\ndouble sum {};\nint n {5};\ndouble x {2.0};\ndouble temp = x;\n\nfor (int i = 0; i &lt; n; i++)\n{\n  sum += temp;\n  temp = temp * (2 * i - 1) * x * x / (2 * i + 1);\n}\n\nstd::cout &lt;&lt; sum;\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>e<sup>x</sup> = 1 + x + x<sup>2</sup>/2! + x<sup>3</sup>/3! + x<sup>4</sup>/4! + ...</code> <code>cos x = 1 - x<sup>2</sup>/2! + x<sup>4</sup>/4! + x<sup>6</sup>/6! + ...</code> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! + x<sup>7</sup>/7! + ...</code> </article> ','<article class="article"> <h1>Лекция 4 (14.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#ref">Ссылки</a></p> <p><a href="#point">Указатель</a></p> <p><a href="#t1">Практика. Sum(int, int)</a></p> <p><a href="#t2">Практика. Max(int, int)</a></p> <p><a href="#t3">Практика. Swap(int&, int&)</a></p> <p><a href="#t4">Практика. Print()</a></p> <p><a href="#t5">Практика. Swap(int*, int*)</a></p> <p><a href="#t6">Практика. Sum(int, int, int = 3)</a></p> <p><a href="#t7">Практика. init(int*)</a></p> <p><a href="#t8">Практика. init(int*&)</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Ссылки и указатели</li> <li>Функции</li> <li>Массивы</li> </ol> </article> <article class="article"> <div class="anchor" id="ref"></div> <h3>Ссылки</h3> <p>тип_данных & название_ссылки = переменная_типа_ссылки;</p> <pre>\nint main()\n{\n  int a = 3;\n  int &refa = a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 3\n\n  refa++;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 4\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 4\n}\n</pre> </article> <article class="article"> <div class="anchor" id="point"></div> <h3>Указатель</h3> <p>тип_данных * название_указателя;</p> <pre>\nint main()\n{\n  int a = 3;\n  int *pointA = &a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl;\n\n  std::cout&lt;&lt;&a&lt;&lt;std::endl; // 000000C2E6DAFBF4\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl; //\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;*pointA&lt;&lt;std::endl; // 3\n}\n</pre> <h4>Указатель</h4> <p>Количество выделяемой памяти не изменяется в зависимости от типа переменных на которую ссылается указатель.</p> <pre>\nint *pint{};\ndouble *pdouble{};\n\nstd::cout&lt;&lt;sizeof(pint)&lt;&lt;std::endl; // 8\nstd::cout&lt;&lt;sizeof(pdouble)&lt;&lt;std::endl; // 8\n</pre> <h4>Указатель</h4> <pre>\nint a {10};\nint b {2};\n\nint *pa {&a};\nint *pb {&b};\n\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\nstd::cout&lt;&lt;"pb: address="&lt;&lt;pb&lt;&lt;"\\t value="&lt;&lt;*pb&lt;&lt;std::endl;\n\npa = pb;\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\n*pa = 125;\nstd::cout&lt;&lt;"b value="&lt;&lt;b&lt;&lt;std::endl;\n</pre> <code>pa: address=00000072CAFEFA54 value=10</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>b value=125</code> <h4>Указатель</h4> <pre>\nint a {10};\nint b {6};\n\nint *p{};\nint *&pRef {p};\n\npRef = &a;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n\n*pRef = 70;\nstd::cout&lt;&lt;"a value="&lt;&lt;a&lt;&lt;std::endl;\n\npRef = &b;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n</pre> <code>p value=10</code> <code>a value=70</code> <code>p value=6</code> <h4>Операторы new и delete</h4> <pre>\nint *ptr = new int;\nint *ptr_1 = new int();\nint *ptr_2 {new int(12)};\n\nstd::cout &lt;&lt; *ptr &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_2 &lt;&lt; std::endl;\n\ndelete ptr;\ndelete ptr_1;\ndelete ptr_2;\n\nptr = nullptr;\nptr_1 = nullptr;\nptr_2 = nullptr;\n</pre> <code>-842150451</code> <code>0</code> <code>12</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Sum(int, int)</h3> <p>Найдем сумму двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = a + b;\n}\n</pre> <p>Разделим программу на несколько файлов</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b) = " &lt;&lt; sum &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Практика. Max(int, int)</h3> <p>Добавим в проект функцию Max, возвращающую максимум из двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Max(a,b) = " &lt;&lt; max &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t3"></div> <h3>Практика. Swap(int&, int&)</h3> <p>Добавим в проект функцию Swap, которая ничего не возвращает, принимает адреса двух переменных и меняет местами их значения</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(&a, &b);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t4"></div> <h3>Практика. Print()</h3> <p>Добавим вывод на экран слова Bob. Добавим функцию Print, которая выводит на экран число, сколько раз функция Print вызывалась</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> <p>Статическая переменная i, объявленная внутри функции Print() инициализируется только один раз - при первом вызове функции. Она получает значение i = 0. При повторных вызовах, инициализация не производится.</p> </article> <article class="article"> <div class="anchor" id="t5"></div> <h3>Практика. Swap(int*, int*)</h3> <p>Перепишем функцию Swap(), при которой она будет принимать не адреса, а указатели на две переменные.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  int *pa = &a;\n  int *pb = &b;\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(pa, pb);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t6"></div> <h3>Практика. Sum(int, int, int = 3)</h3> <p>Перепишем функцию Sum(), при которой она будет принимать не два, а три параметра. Причем третий параметр будет необязательным и в случае его отсутствия будет подставляться значение по умолчанию.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "default c = " &lt;&lt; 3 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,c) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  sum = Sum(a, b, 25);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,25) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int, int = 3);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y, int z)\n{\n  return x + y + z;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t7"></div> <h3>Практика. init(int*)</h3> <p>Напишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t8"></div> <h3>Практика. init(int*&)</h3> <p>Перепишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(&a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article>','<article class="article"> <h1>Лекция 5 (21.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#func">Перегрузка функции</a></p> <p><a href="#const1">Константы</a></p> <p><a href="#const2">Указатели на константы</a></p> <p><a href="#const3">Константный указатель</a></p> <p><a href="#const4">Константный указатель на константу</a></p> <p><a href="#const5">Константные параметры</a></p> <p><a href="#const6">Константные ссылочные параметры</a></p> <p><a href="#const7">Вопросы по перегрузке</a></p> <p><a href="#t1">Практика. Сумма ряда</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Ссылки и указатели</li> <li>Функции</li> <li>Массивы</li> </ol> </article> <article class="article"> <div class="anchor" id="func"></div> <h3>Перегрузка функции</h3> <p>Напишем функцию sum(), которая складывает два целых числа и функцию sum(), которая скаладывает два вещественных числа</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n</pre> <code>9</code> <code>4.1</code> <p>Добавим еще одну функцию sum(), которая складывает три целых числа, причем третий параметр не обязательный, при его отсутствии будет подставляться значение по умолчанию.</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\nint sum(int, int, int = 2);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n\nint sum(int a, int b, int c)\n{\n  return a + b + c;\n}\n</pre> <p>Компилятор не знает какую функцию запустить</p> </article> <article class="article"> <div class="anchor" id="const1"></div> <h3>Константы</h3> <p>const тип_данных & имя_переменной = значение_переменной</p> <p>Объявим константу с инициализацией, а потом попробуем присвоить ей новое значение</p> <pre>\nconst int a = 3;\na = 10; // нельзя\n</pre> <p>Компилятор не будет компилировать, потому что константе нельзя присвоить новое значение</p> <p>Объявим константу без инициализации, а потом попробуем ее инициализировать</p> <pre>\nconst int age; // нельзя\nage = 6;\n</pre> <p>Компилятор не будет компилировать, потому что константу нужно инициализировать только при объявлении.</p> </article> <article class="article"> <div class="anchor" id="const2"></div> <h3>Указатели на константы</h3> <p>const тип_данных * имя_указателя = адресс_переменной</p> <pre>\nconst int a {10};\nconst int *pa {&a};\n\nstd::cout &lt;&lt; "address = " &lt;&lt; pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 4; // нельзя\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nconst int b {45};\npa = &b; // можно\n\nstd::cout &lt;&lt; "*pa = " &lt;&lt; *pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\na = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n</pre> </article> <article class="article"> <div class="anchor" id="const3"></div> <h3>Константный указатель</h3> <p>тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nint *const pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\nint b {45};\npa = &b; // нельзя\n</pre> </article> <article class="article"> <div class="anchor" id="const4"></div> <h3>Константный указатель на константу</h3> <p>const тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nconst int *const pa {&a};\nint b {45};\n</pre> </article> <article class="article"> <div class="anchor" id="const5"></div> <h3>Константные параметры</h3> <pre>\nvoid square(int);\n//void square(const int);\n\nint main()\n{\n  int number {12};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int a)\n{\n  std::cout &lt;&lt; "a * a = " &lt;&lt; a * a &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 144</code> </article> <article class="article"> <div class="anchor" id="const6"></div> <h3>Константные ссылочные параметры</h3> <pre>\nvoid square(const int&);\n\nint main()\n{\n  const int number {6};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int &n)\n{\n  std::cout &lt;&lt; "n * n = " &lt;&lt; n * n &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 36</code> </article> <article class="article"> <div class="anchor" id="const7"></div> <h3>Вопросы по перегрузке</h3> <pre>\nvoid show(int);\nvoid show(int&);\n\nvoid print(int);\nvoid print(const int);\n\nint square(int*);\nint square(const int*);\n\nint square(int* num)\n{\n  return *num * *num;\n}\n\nint square(const int* num)\n{\n  return *num * *num;\n}\n</pre> <p>Компилятор не различает в данном случае & и const от простой реализации</p> <pre>\nconst int n1{2};\nint n2{3};\n\nint square_n1 {square(&n1)};\nint square_n2 {square(&n2)};\n\nstd::cout &lt;&lt; "square(n1) = " &lt;&lt; square_n1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; "square(n2) = " &lt;&lt; square_n2 &lt;&lt; std::endl;\n</pre> <code>4</code> <code>9</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Сумма ряда</h3> <p>Вычислить суммму ряда</p> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ...</code> <p>Для начала попробуем упростить выражение</p> <code>S<sub>n</sub> = sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ... + (-1)<sup>n</sup> * (x<sup>2n+1</sup>)/(2n+1)!</code> <code>q = a<sub>n</sub>/a<sub>n-1</sub></code> <code>q = (-1)<sup>n</sup> * x<sup>2n+1</sup>/(2n+1)! * (2n-1)!/(x<sup>2n-1</sup> * (-1)<sup>n-1</sup>)</code> <code>q = (-1)<sup>n-n+1</sup> * x<sup>2n+1-2n+1</sup> * (2n-1)!/(2n+1)!</code> <p>Так как</p> <code>n! = 1*2*3*...*n</code> <code>(n-1)! = 1*2*3*...*(n-1)</code> <p>То</p> <code>n! = (n-1)!*n</code> <p>Тогда</p> <code>(2n+1)! = (2n-1)! * 2n * (2n+1)</code> <p>Подставим это вместо (2n+1)!</p> <code>q = (-1) * x<sup>2</sup> * (2n-1)! / ((2n-1)! * 2n * (2n+1))</code> <code>q = (-1) * x<sup>2</sup> / (2n * (2n+1))</code> <h4>1 часть</h4> <p>Так как при i=0 множитель даст деление на 0, начинаем с 1, а самое первое значение заносим заранее в ai</p> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; i &lt; n; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <h4>2 часть</h4> <p>Посчитаем с погрешностью. Пусть погрешность будет очень маленькая величина</p> <code>eps = 1.0e-10;</code> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; abs(ai)>eps; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <p>С каждым шагом ai стремится к нашей точности eps, уменьшается. Чем выше точность eps (чем оно меньше), тем ближе к значению S<sub>точ</sub>. Таким образом мы считаем S<sub>n</sub>до тех пор, пока абсолютное значение ai не станет меньше eps</p> <h4>Код программы</h4> <pre>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    std::cout &lt;&lt; "Введите 1- Сумма ряда" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 2- Сумма ряда c погрешностью" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 3- Завершение программы" &lt;&lt; std::endl;\n\n    bool isError{ true };\n    do {\n\n      std::cin >> choice;\n      if (!std::cin.fail()&& choice&lt;=3 && choice>=1)\n      {\n        isError = false;\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n      else\n      {\n        std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n        std::cin.clear();\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n\n    } while (isError);\n\n    if (choice != 3)\n    {\n      double x{};\n      isError = true;\n      do {\n\n        std::cout &lt;&lt; "Введите x " &lt;&lt; std::endl;\n        std::cin >> x;\n        if (!std::cin.fail())\n        {\n          isError = false;\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n        else\n        {\n          std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n          std::cin.clear();\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n\n      } while (isError);\n\n      if (choice == 1)\n      {\n\n        double Sn{};\n        int N{};\n        std::cout &lt;&lt; "Введите кол-во элементов ряда" &lt;&lt; std::endl;\n        std::cin >> N;\n        double ai{ x };\n        for (int i = 1; i &lt; N; i++)//ошибочка\n        {\n          Sn += ai;\n          ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n        }\n        std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; N &lt;&lt; " элементах ряда =" &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n\n\n      }\n      else if (choice == 2)\n      {\n\n\n        int i{};\n        double eps = 1.0E-12;\n\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          double ai{ x };\n\n          for (i = 1; abs(ai) > eps; i++)\n          {\n            Sn += ai;\n            ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n          }\n          std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; i &lt;&lt; " элементах ряда ="&lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n          std::cout &lt;&lt; "Точное значение" &lt;&lt; sin(x) &lt;&lt; std::endl;\n          eps /= 100;\n\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, любое другое значение - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n\n\n  } while (choice != 3);\n\n}\n</iomanip></iostream></pre> </article> '];function d(){var t=document.querySelector(".lections");console.log(t);var n=document.querySelectorAll(".js-dsr-lecture");if(n){console.log(n);for(var e=function(e){n[e].addEventListener("click",(function(n){n.preventDefault(),s[e]&&(t.innerHTML=s[e],function(){var t=document.querySelector(".lections"),n=document.getElementById("link-to-dsr2024cpp");n&&n.addEventListener("click",(function(n){n.preventDefault(),t.innerHTML=c,d()}))}())}))},l=0;l<n.length;l++)e(l)}}var p,u,h=document.getElementById("maincomponent"),f=document.createElement("section");function b(t){return b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},b(t)}function m(){m=function(){return t};var t={},n=Object.prototype,e=n.hasOwnProperty,l=Object.defineProperty||function(t,n,e){t[n]=e.value},i="function"==typeof Symbol?Symbol:{},r=i.iterator||"@@iterator",a=i.asyncIterator||"@@asyncIterator",o=i.toStringTag||"@@toStringTag";function c(t,n,e){return Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}),t[n]}try{c({},"")}catch(t){c=function(t,n,e){return t[n]=e}}function s(t,n,e,i){var r=n&&n.prototype instanceof u?n:u,a=Object.create(r.prototype),o=new j(i||[]);return l(a,"_invoke",{value:S(t,e,o)}),a}function d(t,n,e){try{return{type:"normal",arg:t.call(n,e)}}catch(t){return{type:"throw",arg:t}}}t.wrap=s;var p={};function u(){}function h(){}function f(){}var v={};c(v,r,(function(){return this}));var y=Object.getPrototypeOf,x=y&&y(y(L([])));x&&x!==n&&e.call(x,r)&&(v=x);var g=f.prototype=u.prototype=Object.create(v);function w(t){["next","throw","return"].forEach((function(n){c(t,n,(function(t){return this._invoke(n,t)}))}))}function _(t,n){function i(l,r,a,o){var c=d(t[l],t,r);if("throw"!==c.type){var s=c.arg,p=s.value;return p&&"object"==b(p)&&e.call(p,"__await")?n.resolve(p.__await).then((function(t){i("next",t,a,o)}),(function(t){i("throw",t,a,o)})):n.resolve(p).then((function(t){s.value=t,a(s)}),(function(t){return i("throw",t,a,o)}))}o(c.arg)}var r;l(this,"_invoke",{value:function(t,e){function l(){return new n((function(n,l){i(t,e,n,l)}))}return r=r?r.then(l,l):l()}})}function S(t,n,e){var l="suspendedStart";return function(i,r){if("executing"===l)throw new Error("Generator is already running");if("completed"===l){if("throw"===i)throw r;return{value:void 0,done:!0}}for(e.method=i,e.arg=r;;){var a=e.delegate;if(a){var o=E(a,e);if(o){if(o===p)continue;return o}}if("next"===e.method)e.sent=e._sent=e.arg;else if("throw"===e.method){if("suspendedStart"===l)throw l="completed",e.arg;e.dispatchException(e.arg)}else"return"===e.method&&e.abrupt("return",e.arg);l="executing";var c=d(t,n,e);if("normal"===c.type){if(l=e.done?"completed":"suspendedYield",c.arg===p)continue;return{value:c.arg,done:e.done}}"throw"===c.type&&(l="completed",e.method="throw",e.arg=c.arg)}}}function E(t,n){var e=n.method,l=t.iterator[e];if(void 0===l)return n.delegate=null,"throw"===e&&t.iterator.return&&(n.method="return",n.arg=void 0,E(t,n),"throw"===n.method)||"return"!==e&&(n.method="throw",n.arg=new TypeError("The iterator does not provide a '"+e+"' method")),p;var i=d(l,t.iterator,n.arg);if("throw"===i.type)return n.method="throw",n.arg=i.arg,n.delegate=null,p;var r=i.arg;return r?r.done?(n[t.resultName]=r.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=void 0),n.delegate=null,p):r:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,p)}function M(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function k(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(M,this),this.reset(!0)}function L(t){if(t){var n=t[r];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var l=-1,i=function n(){for(;++l<t.length;)if(e.call(t,l))return n.value=t[l],n.done=!1,n;return n.value=void 0,n.done=!0,n};return i.next=i}}return{next:P}}function P(){return{value:void 0,done:!0}}return h.prototype=f,l(g,"constructor",{value:f,configurable:!0}),l(f,"constructor",{value:h,configurable:!0}),h.displayName=c(f,o,"GeneratorFunction"),t.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===h||"GeneratorFunction"===(n.displayName||n.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,f):(t.__proto__=f,c(t,o,"GeneratorFunction")),t.prototype=Object.create(g),t},t.awrap=function(t){return{__await:t}},w(_.prototype),c(_.prototype,a,(function(){return this})),t.AsyncIterator=_,t.async=function(n,e,l,i,r){void 0===r&&(r=Promise);var a=new _(s(n,e,l,i),r);return t.isGeneratorFunction(e)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},w(g),c(g,o,"Generator"),c(g,r,(function(){return this})),c(g,"toString",(function(){return"[object Generator]"})),t.keys=function(t){var n=Object(t),e=[];for(var l in n)e.push(l);return e.reverse(),function t(){for(;e.length;){var l=e.pop();if(l in n)return t.value=l,t.done=!1,t}return t.done=!0,t}},t.values=L,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!t)for(var n in this)"t"===n.charAt(0)&&e.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var n=this;function l(e,l){return a.type="throw",a.arg=t,n.next=e,l&&(n.method="next",n.arg=void 0),!!l}for(var i=this.tryEntries.length-1;i>=0;--i){var r=this.tryEntries[i],a=r.completion;if("root"===r.tryLoc)return l("end");if(r.tryLoc<=this.prev){var o=e.call(r,"catchLoc"),c=e.call(r,"finallyLoc");if(o&&c){if(this.prev<r.catchLoc)return l(r.catchLoc,!0);if(this.prev<r.finallyLoc)return l(r.finallyLoc)}else if(o){if(this.prev<r.catchLoc)return l(r.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<r.finallyLoc)return l(r.finallyLoc)}}}},abrupt:function(t,n){for(var l=this.tryEntries.length-1;l>=0;--l){var i=this.tryEntries[l];if(i.tryLoc<=this.prev&&e.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var r=i;break}}r&&("break"===t||"continue"===t)&&r.tryLoc<=n&&n<=r.finallyLoc&&(r=null);var a=r?r.completion:{};return a.type=t,a.arg=n,r?(this.method="next",this.next=r.finallyLoc,p):this.complete(a)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),p},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var e=this.tryEntries[n];if(e.finallyLoc===t)return this.complete(e.completion,e.afterLoc),k(e),p}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var e=this.tryEntries[n];if(e.tryLoc===t){var l=e.completion;if("throw"===l.type){var i=l.arg;k(e)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,e){return this.delegate={iterator:L(t),resultName:n,nextLoc:e},"next"===this.method&&(this.arg=void 0),p}},t}function v(t,n,e,l,i,r,a){try{var o=t[r](a),c=o.value}catch(t){return void e(t)}o.done?n(c):Promise.resolve(c).then(l,i)}function y(){var t;return t=m().mark((function t(n){return m().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:document.querySelector("#page").appendChild(n);case 2:case"end":return t.stop()}}),t)})),y=function(){var n=this,e=arguments;return new Promise((function(l,i){var r=t.apply(n,e);function a(t){v(r,l,i,a,o,"next",t)}function o(t){v(r,l,i,a,o,"throw",t)}a(void 0)}))},y.apply(this,arguments)}f.classList.add("lections"),h.append(f),(p=document.createElement("div")).classList.add("btn-up","none"),p.innerHTML="НАВЕРХ",p.addEventListener("click",(function(){window.scrollTo({top:0,left:0,behavior:"smooth"})})),window.addEventListener("scroll",(function(){return function(t){(window.scrollY||document.documentElement.scrollTop)>400?t.classList.remove("none"):t.classList.add("none")}(p)})),function(t){y.apply(this,arguments)}(p),u=document.querySelector(".lections"),console.log(u),document.querySelector(".lections").innerHTML=c,d()})();
//# sourceMappingURL=index.js.map