/*! For license information please see index.js.LICENSE.txt */
(()=>{"use strict";function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n(t)}function t(t,e){for(var l=0;l<e.length;l++){var i=e[l];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,(void 0,r=function(t,e){if("object"!==n(t)||null===t)return t;var l=t[Symbol.toPrimitive];if(void 0!==l){var i=l.call(t,"string");if("object"!==n(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(i.key),"symbol"===n(r)?r:String(r)),i)}var r}function e(n){var t="function"==typeof Map?new Map:void 0;return e=function(n){if(null===n||(e=n,-1===Function.toString.call(e).indexOf("[native code]")))return n;var e;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(n))return t.get(n);t.set(n,i)}function i(){return l(n,arguments,a(this).constructor)}return i.prototype=Object.create(n.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),r(i,n)},e(n)}function l(n,t,e){return l=i()?Reflect.construct.bind():function(n,t,e){var l=[null];l.push.apply(l,t);var i=new(Function.bind.apply(n,l));return e&&r(i,e.prototype),i},l.apply(null,arguments)}function i(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function r(n,t){return r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},r(n,t)}function a(n){return a=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},a(n)}var o=function(e){!function(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),t&&r(n,t)}(p,e);var l,o,c,s,d=(c=p,s=i(),function(){var t,e=a(c);if(s){var l=a(this).constructor;t=Reflect.construct(e,arguments,l)}else t=e.apply(this,arguments);return function(t,e){if(e&&("object"===n(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(t)}(this,t)});function p(){return function(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}(this,p),d.call(this)}return l=p,(o=[{key:"connectedCallback",value:function(){this.innerHTML='<div class="container"> <section id="maincomponent"></section> </div> '}}])&&t(l.prototype,o),Object.defineProperty(l,"prototype",{writable:!1}),p}(e(HTMLElement));customElements.define("main-component",o);const c='<h1>DSR (Doing Software Right)</h1> <article class="article"> <h2>C++: Начала программирования</h2> </article> <article class="article"> <p>Лекции проходят в главном корпусе ВГУ</p> <p>Аудитория 435, по понедельникам с 18.40 до 20.00</p> <p>Преподаватель - Коток Игорь Дмитриевич</p> <p>Факультет ПММ</p> </article> <article class="article"> <div class="anchor" id="konspekt"></div> <h2>Конспект лекций</h2> <p><a href="dsr2024cpp/lec-1.html" class="js-dsr-lecture">Лекция 1 (16.09.2024)</a></p> <p><a href="dsr2024cpp/lec-2.html" class="js-dsr-lecture">Лекция 2 (23.09.2024)</a></p> <p><a href="dsr2024cpp/lec-3.html" class="js-dsr-lecture">Лекция 3 (7.10.2024)</a></p> <p><a href="dsr2024cpp/lec-4.html" class="js-dsr-lecture">Лекция 4 (14.10.2024)</a></p> <p><a href="dsr2024cpp/lec-5.html" class="js-dsr-lecture">Лекция 5 (21.10.2024)</a></p> <p><a href="dsr2024cpp/lec-6.html" class="js-dsr-lecture">Лекция 6 (5.11.2024)</a></p> </article> ';var s=['<article class="article"> <h1>Лекция 1 (16.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#types">Типы данных</a></p> <p><a href="#base">Основы C++</a></p> <p><a href="#task1">Задача 1</a></p> <p><a href="#task2">Задача 2</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Знакомство</li> <li>Ход курса</li> <li>Типы данных</li> <li>Основы C++</li> </ol> <ol> <li>Теория</li> <li>Практика</li> <li>Домашка</li> </ol> </article> <article class="article"> <div class="anchor" id="types"></div> <h3>Типы данных</h3> <h4>Базовые типы</h4> <ol> <li>bool</li> <li>int</li> <li>float</li> <li>char</li> </ol> <h4>Числовые типы</h4> <ol> <li>short 2 байта</li> <li>int 2-4 байта</li> <li>long 4-8 байт</li> <li>long long 8 байт</li> <li>float 4 байта</li> <li>double 8 байт</li> <li>long double 8+ байт</li> </ol> <h4>Символьные типы</h4> <ol> <li>char 1 байт (ASCII)</li> <li>wchar_t 2-4 байта</li> <li>char8_t 1 байт</li> <li>char16_t 2 байта</li> <li>char32_t 4 байта</li> </ol> <p>Раньше строковые типы данных представлялись массивами типа char</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout &lt;&lt; "Hello, world!\\n";\n  return 0;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="base"></div> <h3>Основы C++</h3> <p>Необходимо установить Visual Studio Community</p> <p>Фигурные скобки {} нужно использовать везде где есть логические блоки</p> <h4>Объявление и инициализация переменных</h4> <pre>\nint main()\n{\n  int valInt;\n  int valInt2 = 5;\n  int valInt3(6);\n  int valInt4{12};\n}\n</pre> <p>Инициализация через {} безопасная, при неправильном значении проект даже не запустится</p> <h4>Операторы ввода и вывода</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int count;\n  std::cout &lt;&lt; "Введите количество кроликов" &lt;&lt; std::endl;\n  std::cin &gt;&gt; count;\n  std::cout &lt;&lt; "Количество кроликов " &lt;&lt; count;\n\n  return 0;\n}\n</pre> <h4>Подключение русской локализации</h4> <code>setlocale(LC_ALL, "Russian");</code> <h4>Количество байт, выделенные под переменные</h4> <code>sizeof(bool)</code> <code>sizeof(int)</code> <code>sizeof(double)</code> <p>Использование namespase std нежелательно</p> <code>namespace std;</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1</h3> <p>Треугольник задан на плоскости координатами своих вершин. Найти его периметр</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x1, x2, x3, y1, y2, y3, a, b, c, p;\n\n  std::cout &lt;&lt; "Введите первую вершину" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x1 &gt;&gt; y1;\n  std::cout &lt;&lt; "Введите вторую вершину" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x2 &gt;&gt; y2;\n  std::cout &lt;&lt; "Введите третью вершину" &lt;&lt; std::endl;\n  std::cin &gt;&gt; x3 &gt;&gt; y3;\n\n  a = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n  b = sqrt((x2-x3)*(x2-x3) + (y2-y3)*(y2-y3));\n  c = sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3));\n  p = a+b+c;\n\n  std::cout &lt;&lt; "Периметр " &lt;&lt; p &lt;&lt; std::endl;\n  return 0;\n}\n</pre> <p>Возведение в квадрат</p> <code>a * a; // хорошо</code> <code>pow(a, 2); хуже, потому что выделяется лишняя память</code> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2</h3> <p>Найти сумму членов арифметической и геометрической прогрессии</p> <pre>\ndouble a1, d, Sa, na, b1, q, Sb, nb;\n\nSa = (2*a1+d*(na-1))/2*na;\nSb = b1*(1-pow(q,n,b))/(1-q);\n</pre> <code>system("pouse");</code> <code>std::cin.clear();</code> <code>std::cin.ignore(32767,n);</code> <code>std::cin.get</code> </article>','<article class="article"> <h1>Лекция 2 (23.09.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#conv">Преобразования типов</a></p> <p><a href="#oper">Операции</a></p> <p><a href="#task1">Задача 1</a></p> <p><a href="#task2">Задача 2</a></p> <p><a href="#task3">Задача 3</a></p> </article> <article class="article"> <div class="anchor" id="conv"></div> <h3>Преобразования типов</h3> <h4>Неявные преобразования типов</h4> <p>bool принимает другой тип</p> <code>bool flag_1 = 3; // true</code> <code>bool flag_2 = 2.5; // true</code> <code>bool flag_3 = 0; // false</code> <p>другой тип приниимает bool</p> <code>int var_int = true; // 1</code> <code>double var_double = false; // 0.00000</code> <p>целочисленное принимает вещественное</p> <code>int var_int_1 = 3.4; // 3</code> <code>int var_int_2 = 6.7; // 6</code> <p>вещественное принимает целочисленное</p> <code>float var_float = 324234222; // 324234208</code> <code>double var_double = 120000000000000011; // 1.2000000000000002e+17</code> <p>Если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается</p> <p>беззнаковые переменные принимают выходящие из диапазона</p> <code>unsigned char a = -5; // 251</code> <code>unsigned short b = -12; // 65524</code> <code>int c = -1; // 4294967295</code> <h4>Безопасные преобразования</h4> <p>bool - char - short - int - double - long double</p> <p>bool - char - short - int - long - long long</p> <p>unsigned char - unsigned short - unsigned int - unsigned long</p> <p>float - double - long double</p> <p>В арифметических операциях из двух типов выбирается максимальный и к нему приводится наименьший из них</p> <h4>Явные преобразования типов</h4> <h4>static_cast&lt;type&gt;(value)</h4> <p>Дальнобойщик проехал расстояние 130.21км со средней скоростью 8 км/ч. Сколько часов необходимо оплатить ему за проделанную поездку?</p> <pre>\ndouble distance{ 130.21 };\nunsigned int speed{ 8 };\nunsigned int hours{ static_cast<unsigned int>(distance / speed) } // hours = 16\n// unsigned int hours{ (unsigned int) (distance / speed) }; // hours = 16\nstd::cout &lt;&lt; "Затрачено часов = " &lt;&lt; hours &lt;&lt; std::endl;\n</unsigned></pre> </article> <article class="article"> <div class="anchor" id="oper"></div> <h3>Операции</h3> <h4>Базовые арифметические операции</h4> <p>Сложение a + b</p> <p>Вычитание a - b</p> <p>Умножение a * b</p> <p>Деление a / b</p> <p>Остаток от деления a % b</p> <h4>Операторы присваивания</h4> <p>a += b</p> <p>a -= b</p> <p>a *= b</p> <p>a /= b</p> <p>a %= b</p> <h4>Инкремент и декремент</h4> <p>префиксный инкремент ++a</p> <p>постфиксный инкремент a++</p> <p>префиксный декремент --a</p> <p>постфиксный декремент a--</p> <h4>Внимание подстава!</h4> <pre>\nint a{ 3 };\nint new_a{ --a };\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl; // a = 2\nstd::cout &lt;&lt; "new_a = " &lt;&lt; new_a &lt;&lt; std::endl; // new_a = 2\n</pre> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Приоритет операций</h4> <ol> <li>++, -- (инкремент, декремент)</li> <li>* (умножение), / (деление), % (остаток от деления)</li> <li>+ (сложение), - (вычитание)</li> </ol> <h4>Неоднозначный пример</h4> <pre>\nint b{ 1 };\nint new_b{ ++b * 3 + b++ * 5 };\nstd::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl; // b = 3\nstd::cout &lt;&lt; "new_b = " &lt;&lt; new_b &lt;&lt; std::endl; // new_b = 16\n</pre> <h4>Операции сравнения</h4> <p>a == b равно</p> <p>a &lt; b меньше</p> <p>a &lt;= b меньше или равно</p> <p>a &gt; b больше</p> <p>a &gt;= b больше или равно</p> <p>a != b не равно</p> <h4>Операции сравнения</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1{ a == b }; // false</code> <code>bool F2{ a &lt; b }; // true</code> <code>bool F3{ a &lt;= b }; // true</code> <code>bool F4{ a &gt; b }; // false</code> <code>bool F5{ a &gt;= b }; // false</code> <code>bool F6{ a != b }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> <h4>Логические операции</h4> <p>!a отрицание</p> <p>a && b И</p> <p>a || b ИЛИ</p> <p>a ^ b Исключающее ИЛИ</p> <h4>Логические операции</h4> <code>int a{ 8 }, b{ 11};</code> <code>bool F1( a == b && b > 3 }; // false</code> <code>bool F2( a != b || a == 3 }; // true</code> <code>std::cout &lt;&lt; "F1 = " &lt;&lt; std::boolalpha &lt;&lt; F1 &lt;&lt; std::endl;</code> <code>std::cout &lt;&lt; "F2 = " &lt;&lt; std::boolalpha &lt;&lt; F2 &lt;&lt; std::endl;</code> <h4>Определение оператора</h4> <p>if</p> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\n</pre> <p>if - else</p> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a &lt;= b\\n";\n}\n</pre> <p>if - else if - else</p> <pre>\nint a{ 8 }, b{ 11};\nif (a > b)\n{\n  std::cout &lt;&lt; "a > b\\n";\n}\nelse if (a &lt; b)\n{\n  std::cout &lt;&lt; "a &lt; b\\n";\n}\nelse\n{\n  std::cout &lt;&lt; "a == b\\n";\n}\n</pre> <h4>Тернарный оператор</h4> <code>a > b ? a++ : b++;</code> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1</h3> <p>Определить по введенным пользователем координатам попадания выстрела в мишень количество набранных очков</p> <p>3 очка если попали в круг радиусом 5 с центром в (0, 0)</p> <p>2 очка если попали в круг радиусом 10</p> <p>1 очко если попали в круг радиусом 15</p> <h4>Решение</h4> <h4>Инициализация и заполнение переменных</h4> <pre>\ndouble x{}, y{};\nint score{};\n\nstd::cout &lt;&lt; "Введите координаты выстрела\\n";\nstd::cin >> x >> y;\n</pre> <h4>Проверка на попадание</h4> <pre>\nif (x * x + y * y &lt;= 5)\n{\n  score = 3;\n}\nelse if (x * x + y * y &lt;= 10)\n{\n  score = 2;\n}\nelse if (x * x + y * y &lt;= 15)\n{\n  score = 1;\n}\n</pre> <h4>Вывод результатов работы</h4> <pre>\nif (score > 0)\n{\n  std::cout &lt;&lt; "Поздравляем! Вы выбили - " &lt;&lt; score &lt;&lt; "\\n";\n}\nelse{\n  std::cout &lt;&lt; "Вы промахнулись, нужно стараться лучше\\n";\n}\n</pre> <h4>Имеет ли право на жизнь?</h4> <pre>\nif (score)\n{\n  std::cout &lt;&lt; "Поздравляем! Вы выбили - " &lt;&lt; score &lt;&lt; "\\n";\n}\nelse{\n  std::cout &lt;&lt; "Вы промахнулись, нужно стараться лучше\\n";\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2</h3> <p>Составить программу для вычисления значения площади заштрихованной области, если точка с заданными координатами (x, y) попадает в эту область. В противном случае вывести соответствующее сообщение</p> <p>Большой круг радиусом 3 с центром в (0, 0). Малкенький круг с радиусом 1.5 с центром в (0, 1.5)</p> <h4>Решение</h4> <pre>\n#define _USE_MATH_DEFINES\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x{}, y{}, s{};\n\n  std::cout &lt;&lt; "Введите x и y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  if (x * x + y * y &lt;= 9 && x * x + (y + 1.5) * (y + 1.5) >= 2.25)\n  {\n    std::cout &lt;&lt; "Площадь равна " &lt;&lt; M_PI * 9 - M_PI * 2.25;\n  }\n  else\n  {\n    std::cout &lt;&lt; "Вы не попали в область" &lt;&lt; std::endl;\n  }\n}\n</pre> <h4>Определение switch case</h4> <pre>\nswitch (/*выражение*/)\n{\n  case // значение1: инструкции1; break;\n  case // значение2: инструкции2; break;\n  default: // инструкции;\n}\n</pre> <h4>Пример реализации</h4> <pre>\nint counter{ 2 };\n\nswitch (counter)\n{\n  case 1:\n    std::cout &lt;&lt; "counter = 1" &lt;&lt; std::endl;\n    break;\n  case 2:\n    std::cout &lt;&lt; "counter = 2" &lt;&lt; std::endl;\n    break;\n  case 3:\n    std::cout &lt;&lt; "counter = 3" &lt;&lt; std::endl;\n    break;\n  default:\n    std::cout &lt;&lt; "counter is undefined" &lt;&lt; std::endl;\n    break;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3</h3> <p>Требуется написать программу, которая принимает с клавиатуры координаты точки на плоскости (x, y - вещественные числа) и определяет принадлежность точки заштрихованной области, включая ее границы</p> <p>Область на плоскости лежит между графиками двух функций. Ниже y = 2 - x*x. Выше y = x</p> <p>Пояснение</p> <p>Нужно отдельно проверить через switch попадание в области C и G. Пользователю выводится меню, где указано "Чтобы проверить точку G введите 1" и т.д. switch обрабатывает запрос пользователя и выдает результат проверки на попадание в запрашиваемую область</p> <h4>Решение</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  double x{}, y{}, s{};\n\n  std::cout &lt;&lt; "Введите x и y" &lt;&lt; std::endl;\n  std::cin >> x >> y;\n\n  std::cout &lt;&lt; "Чтобы проверить всю область, нажмите 1" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Чтобы проверить область C, нажмите 2" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Чтобы проверить область G, нажмите 3" &lt;&lt; std::endl;\n\n  int command{};\n\n  std::cout &lt;&lt; "Введите команду" &lt;&lt; std::endl;\n  std::cin >> command;\n\n  switch (command)\n  {\n    case 1:\n      if (x&lt;=0 && y>=x && y &lt;= 2-x*x || x>0 && y&lt;=2-x*x && y>=0)\n      {\n        std::cout &lt;&lt; "Вы попали в закрашенную область\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Вы не попали в закрашенную область\\n";\n      }\n      break;\n    case 2:\n      if (y&lt;=x && y&lt;=2-x*x && x>0 && y>=0)\n      {\n        std::cout &lt;&lt; "Вы попали в область C\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Вы не попали в область C\\n";\n      }\n      break;\n    case 3:\n      if (y&lt;=x && y>=2-x*x && y&lt;=0)\n      {\n        std::cout &lt;&lt; "Вы попали в область G\\n";\n      }\n      else\n      {\n        std::cout &lt;&lt; "Вы не попали в область G\\n";\n      }\n      break;\n    default:\n      std::cout &lt;&lt; "Вы ввели неправильную команду\\n";\n  }\n}\n</pre> </article> ','<article class="article"> <h1>Лекция 3 (7.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#loop">Циклы</a></p> <p><a href="#task1">Задача 1</a></p> <p><a href="#bad">Обработка "плохих" данных</a></p> <p><a href="#task2">Задача 2</a></p> <p><a href="#task3">Задача 3</a></p> <p><a href="#task4">Задача 4</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>while</li> <li>for</li> <li>do while</li> <li>foreach</li> <li>Обработка "плохих" данных</li> </ol> </article> <article class="article"> <div class="anchor" id="loop"></div> <h3>Циклы</h3> <h4>Определение цикла while</h4> <pre>\nwhile (/*выражение*/)\n{\n  //тело_цикла\n}\n</pre> <p>Найти сумму чисел от 1 до 100</p> <pre>\nint i = 0;\nint sum = 0;\n\nwhile (i &lt; 100)\n{\n  i++;\n  sum += i;\n}\n\nstd::cout &lt;&lt; "Сумма чисел от 1 до 100 = " &lt;&lt; sum &lt;&lt; std::endl;\n</pre> <h4>Определение вложенных циклов</h4> <pre>\nwhile (/*выражение1*/)\n{\n  //тело_цикла1\n  while (/*выражение2*/)\n  {\n    //тело_цикла2\n  }\n}\n</pre> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы while</p> <pre>\nint a{}, b{};\n\nwhile (a &lt; 10)\n{\n  a++;\n  while (b &lt; 10)\n  {\n    b++;\n    std::cout &lt;&lt; a &lt;&lt; "\\tx\\t" &lt;&lt; b &lt;&lt; "\\t=\\t" &lt;&lt; a * b &lt;&lt; std::endl;\n  }\n  std::cout &lt;&lt; std::endl;\n  b = 0;\n}\n</pre> <h4>Бесконечные циклы</h4> <pre>\nwhile (true)\n{\n  // этот цикл будет выполняться бесконечно\n}\n</pre> <pre>\nint count = 12;\n\nwhile (count &lt; 20) // всегда будет true\n{\n  std::cout &lt;&lt; count &lt;&lt; " "; // эта строка будет выполняться бесконечно\n}\nreturn 0; // эта строка никогда не выполнится\n</pre> <p>Единственный способ выйти из бесконечного цикла - использовать операторы return, break, goto, выбросить исключение или воспользоваться функцией exit()</p> <h4>continue</h4> <p>Нужно вывести все четные числа от 0 до 30</p> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 == 0)\n  {\n    std::cout &lt;&lt; i &lt;&lt; " ";\n  }\n}\n</pre> <pre>\nint i{0};\n\nwhile (i &lt; 30)\n{\n  i++;\n  if (i % 2 != 0)\n  {\n    continue;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <h4>break</h4> <pre>\nwhile (i != 0)\n{\n  i--;\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nwhile (1)\n{\n  i--;\n  if (i == 0)\n  {\n    break;\n  }\n  std::cout &lt;&lt; i &lt;&lt; " ";\n}\n</pre> <pre>\nint count = 1;\nwhile (count &lt;= 50)\n{\n  if (count &lt; 10)\n  {\n    std::cout &lt;&lt; "0" &lt;&lt; count &lt;&lt; " ";\n  }\n  else\n  {\n    std::cout &lt;&lt; count &lt;&lt; " "\n  }\n  if (count % 10 == 0)\n  {\n    std::cout &lt;&lt; "\\n";\n  }\n  ++count;\n}\n</pre> <h4>Определение цикла for</h4> <p>Вывести квадраты четных чисел от 0 до 20</p> <pre>\nint length{20};\n\nfor (int i = 0; i &lt; length; i++)\n{\n  if (i % 2 == 0)\n  {\n    std::cout &lt;&lt; i * i &lt;&lt; " ";\n  }\n}\n</pre> <p>Вывести таблицу умножения от 1 до 9, используя вложенные циклы for</p> <pre>\nfor (int i{1}; i &lt; 10; i++)\n{\n  for (int j{1}; j &lt; 10; j++)\n  {\n    std::cout &lt;&lt; i &lt;&lt; "\\t x \\t" &lt;&lt; j &lt;&lt; "\\t = \\t" &lt;&lt; i * j &lt;&lt; std::endl;\n  }\n  std::cout &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="task1"></div> <h3>Задача 1</h3> <p>Напишите программу, где пользователь вводит любое целое положительное число. А программа суммирует все числа от 1 до введенного пользователем числа.</p> <pre>\nunsigned int temp{};\nint sum{};\nstd::cin >> temp;\n\nfor (int j{1}; j &lt; temp; j++)\n{\n  sum += j;\n}\n</pre> <h4>ctime, srand, rand</h4> <pre>\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nint main()\n{\n  srand(time(0));\n  int balance = 8;\n\n  do\n  {\n    std::cout &lt;&lt; "balance = " &lt;&lt; balance &lt;&lt; std::endl;\n    int removal = rand() % 3;\n    std::cout &lt;&lt; "removal = " &lt;&lt; removal &lt;&lt; std::endl;\n    balance -= removal;\n  } while (balance > 0);\n\n  return 0;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="bad"></div> <h3>Обработка "плохих" данных</h3> <h4>Оператор извлечения</h4> <p>Если во входном буфере есть данные, то эти данные используются для извлечения.</p> <p>Если во входном буфере нет данных, то пользователю предлагается ввести данные (обычно именно это и происходит в большинстве случаев). Когда пользователь нажимает Enter, символ новой строки \\n помещается во входной буфер</p> <h4>Оператор извлечения &gt;&gt;</h4> <p>Оператор &gt;&gt; извлекает столько данных из входного буфера в переменную, сколько позволяет размер самой переменной (игнорируя любые пробелы, табы и \\n)</p> <p>Любые данные, которые не были извлечены остаются во входном буфере для последующего извлечения</p> <pre>\nint a;\nstd::cin &gt;&gt; a;\n</pre> <p>Пользователь вводит 21Z. 21 записывается в переменную a, при этом в буфере остается Z\\n</p> <h4>Ошибка 1: Извлечение выполняется успешно, но данные бесполезны</h4> <pre>\nwhile (true) // пока пользователь не введет корректные данные\n{\n  std::cout &lt;&lt; "Enter \'+\', \'-\', \'*\', \'/\' :";\n  char sm;\n  std::cin &gt;&gt; sm;\n\n  // вывполняем проверку значений\n  if (sm == \'+\'\' || sm ==\'-\' || sm == \'*\' || sm == \'/\') {\n    return sm; // возвращаем данные в функцию main()\n  } else { // иначе, сообщаем что что-то пошло не так\n    std::cout &lt;&lt; "Invalid input. Try again.\\n";\n  }\n}\n</pre> <h4>Ошибка 2: Извлечение выполняется успешно, но пользователь вводит лишний текст</h4> <pre>\nstd::cout &lt;&lt; "Enter a double value: ";\ndouble a;\nstd::cin &gt;&gt; a;\nstd::cin.ignore(32767, \'\\n\'); // удаляем до 32767 символов\n// из входного буфера вплоть до появления символа \'\\n\'\n\nstd::cin.ignore(std::cin.rdbuf()->in_avail());\n// зачищаем только то, что использовано\n</pre> <h4>Ошибка 3: Извлечение не выполняется</h4> <pre>\nwhile (true) // пока пользователь не введет корректное значение1\n{\n  std::cout &lt;&lt; "Enter a double value: ";\n  double a;\n  std::cin &gt;&gt; a;\n\n  if (std::cin.fail()) // если предыдущее значение оказалось неудачным\n  {\n    std::cin.clear(); // возвращаем cin в обычный режим работы\n    std::cin.ignore(32767, \'\\n\'); // удаляем значения предыдущего ввода из входного буфера\n  }\n  else // если все хорошо, выходим используя break\n  {\n    std::cin.ignore(32767, \'\\n\');\n    break;\n  }\n}\n</pre> <h4>Ошибка 4: Извлечение выполняется успешно, но пользователь ввел слишком большое числовое значение</h4> <pre>\nstd::int16_t x{ 0 };\n// переменная x занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number x between -32768 and 32767: ";\nstd::cin &gt;&gt; x;\n\nstd::int16_t y{ 0 };\n// переменная y занимает 16 бит\n// ее диапазон от -32768 до 32767\nstd::cout &lt;&lt; "Enter number y between -32768 and 32767: ";\nstd::cin &gt;&gt; y;\n\nstd::cout &lt;&lt; "The sum is: " &lt;&lt; x + y &lt;&lt; \'\\n\';\n</pre> </article> <article class="article"> <div class="anchor" id="task2"></div> <h3>Задача 2</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>1 + 1/3 + 1/(3<sup>2</sup>) + ... + 1/(3<sup>8</sup>)</code> <h4>Решение</h4> <pre>\ndouble sum {1};\ndouble denominator {1};\n\nfor (int i = 0; i &lt; 8; i++)\n{\n  denominator *= 3;\n  sum += 1 / denominator;\n}\n\nstd::cout &lt;&lt; sum;\n</pre> </article> <article class="article"> <div class="anchor" id="task3"></div> <h3>Задача 3</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>x + x<sup>3</sup>/3 + x<sup>5</sup>/5 + ... + x<sup>11</sup>/11</code> <h4>Решение</h4> <pre>\ndouble sum {};\nint n {5};\ndouble x {2.0};\ndouble temp = x;\n\nfor (int i = 0; i &lt; n; i++)\n{\n  sum += temp;\n  temp = temp * (2 * i - 1) * x * x / (2 * i + 1);\n}\n\nstd::cout &lt;&lt; sum;\n</pre> </article> <article class="article"> <div class="anchor" id="task4"></div> <h3>Задача 4</h3> <p>Вычислить сумму числовой последовательности без использования возведения в степень</p> <code>e<sup>x</sup> = 1 + x + x<sup>2</sup>/2! + x<sup>3</sup>/3! + x<sup>4</sup>/4! + ...</code> <code>cos x = 1 - x<sup>2</sup>/2! + x<sup>4</sup>/4! + x<sup>6</sup>/6! + ...</code> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! + x<sup>7</sup>/7! + ...</code> </article> ','<article class="article"> <h1>Лекция 4 (14.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#ref">Ссылки</a></p> <p><a href="#point">Указатель</a></p> <p><a href="#t1">Практика. Sum(int, int)</a></p> <p><a href="#t2">Практика. Max(int, int)</a></p> <p><a href="#t3">Практика. Swap(int&, int&)</a></p> <p><a href="#t4">Практика. Print()</a></p> <p><a href="#t5">Практика. Swap(int*, int*)</a></p> <p><a href="#t6">Практика. Sum(int, int, int = 3)</a></p> <p><a href="#t7">Практика. init(int*)</a></p> <p><a href="#t8">Практика. init(int*&)</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Ссылки и указатели</li> <li>Функции</li> <li>Массивы</li> </ol> </article> <article class="article"> <div class="anchor" id="ref"></div> <h3>Ссылки</h3> <p>тип_данных & название_ссылки = переменная_типа_ссылки;</p> <pre>\nint main()\n{\n  int a = 3;\n  int &refa = a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 3\n\n  refa++;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 4\n  std::cout&lt;&lt;refa&lt;&lt;std::endl; // 4\n}\n</pre> </article> <article class="article"> <div class="anchor" id="point"></div> <h3>Указатель</h3> <p>тип_данных * название_указателя;</p> <pre>\nint main()\n{\n  int a = 3;\n  int *pointA = &a;\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl;\n\n  std::cout&lt;&lt;&a&lt;&lt;std::endl; // 000000C2E6DAFBF4\n  std::cout&lt;&lt;pointA&lt;&lt;std::endl; // 000000C2E6DAFBF4\n\n  std::cout&lt;&lt;std::endl; //\n\n  std::cout&lt;&lt;a&lt;&lt;std::endl; // 3\n  std::cout&lt;&lt;*pointA&lt;&lt;std::endl; // 3\n}\n</pre> <h4>Указатель</h4> <p>Количество выделяемой памяти не изменяется в зависимости от типа переменных на которую ссылается указатель.</p> <pre>\nint *pint{};\ndouble *pdouble{};\n\nstd::cout&lt;&lt;sizeof(pint)&lt;&lt;std::endl; // 8\nstd::cout&lt;&lt;sizeof(pdouble)&lt;&lt;std::endl; // 8\n</pre> <h4>Указатель</h4> <pre>\nint a {10};\nint b {2};\n\nint *pa {&a};\nint *pb {&b};\n\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\nstd::cout&lt;&lt;"pb: address="&lt;&lt;pb&lt;&lt;"\\t value="&lt;&lt;*pb&lt;&lt;std::endl;\n\npa = pb;\nstd::cout&lt;&lt;"pa: address="&lt;&lt;pa&lt;&lt;"\\t value="&lt;&lt;*pa&lt;&lt;std::endl;\n*pa = 125;\nstd::cout&lt;&lt;"b value="&lt;&lt;b&lt;&lt;std::endl;\n</pre> <code>pa: address=00000072CAFEFA54 value=10</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>pb: address=00000072CAFEFA74 value=2</code> <code>b value=125</code> <h4>Указатель</h4> <pre>\nint a {10};\nint b {6};\n\nint *p{};\nint *&pRef {p};\n\npRef = &a;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n\n*pRef = 70;\nstd::cout&lt;&lt;"a value="&lt;&lt;a&lt;&lt;std::endl;\n\npRef = &b;\nstd::cout&lt;&lt;"p value="&lt;&lt;*p&lt;&lt;std::endl;\n</pre> <code>p value=10</code> <code>a value=70</code> <code>p value=6</code> <h4>Операторы new и delete</h4> <pre>\nint *ptr = new int;\nint *ptr_1 = new int();\nint *ptr_2 {new int(12)};\n\nstd::cout &lt;&lt; *ptr &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; *ptr_2 &lt;&lt; std::endl;\n\ndelete ptr;\ndelete ptr_1;\ndelete ptr_2;\n\nptr = nullptr;\nptr_1 = nullptr;\nptr_2 = nullptr;\n</pre> <code>-842150451</code> <code>0</code> <code>12</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Sum(int, int)</h3> <p>Найдем сумму двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = a + b;\n}\n</pre> <p>Разделим программу на несколько файлов</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b) = " &lt;&lt; sum &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Практика. Max(int, int)</h3> <p>Добавим в проект функцию Max, возвращающую максимум из двух чисел</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Max(a,b) = " &lt;&lt; max &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t3"></div> <h3>Практика. Swap(int&, int&)</h3> <p>Добавим в проект функцию Swap, которая ничего не возвращает, принимает адреса двух переменных и меняет местами их значения</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(&a, &b);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t4"></div> <h3>Практика. Print()</h3> <p>Добавим вывод на экран слова Bob. Добавим функцию Print, которая выводит на экран число, сколько раз функция Print вызывалась</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int&, int&);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int &x, int &y)\n{\n  int temp = x;\n  x = y;\n  y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> <p>Статическая переменная i, объявленная внутри функции Print() инициализируется только один раз - при первом вызове функции. Она получает значение i = 0. При повторных вызовах, инициализация не производится.</p> </article> <article class="article"> <div class="anchor" id="t5"></div> <h3>Практика. Swap(int*, int*)</h3> <p>Перепишем функцию Swap(), при которой она будет принимать не адреса, а указатели на две переменные.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  int max{};\n  max = Max(a, b);\n\n  int *pa = &a;\n  int *pb = &b;\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n  Swap(pa, pb);\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y)\n{\n  return x + y;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t6"></div> <h3>Практика. Sum(int, int, int = 3)</h3> <p>Перепишем функцию Sum(), при которой она будет принимать не два, а три параметра. Причем третий параметр будет необязательным и в случае его отсутствия будет подставляться значение по умолчанию.</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int a{3};\n  int b{4};\n\n  int sum{};\n  sum = Sum(a, b);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "default c = " &lt;&lt; 3 &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,c) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  sum = Sum(a, b, 25);\n\n  std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n  std::cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Sum(a,b,25) = " &lt;&lt; sum &lt;&lt; std::endl;\n\n  int max{};\n  max = Max(a, b);\n\n  Swap(&a, &b);\n\n  std::cout &lt;&lt; "Bob" &lt;&lt; std::endl;\n\n  Print();\n  Print();\n  Print();\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nint Sum(int, int, int = 3);\nint Max(int, int);\nvoid Swap(int*, int*);\nvoid Print();\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nint Sum(int x, int y, int z)\n{\n  return x + y + z;\n}\n\nint Max(int x, int y)\n{\n  if (x > y)\n  {\n    return x;\n  }\n  else{\n    return y;\n  }\n}\n\nvoid Swap(int *x, int *y)\n{\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid Print()\n{\n  static int i{0};\n  std::cout &lt;&lt; i++ &lt;&lt; std::endl;\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t7"></div> <h3>Практика. init(int*)</h3> <p>Напишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article> <article class="article"> <div class="anchor" id="t8"></div> <h3>Практика. init(int*&)</h3> <p>Перепишем функцию init(), которая инициализирует значение переменной</p> <p>Файл project.cpp</p> <pre>\n#include &lt;iostream&gt;\n#include "Math.h"\n\nint main()\n{\n  int *a;\n  init(&a);\n  std::cout &lt;&lt; "a = " &lt;&lt; *a &lt;&lt; std::endl;\n}\n</pre> <p>Файл Math.h</p> <pre>\n#pragma once\n\nvoid init(int*);\n</pre> <p>Файл Math.cpp</p> <pre>\n#include "Math.h"\n\nvoid init(int *x)\n{\n  x = new int(3);\n}\n</pre> </article>','<article class="article"> <h1>Лекция 5 (21.10.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#plan">План работы</a></p> <p><a href="#func">Перегрузка функции</a></p> <p><a href="#const1">Константы</a></p> <p><a href="#const2">Указатели на константы</a></p> <p><a href="#const3">Константный указатель</a></p> <p><a href="#const4">Константный указатель на константу</a></p> <p><a href="#const5">Константные параметры</a></p> <p><a href="#const6">Константные ссылочные параметры</a></p> <p><a href="#const7">Вопросы по перегрузке</a></p> <p><a href="#t1">Практика. Сумма ряда</a></p> <p><a href="#t2">Код программы</a></p> </article> <article class="article"> <div class="anchor" id="plan"></div> <h3>План работы</h3> <ol> <li>Ссылки и указатели</li> <li>Функции</li> <li>Массивы</li> </ol> </article> <article class="article"> <div class="anchor" id="func"></div> <h3>Перегрузка функции</h3> <p>Напишем функцию sum(), которая складывает два целых числа и функцию sum(), которая скаладывает два вещественных числа</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n</pre> <code>9</code> <code>4.1</code> <p>Добавим еще одну функцию sum(), которая складывает три целых числа, причем третий параметр не обязательный, при его отсутствии будет подставляться значение по умолчанию.</p> <pre>\nint sum(int, int);\ndouble sum(double, double);\nint sum(int, int, int = 2);\n\nint main()\n{\n  int result1 {sum(3,6)};\n  std::cout &lt;&lt; result1 &lt;&lt; std::endl;\n\n  double result2 {sum(2.5, 1.6)};\n  std::cout &lt;&lt; result2 &lt;&lt; std::endl;\n\n  return 0;\n}\n\nint sum(int a, int b)\n{\n  return a + b;\n}\n\ndouble sum(double a, double b)\n{\n  return a + b;\n}\n\nint sum(int a, int b, int c)\n{\n  return a + b + c;\n}\n</pre> <p>Компилятор не знает какую функцию запустить</p> </article> <article class="article"> <div class="anchor" id="const1"></div> <h3>Константы</h3> <p>const тип_данных & имя_переменной = значение_переменной</p> <p>Объявим константу с инициализацией, а потом попробуем присвоить ей новое значение</p> <pre>\nconst int a = 3;\na = 10; // нельзя\n</pre> <p>Компилятор не будет компилировать, потому что константе нельзя присвоить новое значение</p> <p>Объявим константу без инициализации, а потом попробуем ее инициализировать</p> <pre>\nconst int age; // нельзя\nage = 6;\n</pre> <p>Компилятор не будет компилировать, потому что константу нужно инициализировать только при объявлении.</p> </article> <article class="article"> <div class="anchor" id="const2"></div> <h3>Указатели на константы</h3> <p>const тип_данных * имя_указателя = адресс_переменной</p> <pre>\nconst int a {10};\nconst int *pa {&a};\n\nstd::cout &lt;&lt; "address = " &lt;&lt; pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 4; // нельзя\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nconst int b {45};\npa = &b; // можно\n\nstd::cout &lt;&lt; "*pa = " &lt;&lt; *pa &lt;&lt; std::endl;\nstd::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;\n</pre> <pre>\nconst int a {10};\nconst int *pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\na = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n</pre> </article> <article class="article"> <div class="anchor" id="const3"></div> <h3>Константный указатель</h3> <p>тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nint *const pa {&a};\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\n*pa = 22; // можно\nstd::cout &lt;&lt; "value = " &lt;&lt; *pa &lt;&lt; std::endl;\n\nint b {45};\npa = &b; // нельзя\n</pre> </article> <article class="article"> <div class="anchor" id="const4"></div> <h3>Константный указатель на константу</h3> <p>const тип_данных *const имя_указателя = адресс_переменной</p> <pre>\nint a {10};\nconst int *const pa {&a};\nint b {45};\n</pre> </article> <article class="article"> <div class="anchor" id="const5"></div> <h3>Константные параметры</h3> <pre>\nvoid square(int);\n//void square(const int);\n\nint main()\n{\n  int number {12};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int a)\n{\n  std::cout &lt;&lt; "a * a = " &lt;&lt; a * a &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 144</code> </article> <article class="article"> <div class="anchor" id="const6"></div> <h3>Константные ссылочные параметры</h3> <pre>\nvoid square(const int&);\n\nint main()\n{\n  const int number {6};\n  square(number);\n\n  return 0;\n}\n\nvoid square(const int &n)\n{\n  std::cout &lt;&lt; "n * n = " &lt;&lt; n * n &lt;&lt; std::endl;\n}\n</pre> <code>a * a = 36</code> </article> <article class="article"> <div class="anchor" id="const7"></div> <h3>Вопросы по перегрузке</h3> <pre>\nvoid show(int);\nvoid show(int&);\n\nvoid print(int);\nvoid print(const int);\n\nint square(int*);\nint square(const int*);\n\nint square(int* num)\n{\n  return *num * *num;\n}\n\nint square(const int* num)\n{\n  return *num * *num;\n}\n</pre> <p>Компилятор не различает в данном случае & и const от простой реализации</p> <pre>\nconst int n1{2};\nint n2{3};\n\nint square_n1 {square(&n1)};\nint square_n2 {square(&n2)};\n\nstd::cout &lt;&lt; "square(n1) = " &lt;&lt; square_n1 &lt;&lt; std::endl;\nstd::cout &lt;&lt; "square(n2) = " &lt;&lt; square_n2 &lt;&lt; std::endl;\n</pre> <code>4</code> <code>9</code> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Практика. Сумма ряда</h3> <p>Вычислить суммму ряда</p> <code>sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ...</code> <p>Для начала попробуем упростить выражение</p> <code>S<sub>n</sub> = sin x = x - x<sup>3</sup>/3! + x<sup>5</sup>/5! - x<sup>7</sup>/7! + ... + (-1)<sup>n</sup> * (x<sup>2n+1</sup>)/(2n+1)!</code> <code>q = a<sub>n</sub>/a<sub>n-1</sub></code> <code>q = (-1)<sup>n</sup> * x<sup>2n+1</sup>/(2n+1)! * (2n-1)!/(x<sup>2n-1</sup> * (-1)<sup>n-1</sup>)</code> <code>q = (-1)<sup>n-n+1</sup> * x<sup>2n+1-2n+1</sup> * (2n-1)!/(2n+1)!</code> <p>Так как</p> <code>n! = 1*2*3*...*n</code> <code>(n-1)! = 1*2*3*...*(n-1)</code> <p>То</p> <code>n! = (n-1)!*n</code> <p>Тогда</p> <code>(2n+1)! = (2n-1)! * 2n * (2n+1)</code> <p>Подставим это вместо (2n+1)!</p> <code>q = (-1) * x<sup>2</sup> * (2n-1)! / ((2n-1)! * 2n * (2n+1))</code> <code>q = (-1) * x<sup>2</sup> / (2n * (2n+1))</code> <h4>1 часть</h4> <p>Так как при i=0 множитель даст деление на 0, начинаем с 1, а самое первое значение заносим заранее в ai</p> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; i &lt; n; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <h4>2 часть</h4> <p>Посчитаем с погрешностью. Пусть погрешность будет очень маленькая величина</p> <code>eps = 1.0e-10;</code> <pre>\ndouble Sn{};\ndouble ai{x};\n\nfor (int i=1; abs(ai)>eps; i++)\n{\n  Sn += ai;\n  ai *= (-1) * (x*x) / (2*n * (2*n + 1));\n}\n</pre> <p>С каждым шагом ai стремится к нашей точности eps, уменьшается. Чем выше точность eps (чем оно меньше), тем ближе к значению S<sub>точ</sub>. Таким образом мы считаем S<sub>n</sub>до тех пор, пока абсолютное значение ai не станет меньше eps</p> </article> <article class="article"> <div class="anchor" id="t2"></div> <h3>Код программы</h3> <pre>\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    std::cout &lt;&lt; "Введите 1- Сумма ряда" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 2- Сумма ряда c погрешностью" &lt;&lt; std::endl;\n    std::cout &lt;&lt; "Введите 3- Завершение программы" &lt;&lt; std::endl;\n\n    bool isError{ true };\n    do {\n\n      std::cin >> choice;\n      if (!std::cin.fail()&& choice&lt;=3 && choice>=1)\n      {\n        isError = false;\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n      else\n      {\n        std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n        std::cin.clear();\n        std::cin.ignore(std::cin.rdbuf()->in_avail());\n      }\n\n    } while (isError);\n\n    if (choice != 3)\n    {\n      double x{};\n      isError = true;\n      do {\n\n        std::cout &lt;&lt; "Введите x " &lt;&lt; std::endl;\n        std::cin >> x;\n        if (!std::cin.fail())\n        {\n          isError = false;\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n        else\n        {\n          std::cout &lt;&lt; "Ошибка ввода" &lt;&lt; std::endl;\n          std::cin.clear();\n          std::cin.ignore(std::cin.rdbuf()->in_avail());\n        }\n\n      } while (isError);\n\n      if (choice == 1)\n      {\n\n        double Sn{};\n        int N{};\n        std::cout &lt;&lt; "Введите кол-во элементов ряда" &lt;&lt; std::endl;\n        std::cin >> N;\n        double ai{ x };\n        for (int i = 1; i &lt; N; i++)//ошибочка\n        {\n          Sn += ai;\n          ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n        }\n        std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; N\n        &lt;&lt; " элементах ряда =" &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n\n\n      }\n      else if (choice == 2)\n      {\n\n\n        int i{};\n        double eps = 1.0E-12;\n\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          double ai{ x };\n\n          for (i = 1; abs(ai) > eps; i++)\n          {\n            Sn += ai;\n            ai *= (-1) * (x * x) / (2*i * (2*i + 1));\n          }\n          std::cout &lt;&lt; "Приближенное значение при " &lt;&lt; i\n          &lt;&lt; " элементах ряда ="&lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n          std::cout &lt;&lt; "Точное значение" &lt;&lt; sin(x) &lt;&lt; std::endl;\n          eps /= 100;\n\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, другое - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n\n\n  } while (choice != 3);\n\n}\n</iomanip></iostream></pre> </article> ','<article class="article"> <h1>Лекция 6 (5.11.2024)</h1> </article> <div id="link-to-dsr2024cpp" class="btn-back">назад</div> <article class="article"> <h2>Содержание</h2> <p><a href="#lamb">Лямбда-функции</a></p> <p><a href="#lamb1">Определение лямбда-функций</a></p> <p><a href="#lamb2">"Захват" лямбда-выражения</a></p> <p><a href="#lamb3">Примеры использования</a></p> <p><a href="#t1">Код программы</a></p> </article> <article class="article"> <div class="anchor" id="lamb"></div> <h3>Лямбда-функции</h3> </article> <article class="article"> <div class="anchor" id="lamb1"></div> <h3>Определение лямбда-функций</h3> <pre>\n     1   2     3       4       5\n     |   |     |       |       |\n    --- --- ------- ------- --------\n    [=] ()  mutable throw() -> int\n  |  {\n  |    int n = x + y;\n  |\n  |    x = y;\n6-|    y = n;\n  |\n  |    return n;\n  |  }\n</pre> <ol> <li>Capture clause - список внешних захватываемых параметров</li> <li>Список передаваемых параметров</li> <li>Спецификация изменений</li> <li>Спецификация исключений</li> <li>Тип возвращаемого значения</li> <li>Тело функции</li> </ol> </article> <article class="article"> <div class="anchor" id="lamb2"></div> <h3>"Захват" лямбда-выражения</h3> <ol> <li> <h4>По значению</h4> <pre>\nint n{10};\nstd::function&lt;void(int)&gt; add =\n       [=](int x) { std::cout &lt;&lt; x + n &lt;&lt; std::endl; };\n\nadd(5); // выведет 15\n</pre> <p>[=] Внешнюю переменную n изменять нельзя - программа не скомпилируется</p> </li> <li> <h4>По ссылке</h4> <pre>\nint n{10};\nstd::function&lt;void(int)&gt; add =\n       [&](int x) { std::cout &lt;&lt; x + ++n &lt;&lt; std::endl; };\n\nadd(5); // выведет 16\ncout &lt;&lt; n; // выведет 11\n</pre> <p>[&] Внешнюю переменную n изменять можно. Она также изменится за пределами функции</p> </li> <li> <h4>mutable</h4> <pre>\n#include &lt;iostream&gt;\n\nint main()\n{\n  int n{10};\n  auto increment = [=]() mutable {\n    n++; // увеличиваем значение внешней переменной\n    std::cout &lt;&lt; "n inside lambda: " &lt;&lt; n &lt;&lt; std::endl;\n  };\n  increment();\n  std::cout &lt;&lt; "n outside lambda: " &lt;&lt; n &lt;&lt; std::endl;\n}\n</pre> <p>mutable Внешняя переменная n передается по значению, но внутри лямбда-выражения ее можно изменять. За пределами она не изменится</p> </li> <li> <h4>Все по значению, кроме одной по ссылке</h4> <pre>\nint n{10}, n_2{ 8 };\nauto add = [=, &n](int x)\n{ std::cout &lt;&lt; x + ++n + n_2 &lt;&lt; std::endl; };\n\nadd(5); // выведет 24\ncout &lt;&lt; nl // выведет 11\n</pre> <p>[=, &n] все переменные передаются по значению и их изменять нельзя, но переменная n передается по ссылке и ее изменять можно. За пределами функции она тоже изменится.</p> </li> <li> <h4>Ошибка</h4> <pre>\nint n{10}, n_2{ 8 };\nauto add = [&, &n](int x)\n{ std::cout &lt;&lt; x + ++n + n_2 &lt;&lt; std::endl; };\n\nadd(5); // ошибка\ncout &lt;&lt; n_2; // ошибка\n</pre> <p>[&, &n] все переменные передаются по ссылке и переменная n тоже передается по ссылке. Это условие избыточное. Компилироваться такая строчка не будет</p> </li> <li> <h4>Все по значению, кроме одной по ссылке</h4> <pre>\n#include &lt;iostream&gt;\n#include &lt;function&gt;\n\nusing namespace std;\n\nint main()\n{\n  int n{ 10 }, n_2{ 8 };\n  std::function&lt;void(int)&gt; lambda_func = [=, &n_2](int x)\n  { std::cout &lt;&lt; x + ++n_2 - n &lt;&lt; std::endl; };\n\n  lambda_func(5); // выведет 13\n}\n</pre> <p>[=, &n_2] все переменные передаются по значению и их изменять нельзя, но переменная n_2 передается по ссылке и ее изменять можно. За пределами функции она тоже изменится.</p> </li> </ol> </article> <article class="article"> <div class="anchor" id="lamb3"></div> <h3>Примеры использования</h3> <ol> <li> <h4>Логические выражения. Передача по значению</h4> <pre>\nint n{ 4 };\nstd::function&lt;bool(int)&gt; lambda_func_bool =\n       [](int x) { return x &gt; 1 && x &lt; 3; };\ncout &lt;&lt; lambda_func_bool(n); // 0\n\ndouble r{ 5 };\ndouble x{ 4 }, y{ 2 };\nauto lambda_func_r =\n       [r](double x, double y) { return x * x + y * y &lt;= r * r; };\ncout &lt;&lt; lambda_func_r(x, y); // 1\n\nr = 1;\ncout &lt;&lt; lambda_func_r(x, y); // 1\n</pre> <p>[r] переменная r передается по значению и равна значению, которое было при первом вызове лямбда-функции. Если после вызова лямбда-функции переменную r изменить, то при следующем вызове лямбда-функции все равно останется ее старое значение</p> </li> <li> <h4>Логические выражения. Передача по ссылке</h4> <pre>\nint n{ 4 };\nstd::function&lt;bool(int)&gt; lambda_func_bool =\n       [](int x) { return x &gt; 1 && x &lt; 3; };\ncout &lt;&lt; lambda_func_bool(n); // 0\n\ndouble r{ 5 };\ndouble x{ 4 }, y{ 2 };\nauto lambda_func_r =\n       [&r](double x, double y) { return x * x + y * y &lt;= r * r; };\ncout &lt;&lt; lambda_func_r(x, y); // 1\n\nr = 1;\ncout &lt;&lt; lambda_func_r(x, y); // 0\n</pre> <p>[&r] переменная r передается по ссылке. Если после вызова лямбда-функции переменную r изменить, то при следующем вызове лямбда-функции она тоже изменится</p> </li> <li> <h4>Замена переменных</h4> <pre>\ndouble a{ 4 }, b{ 2 };\nstd::function&lt;void(double&, double&)&gt; lambda_func_swap\n= [](double& x, double& y)\n{\n  double temp = x;\n  x = y;\n  y = temp;\n};\n\nlambda_func_swap(a, b);\ncout &lt;&lt; a &lt;&lt; " " &lt;&lt; b; // 2 4\n</pre> </li> </ol> </article> <article class="article"> <div class="anchor" id="t1"></div> <h3>Код программы</h3> <p>Вынесем в отдельный файл функцию</p> <p>Файл Series.cpp</p> <pre>\n#include "Series.h"\n\nint menu() {\n  std::cout &lt;&lt; "Введите 1 - Сумма ряда" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Введите 2 - Сумма ряда c погрешностью" &lt;&lt; std::endl;\n  std::cout &lt;&lt; "Введите 3 - Завершение программы" &lt;&lt; std::endl;\n\n  int choice{};\n  get_value<int>(choice, [](int temp) { return temp >= 1 && temp &lt;= 3; },\n  "Введите значение в диапазоне от 1 до 3\\n");\n\n\treturn choice;\n}\n//void get_value(int& choice, std::function&lt;bool(int)&gt;\n//condition, const std::string& message)\n//{\n//  std::cout &lt;&lt; message &lt;&lt; std::endl;\n//\n//  do {\n//    std::cin >> choice;\n//    if (!std::cin.fail() && condition(choice))\n//    {\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//      return;\n//    }\n//    else\n//    {\n//      std::cout &lt;&lt; message &lt;&lt; std::endl;\n//      std::cin.clear();\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//    }\n//  } while (true);\n//}\n//void get_value(double& x, std::function&lt;bool(double)&gt;\n//condition, const std::string& message)\n//{\n//  std::cout &lt;&lt; message &lt;&lt; std::endl;\n//\n//  do {\n//    std::cin >> x;\n//    if (!std::cin.fail() && condition(x))\n//    {\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//      return;\n//    }\n//    else\n//    {\n//      std::cout &lt;&lt; message &lt;&lt; std::endl;\n//      std::cin.clear();\n//      std::cin.ignore(std::cin.rdbuf()->in_avail());\n//    }\n//  } while (true);\n//}\n\ndouble sum_series(double x, int n)\n{\n  double Sn{};\n  double ai{ x };\n  for (int i = 1; i &lt; n; i++)\n  {\n    Sn += ai;\n    ai *= (-1) * (x * x) / (2 * i * (2 * i + 1));\n  }\n  return Sn;\n}\n\ndouble sum_series(double x, int& count, double eps)\n{\n  double Sn{};\n  double ai{ x };\n\n  for (count = 1; abs(ai) >= eps; count++)\n  {\n    Sn += ai;\n    ai *= (-1) * (x * x) / (2 * count * (2 * count + 1));\n  }\n  return Sn;\n}\n\nvoid print_answer(double Sn, const std::string& message, int n)\n{\n  std::cout&lt;&lt;std::setw(35) &lt;&lt; std::left &lt;&lt; message &lt;&lt; std::fixed\n  &lt;&lt; std::setprecision(20) &lt;&lt; Sn &lt;&lt; std::endl;\n  if (n > 0)\n  {\n    std::cout &lt;&lt; std::setw(35) &lt;&lt; std::left\n    &lt;&lt; "Количество элементов ряда" &lt;&lt; std::fixed &lt;&lt; n &lt;&lt; std::endl;\n  }\n}\n</int></pre> <p>Файл Series.h</p> <pre>\n#pragma once\n#include <iostream>\n#include <iomanip>\n#include <functional>\n\nint menu();\n//void get_value(int& choice, std::function<bool (int)> condition, const std::string& message);\n//void get_value(double& x, std::function<bool (double)> condition, const std::string& message);\n\ndouble sum_series(double x, int n);\ndouble sum_series(double x, int& count, double eps);\nvoid print_answer(double Sn, const std::string& message, int n = 0);\n\ntemplate&lt;typename T&gt;\nvoid get_value(T& x, std::function&lt;bool(T)&gt; condition, const std::string& message)\n{\n  std::cout &lt;&lt; message &lt;&lt; std::endl;\n\n  do {\n    std::cin >> x;\n    if (!std::cin.fail() && condition(x))\n    {\n      std::cin.ignore(std::cin.rdbuf()->in_avail());\n      return;\n    }\n    else\n    {\n      std::cout &lt;&lt; message &lt;&lt; std::endl;\n      std::cin.clear();\n      std::cin.ignore(std::cin.rdbuf()->in_avail());\n    }\n  } while (true);\n}\n</bool></bool></functional></iomanip></iostream></pre> <p>Основная программа примет вид</p> <p>Файл main.c</p> <pre>\n#include "Series.h"\n\nint main()\n{\n  setlocale(LC_ALL, "Russian");\n\n  int choice{};\n  do\n  {\n    choice = menu();\n\n    if (choice != 3)\n    {\n      double x{};\n      get_value<double>(x, [](double temp) {return abs(temp) &lt;= 1; }, "Введите x  от -1 до 1\\n");\n\n      if (choice == 1)\n      {\n        double Sn{};\n        int N{};\n        get_value<int>(N, [](int temp) {return temp > 0; }, "Введите количество элементов ряда N, где N > 0");\n\n        Sn = sum_series(x, N);\n        print_answer(Sn, "Приближенное значение", N);\n      }\n      else if (choice == 2)\n      {\n        int count{};\n        double eps = 1.0E-12;\n\n        for (int j{ 0 }; j &lt; 2; j++)\n        {\n          double Sn{};\n          Sn = sum_series(x, count, eps);\n          print_answer(Sn, "Приближенное значение", count);\n          print_answer(sin(x), "Точное значение");\n\n          eps /= 100;\n        }\n      }\n    }\n\n    char isExit{};\n    std::cout &lt;&lt; "Хотите завершить работу? (Y/y - завершить, любое другое значение - нет)" &lt;&lt; std::endl;\n    std::cin >> isExit;\n\n    if (isExit == \'Y\' || isExit == \'y\')\n    {\n      choice = 3;\n    }\n  } while (choice != 3);\n}\n</int></double></pre> </article> '];function d(){var n=document.querySelector(".lections");console.log(n);var t=document.querySelectorAll(".js-dsr-lecture");if(t){console.log(t);for(var e=function(e){t[e].addEventListener("click",(function(t){t.preventDefault(),s[e]&&(n.innerHTML=s[e],function(){var n=document.querySelector(".lections"),t=document.getElementById("link-to-dsr2024cpp");t&&t.addEventListener("click",(function(t){t.preventDefault(),n.innerHTML=c,d()}))}())}))},l=0;l<t.length;l++)e(l)}}var p,u,h=document.getElementById("maincomponent"),b=document.createElement("section");function f(n){return f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},f(n)}function m(){m=function(){return n};var n={},t=Object.prototype,e=t.hasOwnProperty,l=Object.defineProperty||function(n,t,e){n[t]=e.value},i="function"==typeof Symbol?Symbol:{},r=i.iterator||"@@iterator",a=i.asyncIterator||"@@asyncIterator",o=i.toStringTag||"@@toStringTag";function c(n,t,e){return Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}),n[t]}try{c({},"")}catch(n){c=function(n,t,e){return n[t]=e}}function s(n,t,e,i){var r=t&&t.prototype instanceof u?t:u,a=Object.create(r.prototype),o=new j(i||[]);return l(a,"_invoke",{value:S(n,e,o)}),a}function d(n,t,e){try{return{type:"normal",arg:n.call(t,e)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var p={};function u(){}function h(){}function b(){}var v={};c(v,r,(function(){return this}));var x=Object.getPrototypeOf,y=x&&x(x(L([])));y&&y!==t&&e.call(y,r)&&(v=y);var g=b.prototype=u.prototype=Object.create(v);function _(n){["next","throw","return"].forEach((function(t){c(n,t,(function(n){return this._invoke(t,n)}))}))}function w(n,t){function i(l,r,a,o){var c=d(n[l],n,r);if("throw"!==c.type){var s=c.arg,p=s.value;return p&&"object"==f(p)&&e.call(p,"__await")?t.resolve(p.__await).then((function(n){i("next",n,a,o)}),(function(n){i("throw",n,a,o)})):t.resolve(p).then((function(n){s.value=n,a(s)}),(function(n){return i("throw",n,a,o)}))}o(c.arg)}var r;l(this,"_invoke",{value:function(n,e){function l(){return new t((function(t,l){i(n,e,t,l)}))}return r=r?r.then(l,l):l()}})}function S(n,t,e){var l="suspendedStart";return function(i,r){if("executing"===l)throw new Error("Generator is already running");if("completed"===l){if("throw"===i)throw r;return{value:void 0,done:!0}}for(e.method=i,e.arg=r;;){var a=e.delegate;if(a){var o=E(a,e);if(o){if(o===p)continue;return o}}if("next"===e.method)e.sent=e._sent=e.arg;else if("throw"===e.method){if("suspendedStart"===l)throw l="completed",e.arg;e.dispatchException(e.arg)}else"return"===e.method&&e.abrupt("return",e.arg);l="executing";var c=d(n,t,e);if("normal"===c.type){if(l=e.done?"completed":"suspendedYield",c.arg===p)continue;return{value:c.arg,done:e.done}}"throw"===c.type&&(l="completed",e.method="throw",e.arg=c.arg)}}}function E(n,t){var e=t.method,l=n.iterator[e];if(void 0===l)return t.delegate=null,"throw"===e&&n.iterator.return&&(t.method="return",t.arg=void 0,E(n,t),"throw"===t.method)||"return"!==e&&(t.method="throw",t.arg=new TypeError("The iterator does not provide a '"+e+"' method")),p;var i=d(l,n.iterator,t.arg);if("throw"===i.type)return t.method="throw",t.arg=i.arg,t.delegate=null,p;var r=i.arg;return r?r.done?(t[n.resultName]=r.value,t.next=n.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,p):r:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,p)}function k(n){var t={tryLoc:n[0]};1 in n&&(t.catchLoc=n[1]),2 in n&&(t.finallyLoc=n[2],t.afterLoc=n[3]),this.tryEntries.push(t)}function M(n){var t=n.completion||{};t.type="normal",delete t.arg,n.completion=t}function j(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(k,this),this.reset(!0)}function L(n){if(n){var t=n[r];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var l=-1,i=function t(){for(;++l<n.length;)if(e.call(n,l))return t.value=n[l],t.done=!1,t;return t.value=void 0,t.done=!0,t};return i.next=i}}return{next:P}}function P(){return{value:void 0,done:!0}}return h.prototype=b,l(g,"constructor",{value:b,configurable:!0}),l(b,"constructor",{value:h,configurable:!0}),h.displayName=c(b,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var t="function"==typeof n&&n.constructor;return!!t&&(t===h||"GeneratorFunction"===(t.displayName||t.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,b):(n.__proto__=b,c(n,o,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},_(w.prototype),c(w.prototype,a,(function(){return this})),n.AsyncIterator=w,n.async=function(t,e,l,i,r){void 0===r&&(r=Promise);var a=new w(s(t,e,l,i),r);return n.isGeneratorFunction(e)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},_(g),c(g,o,"Generator"),c(g,r,(function(){return this})),c(g,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var t=Object(n),e=[];for(var l in t)e.push(l);return e.reverse(),function n(){for(;e.length;){var l=e.pop();if(l in t)return n.value=l,n.done=!1,n}return n.done=!0,n}},n.values=L,j.prototype={constructor:j,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(M),!n)for(var t in this)"t"===t.charAt(0)&&e.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var t=this;function l(e,l){return a.type="throw",a.arg=n,t.next=e,l&&(t.method="next",t.arg=void 0),!!l}for(var i=this.tryEntries.length-1;i>=0;--i){var r=this.tryEntries[i],a=r.completion;if("root"===r.tryLoc)return l("end");if(r.tryLoc<=this.prev){var o=e.call(r,"catchLoc"),c=e.call(r,"finallyLoc");if(o&&c){if(this.prev<r.catchLoc)return l(r.catchLoc,!0);if(this.prev<r.finallyLoc)return l(r.finallyLoc)}else if(o){if(this.prev<r.catchLoc)return l(r.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<r.finallyLoc)return l(r.finallyLoc)}}}},abrupt:function(n,t){for(var l=this.tryEntries.length-1;l>=0;--l){var i=this.tryEntries[l];if(i.tryLoc<=this.prev&&e.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var r=i;break}}r&&("break"===n||"continue"===n)&&r.tryLoc<=t&&t<=r.finallyLoc&&(r=null);var a=r?r.completion:{};return a.type=n,a.arg=t,r?(this.method="next",this.next=r.finallyLoc,p):this.complete(a)},complete:function(n,t){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&t&&(this.next=t),p},finish:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.finallyLoc===n)return this.complete(e.completion,e.afterLoc),M(e),p}},catch:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var e=this.tryEntries[t];if(e.tryLoc===n){var l=e.completion;if("throw"===l.type){var i=l.arg;M(e)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,t,e){return this.delegate={iterator:L(n),resultName:t,nextLoc:e},"next"===this.method&&(this.arg=void 0),p}},n}function v(n,t,e,l,i,r,a){try{var o=n[r](a),c=o.value}catch(n){return void e(n)}o.done?t(c):Promise.resolve(c).then(l,i)}function x(){var n;return n=m().mark((function n(t){return m().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:document.querySelector("#page").appendChild(t);case 2:case"end":return n.stop()}}),n)})),x=function(){var t=this,e=arguments;return new Promise((function(l,i){var r=n.apply(t,e);function a(n){v(r,l,i,a,o,"next",n)}function o(n){v(r,l,i,a,o,"throw",n)}a(void 0)}))},x.apply(this,arguments)}b.classList.add("lections"),h.append(b),(p=document.createElement("div")).classList.add("btn-up","none"),p.innerHTML="НАВЕРХ",p.addEventListener("click",(function(){window.scrollTo({top:0,left:0,behavior:"smooth"})})),window.addEventListener("scroll",(function(){return function(n){(window.scrollY||document.documentElement.scrollTop)>400?n.classList.remove("none"):n.classList.add("none")}(p)})),function(n){x.apply(this,arguments)}(p),u=document.querySelector(".lections"),console.log(u),document.querySelector(".lections").innerHTML=c,d()})();
//# sourceMappingURL=index.js.map